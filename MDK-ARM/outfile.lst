
========================================================================

** ELF Header Information

    File Name: C:\STM32\project\efeed\MDK-ARM\efeed\efeed.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x080000ed
    Flags: EF_ARM_HASENTRY + EF_ARM_ABI_FLOAT_SOFT (0x05000202)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Soft float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armasm [4d35cf]
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armlink [4d35d2]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 1
    Section header entries: 16

    Program header offset: 820944 (0x000c86d0)
    Section header offset: 820976 (0x000c86f0)

    Section header string table index: 15

========================================================================

** Program header #0 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 32300 bytes (16536 bytes in file)
    Virtual address: 0x08000000 (Alignment 8)


========================================================================

** Section #1 'ER_IROM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 15912 bytes (alignment 8)
    Address: 0x08000000

    $d.realdata
    RESET
    __Vectors
        0x08000000:    20001008    ...     DCD    536875016
        0x08000004:    08000101    ....    DCD    134217985
        0x08000008:    08000109    ....    DCD    134217993
        0x0800000c:    0800010b    ....    DCD    134217995
        0x08000010:    0800010d    ....    DCD    134217997
        0x08000014:    0800010f    ....    DCD    134217999
        0x08000018:    08000111    ....    DCD    134218001
        0x0800001c:    00000000    ....    DCD    0
        0x08000020:    00000000    ....    DCD    0
        0x08000024:    00000000    ....    DCD    0
        0x08000028:    00000000    ....    DCD    0
        0x0800002c:    08001965    e...    DCD    134224229
        0x08000030:    08000115    ....    DCD    134218005
        0x08000034:    00000000    ....    DCD    0
        0x08000038:    0800157d    }...    DCD    134223229
        0x0800003c:    08001969    i...    DCD    134224233
        0x08000040:    0800011b    ....    DCD    134218011
        0x08000044:    0800011b    ....    DCD    134218011
        0x08000048:    0800011b    ....    DCD    134218011
        0x0800004c:    0800011b    ....    DCD    134218011
        0x08000050:    0800011b    ....    DCD    134218011
        0x08000054:    0800011b    ....    DCD    134218011
        0x08000058:    0800011b    ....    DCD    134218011
        0x0800005c:    0800011b    ....    DCD    134218011
        0x08000060:    0800011b    ....    DCD    134218011
        0x08000064:    0800011b    ....    DCD    134218011
        0x08000068:    0800011b    ....    DCD    134218011
        0x0800006c:    0800011b    ....    DCD    134218011
        0x08000070:    0800011b    ....    DCD    134218011
        0x08000074:    0800011b    ....    DCD    134218011
        0x08000078:    08000299    ....    DCD    134218393
        0x0800007c:    0800011b    ....    DCD    134218011
        0x08000080:    0800011b    ....    DCD    134218011
        0x08000084:    0800011b    ....    DCD    134218011
        0x08000088:    0800011b    ....    DCD    134218011
        0x0800008c:    0800011b    ....    DCD    134218011
        0x08000090:    0800011b    ....    DCD    134218011
        0x08000094:    0800011b    ....    DCD    134218011
        0x08000098:    0800011b    ....    DCD    134218011
        0x0800009c:    0800011b    ....    DCD    134218011
        0x080000a0:    0800011b    ....    DCD    134218011
        0x080000a4:    08001b39    9...    DCD    134224697
        0x080000a8:    0800011b    ....    DCD    134218011
        0x080000ac:    0800011b    ....    DCD    134218011
        0x080000b0:    08001b59    Y...    DCD    134224729
        0x080000b4:    0800011b    ....    DCD    134218011
        0x080000b8:    08001bd9    ....    DCD    134224857
        0x080000bc:    0800011b    ....    DCD    134218011
        0x080000c0:    0800011b    ....    DCD    134218011
        0x080000c4:    080003f5    ....    DCD    134218741
        0x080000c8:    080003f1    ....    DCD    134218737
        0x080000cc:    0800011b    ....    DCD    134218011
        0x080000d0:    0800011b    ....    DCD    134218011
        0x080000d4:    0800011b    ....    DCD    134218011
        0x080000d8:    0800011b    ....    DCD    134218011
        0x080000dc:    0800011b    ....    DCD    134218011
        0x080000e0:    0800011b    ....    DCD    134218011
        0x080000e4:    0800011b    ....    DCD    134218011
        0x080000e8:    0800011b    ....    DCD    134218011
    $t
    .ARM.Collect$$$$00000000
    .ARM.Collect$$$$00000001
    __Vectors_End
    __main
    _main_stk
        0x080000ec:    f8dfd00c    ....    LDR      sp,__lit__00000000 ; [0x80000fc] = 0x20001008
    .ARM.Collect$$$$00000004
    _main_scatterload
        0x080000f0:    f000f87a    ..z.    BL       __scatterload ; 0x80001e8
    .ARM.Collect$$$$00000008
    .ARM.Collect$$$$0000000A
    .ARM.Collect$$$$0000000B
    __main_after_scatterload
    _main_clock
    _main_cpp_init
    _main_init
        0x080000f4:    4800        .H      LDR      r0,[pc,#0] ; [0x80000f8] = 0x80024c1
        0x080000f6:    4700        .G      BX       r0
    $d
        0x080000f8:    080024c1    .$..    DCD    134227137
    .ARM.Collect$$$$00002712
    __lit__00000000
    .ARM.Collect$$$$0000000D
    .ARM.Collect$$$$0000000F
    __rt_final_cpp
    __rt_final_exit
        0x080000fc:    20001008    ...     DCD    536875016
    $t
    .text
    Reset_Handler
;;;150                     LDR     R0, =SystemInit
        0x08000100:    4806        .H      LDR      r0,[pc,#24] ; [0x800011c] = 0x8001ae1
;;;151                     BLX     R0
        0x08000102:    4780        .G      BLX      r0
;;;152                     LDR     R0, =__main
        0x08000104:    4806        .H      LDR      r0,[pc,#24] ; [0x8000120] = 0x80000ed
;;;153                     BX      R0
        0x08000106:    4700        .G      BX       r0
    NMI_Handler
;;;154                     ENDP
;;;155    
;;;156    ; Dummy Exception Handlers (infinite loops which can be modified)
;;;157    
;;;158    NMI_Handler     PROC
;;;159                    EXPORT  NMI_Handler                [WEAK]
;;;160                    B       .
        0x08000108:    e7fe        ..      B        NMI_Handler ; 0x8000108
    HardFault_Handler
;;;161                    ENDP
;;;162    HardFault_Handler\
;;;163                    PROC
;;;164                    EXPORT  HardFault_Handler          [WEAK]
;;;165                    B       .
        0x0800010a:    e7fe        ..      B        HardFault_Handler ; 0x800010a
    MemManage_Handler
;;;166                    ENDP
;;;167    MemManage_Handler\
;;;168                    PROC
;;;169                    EXPORT  MemManage_Handler          [WEAK]
;;;170                    B       .
        0x0800010c:    e7fe        ..      B        MemManage_Handler ; 0x800010c
    BusFault_Handler
;;;171                    ENDP
;;;172    BusFault_Handler\
;;;173                    PROC
;;;174                    EXPORT  BusFault_Handler           [WEAK]
;;;175                    B       .
        0x0800010e:    e7fe        ..      B        BusFault_Handler ; 0x800010e
    UsageFault_Handler
;;;176                    ENDP
;;;177    UsageFault_Handler\
;;;178                    PROC
;;;179                    EXPORT  UsageFault_Handler         [WEAK]
;;;180                    B       .
        0x08000110:    e7fe        ..      B        UsageFault_Handler ; 0x8000110
;;;181                    ENDP
;;;182    SVC_Handler     PROC
;;;183                    EXPORT  SVC_Handler                [WEAK]
;;;184                    B       .
        0x08000112:    e7fe        ..      B        0x8000112 ; UsageFault_Handler + 2
    DebugMon_Handler
;;;185                    ENDP
;;;186    DebugMon_Handler\
;;;187                    PROC
;;;188                    EXPORT  DebugMon_Handler           [WEAK]
;;;189                    B       .
        0x08000114:    e7fe        ..      B        DebugMon_Handler ; 0x8000114
;;;190                    ENDP
;;;191    PendSV_Handler  PROC
;;;192                    EXPORT  PendSV_Handler             [WEAK]
;;;193                    B       .
        0x08000116:    e7fe        ..      B        0x8000116 ; DebugMon_Handler + 2
;;;194                    ENDP
;;;195    SysTick_Handler PROC
;;;196                    EXPORT  SysTick_Handler            [WEAK]
;;;197                    B       .
        0x08000118:    e7fe        ..      B        0x8000118 ; DebugMon_Handler + 4
    ADC1_2_IRQHandler
    CAN1_RX1_IRQHandler
    CAN1_SCE_IRQHandler
    DMA1_Channel1_IRQHandler
    DMA1_Channel2_IRQHandler
    DMA1_Channel3_IRQHandler
    DMA1_Channel5_IRQHandler
    DMA1_Channel6_IRQHandler
    DMA1_Channel7_IRQHandler
    EXTI0_IRQHandler
    EXTI15_10_IRQHandler
    EXTI1_IRQHandler
    EXTI2_IRQHandler
    EXTI3_IRQHandler
    EXTI4_IRQHandler
    EXTI9_5_IRQHandler
    FLASH_IRQHandler
    I2C1_ER_IRQHandler
    I2C1_EV_IRQHandler
    PVD_IRQHandler
    RCC_IRQHandler
    RTC_Alarm_IRQHandler
    RTC_IRQHandler
    SPI1_IRQHandler
    SPI2_IRQHandler
    TAMPER_IRQHandler
    TIM1_BRK_IRQHandler
    TIM1_CC_IRQHandler
    TIM1_TRG_COM_IRQHandler
    TIM3_IRQHandler
    USART1_IRQHandler
    USART2_IRQHandler
    USART3_IRQHandler
    USBWakeUp_IRQHandler
    USB_HP_CAN1_TX_IRQHandler
    USB_LP_CAN1_RX0_IRQHandler
    WWDG_IRQHandler
;;;198                    ENDP
;;;199    
;;;200    Default_Handler PROC
;;;201    
;;;202                    EXPORT  WWDG_IRQHandler            [WEAK]
;;;203                    EXPORT  PVD_IRQHandler             [WEAK]
;;;204                    EXPORT  TAMPER_IRQHandler          [WEAK]
;;;205                    EXPORT  RTC_IRQHandler             [WEAK]
;;;206                    EXPORT  FLASH_IRQHandler           [WEAK]
;;;207                    EXPORT  RCC_IRQHandler             [WEAK]
;;;208                    EXPORT  EXTI0_IRQHandler           [WEAK]
;;;209                    EXPORT  EXTI1_IRQHandler           [WEAK]
;;;210                    EXPORT  EXTI2_IRQHandler           [WEAK]
;;;211                    EXPORT  EXTI3_IRQHandler           [WEAK]
;;;212                    EXPORT  EXTI4_IRQHandler           [WEAK]
;;;213                    EXPORT  DMA1_Channel1_IRQHandler   [WEAK]
;;;214                    EXPORT  DMA1_Channel2_IRQHandler   [WEAK]
;;;215                    EXPORT  DMA1_Channel3_IRQHandler   [WEAK]
;;;216                    EXPORT  DMA1_Channel4_IRQHandler   [WEAK]
;;;217                    EXPORT  DMA1_Channel5_IRQHandler   [WEAK]
;;;218                    EXPORT  DMA1_Channel6_IRQHandler   [WEAK]
;;;219                    EXPORT  DMA1_Channel7_IRQHandler   [WEAK]
;;;220                    EXPORT  ADC1_2_IRQHandler          [WEAK]
;;;221                    EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]
;;;222                    EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]
;;;223                    EXPORT  CAN1_RX1_IRQHandler        [WEAK]
;;;224                    EXPORT  CAN1_SCE_IRQHandler        [WEAK]
;;;225                    EXPORT  EXTI9_5_IRQHandler         [WEAK]
;;;226                    EXPORT  TIM1_BRK_IRQHandler        [WEAK]
;;;227                    EXPORT  TIM1_UP_IRQHandler         [WEAK]
;;;228                    EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]
;;;229                    EXPORT  TIM1_CC_IRQHandler         [WEAK]
;;;230                    EXPORT  TIM2_IRQHandler            [WEAK]
;;;231                    EXPORT  TIM3_IRQHandler            [WEAK]
;;;232                    EXPORT  TIM4_IRQHandler            [WEAK]
;;;233                    EXPORT  I2C1_EV_IRQHandler         [WEAK]
;;;234                    EXPORT  I2C1_ER_IRQHandler         [WEAK]
;;;235                    EXPORT  I2C2_EV_IRQHandler         [WEAK]
;;;236                    EXPORT  I2C2_ER_IRQHandler         [WEAK]
;;;237                    EXPORT  SPI1_IRQHandler            [WEAK]
;;;238                    EXPORT  SPI2_IRQHandler            [WEAK]
;;;239                    EXPORT  USART1_IRQHandler          [WEAK]
;;;240                    EXPORT  USART2_IRQHandler          [WEAK]
;;;241                    EXPORT  USART3_IRQHandler          [WEAK]
;;;242                    EXPORT  EXTI15_10_IRQHandler       [WEAK]
;;;243                    EXPORT  RTC_Alarm_IRQHandler        [WEAK]
;;;244                    EXPORT  USBWakeUp_IRQHandler       [WEAK]
;;;245    
;;;246    WWDG_IRQHandler
;;;247    PVD_IRQHandler
;;;248    TAMPER_IRQHandler
;;;249    RTC_IRQHandler
;;;250    FLASH_IRQHandler
;;;251    RCC_IRQHandler
;;;252    EXTI0_IRQHandler
;;;253    EXTI1_IRQHandler
;;;254    EXTI2_IRQHandler
;;;255    EXTI3_IRQHandler
;;;256    EXTI4_IRQHandler
;;;257    DMA1_Channel1_IRQHandler
;;;258    DMA1_Channel2_IRQHandler
;;;259    DMA1_Channel3_IRQHandler
;;;260    DMA1_Channel4_IRQHandler
;;;261    DMA1_Channel5_IRQHandler
;;;262    DMA1_Channel6_IRQHandler
;;;263    DMA1_Channel7_IRQHandler
;;;264    ADC1_2_IRQHandler
;;;265    USB_HP_CAN1_TX_IRQHandler
;;;266    USB_LP_CAN1_RX0_IRQHandler
;;;267    CAN1_RX1_IRQHandler
;;;268    CAN1_SCE_IRQHandler
;;;269    EXTI9_5_IRQHandler
;;;270    TIM1_BRK_IRQHandler
;;;271    TIM1_UP_IRQHandler
;;;272    TIM1_TRG_COM_IRQHandler
;;;273    TIM1_CC_IRQHandler
;;;274    TIM2_IRQHandler
;;;275    TIM3_IRQHandler
;;;276    TIM4_IRQHandler
;;;277    I2C1_EV_IRQHandler
;;;278    I2C1_ER_IRQHandler
;;;279    I2C2_EV_IRQHandler
;;;280    I2C2_ER_IRQHandler
;;;281    SPI1_IRQHandler
;;;282    SPI2_IRQHandler
;;;283    USART1_IRQHandler
;;;284    USART2_IRQHandler
;;;285    USART3_IRQHandler
;;;286    EXTI15_10_IRQHandler
;;;287    RTC_Alarm_IRQHandler
;;;288    USBWakeUp_IRQHandler
;;;289    
;;;290                    B       .
        0x0800011a:    e7fe        ..      B        ADC1_2_IRQHandler ; 0x800011a
    $d
        0x0800011c:    08001ae1    ....    DCD    134224609
        0x08000120:    080000ed    ....    DCD    134217965
    $t
    .text
    __aeabi_uldivmod
        0x08000124:    e92d5ff0    -.._    PUSH     {r4-r12,lr}
        0x08000128:    4605        .F      MOV      r5,r0
        0x0800012a:    2000        .       MOVS     r0,#0
        0x0800012c:    4692        .F      MOV      r10,r2
        0x0800012e:    469b        .F      MOV      r11,r3
        0x08000130:    4688        .F      MOV      r8,r1
        0x08000132:    4606        .F      MOV      r6,r0
        0x08000134:    4681        .F      MOV      r9,r0
        0x08000136:    2440        @$      MOVS     r4,#0x40
        0x08000138:    e01b        ..      B        0x8000172 ; __aeabi_uldivmod + 78
        0x0800013a:    4628        (F      MOV      r0,r5
        0x0800013c:    4641        AF      MOV      r1,r8
        0x0800013e:    4647        GF      MOV      r7,r8
        0x08000140:    4622        "F      MOV      r2,r4
        0x08000142:    f000f841    ..A.    BL       __aeabi_llsr ; 0x80001c8
        0x08000146:    4653        SF      MOV      r3,r10
        0x08000148:    465a        ZF      MOV      r2,r11
        0x0800014a:    1ac0        ..      SUBS     r0,r0,r3
        0x0800014c:    4191        .A      SBCS     r1,r1,r2
        0x0800014e:    d310        ..      BCC      0x8000172 ; __aeabi_uldivmod + 78
        0x08000150:    4611        .F      MOV      r1,r2
        0x08000152:    4618        .F      MOV      r0,r3
        0x08000154:    4622        "F      MOV      r2,r4
        0x08000156:    f000f828    ..(.    BL       __aeabi_llsl ; 0x80001aa
        0x0800015a:    1a2d        -.      SUBS     r5,r5,r0
        0x0800015c:    eb670801    g...    SBC      r8,r7,r1
        0x08000160:    464f        OF      MOV      r7,r9
        0x08000162:    4622        "F      MOV      r2,r4
        0x08000164:    2001        .       MOVS     r0,#1
        0x08000166:    2100        .!      MOVS     r1,#0
        0x08000168:    f000f81f    ....    BL       __aeabi_llsl ; 0x80001aa
        0x0800016c:    eb170900    ....    ADDS     r9,r7,r0
        0x08000170:    414e        NA      ADCS     r6,r6,r1
        0x08000172:    1e20         .      SUBS     r0,r4,#0
        0x08000174:    f1a40401    ....    SUB      r4,r4,#1
        0x08000178:    dcdf        ..      BGT      0x800013a ; __aeabi_uldivmod + 22
        0x0800017a:    4648        HF      MOV      r0,r9
        0x0800017c:    4631        1F      MOV      r1,r6
        0x0800017e:    462a        *F      MOV      r2,r5
        0x08000180:    4643        CF      MOV      r3,r8
        0x08000182:    e8bd9ff0    ....    POP      {r4-r12,pc}
    .text
    __aeabi_memset
    __aeabi_memset4
    __aeabi_memset8
        0x08000186:    b2d2        ..      UXTB     r2,r2
        0x08000188:    e001        ..      B        0x800018e ; __aeabi_memset + 8
        0x0800018a:    f8002b01    ...+    STRB     r2,[r0],#1
        0x0800018e:    1e49        I.      SUBS     r1,r1,#1
        0x08000190:    d2fb        ..      BCS      0x800018a ; __aeabi_memset + 4
        0x08000192:    4770        pG      BX       lr
    __aeabi_memclr
    __aeabi_memclr4
    __aeabi_memclr8
        0x08000194:    2200        ."      MOVS     r2,#0
        0x08000196:    e7f6        ..      B        __aeabi_memset ; 0x8000186
    _memset$wrapper
        0x08000198:    b510        ..      PUSH     {r4,lr}
        0x0800019a:    4613        .F      MOV      r3,r2
        0x0800019c:    460a        .F      MOV      r2,r1
        0x0800019e:    4604        .F      MOV      r4,r0
        0x080001a0:    4619        .F      MOV      r1,r3
        0x080001a2:    f7fffff0    ....    BL       __aeabi_memset ; 0x8000186
        0x080001a6:    4620         F      MOV      r0,r4
        0x080001a8:    bd10        ..      POP      {r4,pc}
    .text
    __aeabi_llsl
    _ll_shift_l
        0x080001aa:    2a20         *      CMP      r2,#0x20
        0x080001ac:    db04        ..      BLT      0x80001b8 ; __aeabi_llsl + 14
        0x080001ae:    3a20         :      SUBS     r2,r2,#0x20
        0x080001b0:    fa00f102    ....    LSL      r1,r0,r2
        0x080001b4:    2000        .       MOVS     r0,#0
        0x080001b6:    4770        pG      BX       lr
        0x080001b8:    4091        .@      LSLS     r1,r1,r2
        0x080001ba:    f1c20320    .. .    RSB      r3,r2,#0x20
        0x080001be:    fa20f303     ...    LSR      r3,r0,r3
        0x080001c2:    4319        .C      ORRS     r1,r1,r3
        0x080001c4:    4090        .@      LSLS     r0,r0,r2
        0x080001c6:    4770        pG      BX       lr
    .text
    __aeabi_llsr
    _ll_ushift_r
        0x080001c8:    2a20         *      CMP      r2,#0x20
        0x080001ca:    db04        ..      BLT      0x80001d6 ; __aeabi_llsr + 14
        0x080001cc:    3a20         :      SUBS     r2,r2,#0x20
        0x080001ce:    fa21f002    !...    LSR      r0,r1,r2
        0x080001d2:    2100        .!      MOVS     r1,#0
        0x080001d4:    4770        pG      BX       lr
        0x080001d6:    fa21f302    !...    LSR      r3,r1,r2
        0x080001da:    40d0        .@      LSRS     r0,r0,r2
        0x080001dc:    f1c20220    .. .    RSB      r2,r2,#0x20
        0x080001e0:    4091        .@      LSLS     r1,r1,r2
        0x080001e2:    4308        .C      ORRS     r0,r0,r1
        0x080001e4:    4619        .F      MOV      r1,r3
        0x080001e6:    4770        pG      BX       lr
    .text
    __scatterload
    __scatterload_rt2
        0x080001e8:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000204] = 0x8003e08
        0x080001ea:    4d07        .M      LDR      r5,[pc,#28] ; [0x8000208] = 0x8003e28
        0x080001ec:    e006        ..      B        0x80001fc ; __scatterload + 20
        0x080001ee:    68e0        .h      LDR      r0,[r4,#0xc]
        0x080001f0:    f0400301    @...    ORR      r3,r0,#1
        0x080001f4:    e8940007    ....    LDM      r4,{r0-r2}
        0x080001f8:    4798        .G      BLX      r3
        0x080001fa:    3410        .4      ADDS     r4,r4,#0x10
        0x080001fc:    42ac        .B      CMP      r4,r5
        0x080001fe:    d3f6        ..      BCC      0x80001ee ; __scatterload + 6
        0x08000200:    f7ffff78    ..x.    BL       __main_after_scatterload ; 0x80000f4
    $d
        0x08000204:    08003e08    .>..    DCD    134233608
        0x08000208:    08003e28    (>..    DCD    134233640
    $t
    .text
    __decompress
    __decompress1
        0x0800020c:    b570        p.      PUSH     {r4-r6,lr}
        0x0800020e:    188c        ..      ADDS     r4,r1,r2
        0x08000210:    f8105b01    ...[    LDRB     r5,[r0],#1
        0x08000214:    f0150307    ....    ANDS     r3,r5,#7
        0x08000218:    d101        ..      BNE      0x800021e ; __decompress + 18
        0x0800021a:    f8103b01    ...;    LDRB     r3,[r0],#1
        0x0800021e:    112a        *.      ASRS     r2,r5,#4
        0x08000220:    d106        ..      BNE      0x8000230 ; __decompress + 36
        0x08000222:    f8102b01    ...+    LDRB     r2,[r0],#1
        0x08000226:    e003        ..      B        0x8000230 ; __decompress + 36
        0x08000228:    f8106b01    ...k    LDRB     r6,[r0],#1
        0x0800022c:    f8016b01    ...k    STRB     r6,[r1],#1
        0x08000230:    1e5b        [.      SUBS     r3,r3,#1
        0x08000232:    d1f9        ..      BNE      0x8000228 ; __decompress + 28
        0x08000234:    072b        +.      LSLS     r3,r5,#28
        0x08000236:    d405        ..      BMI      0x8000244 ; __decompress + 56
        0x08000238:    2300        .#      MOVS     r3,#0
        0x0800023a:    1e52        R.      SUBS     r2,r2,#1
        0x0800023c:    d40d        ..      BMI      0x800025a ; __decompress + 78
        0x0800023e:    f8013b01    ...;    STRB     r3,[r1],#1
        0x08000242:    e7fa        ..      B        0x800023a ; __decompress + 46
        0x08000244:    f8103b01    ...;    LDRB     r3,[r0],#1
        0x08000248:    1acb        ..      SUBS     r3,r1,r3
        0x0800024a:    1c92        ..      ADDS     r2,r2,#2
        0x0800024c:    e003        ..      B        0x8000256 ; __decompress + 74
        0x0800024e:    f8135b01    ...[    LDRB     r5,[r3],#1
        0x08000252:    f8015b01    ...[    STRB     r5,[r1],#1
        0x08000256:    1e52        R.      SUBS     r2,r2,#1
        0x08000258:    d5f9        ..      BPL      0x800024e ; __decompress + 66
        0x0800025a:    42a1        .B      CMP      r1,r4
        0x0800025c:    d3d8        ..      BCC      0x8000210 ; __decompress + 4
        0x0800025e:    2000        .       MOVS     r0,#0
        0x08000260:    bd70        p.      POP      {r4-r6,pc}
        0x08000262:    0000        ..      MOVS     r0,r0
    i.Activate_I2C_Master
    Activate_I2C_Master
;;; .\..\Src\i2c_interface.c
;;;303      LL_I2C_Enable(I2C2);
        0x08000264:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;367      SET_BIT(I2Cx->CR1, I2C_CR1_PE);
        0x08000266:    480b        .H      LDR      r0,[pc,#44] ; [0x8000294] = 0x40005800
        0x08000268:    6800        .h      LDR      r0,[r0,#0]
        0x0800026a:    f0400001    @...    ORR      r0,r0,#1
        0x0800026e:    4909        .I      LDR      r1,[pc,#36] ; [0x8000294] = 0x40005800
        0x08000270:    6008        .`      STR      r0,[r1,#0]
;;;368    }
        0x08000272:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;309      LL_I2C_EnableIT_EVT(I2C2);
        0x08000274:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1004     SET_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN);
        0x08000276:    4608        .F      MOV      r0,r1
        0x08000278:    6840        @h      LDR      r0,[r0,#4]
        0x0800027a:    f4407000    @..p    ORR      r0,r0,#0x200
        0x0800027e:    6048        H`      STR      r0,[r1,#4]
;;;1005   }
        0x08000280:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;310      LL_I2C_EnableIT_ERR(I2C2);
        0x08000282:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1094     SET_BIT(I2Cx->CR2, I2C_CR2_ITERREN);
        0x08000284:    4608        .F      MOV      r0,r1
        0x08000286:    6840        @h      LDR      r0,[r0,#4]
        0x08000288:    f4407080    @..p    ORR      r0,r0,#0x100
        0x0800028c:    6048        H`      STR      r0,[r1,#4]
;;;1095   }
        0x0800028e:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;311    }
        0x08000290:    4770        pG      BX       lr
    $d
        0x08000292:    0000        ..      DCW    0
        0x08000294:    40005800    .X.@    DCD    1073764352
    $t
    i.DMA1_Channel4_IRQHandler
    DMA1_Channel4_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;158    {
        0x08000298:    b510        ..      PUSH     {r4,lr}
;;;159      /* USER CODE BEGIN DMA1_Channel4_IRQn 0 */
;;;160      if(LL_DMA_IsActiveFlag_TC4(DMA1))
        0x0800029a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1258     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF4) == (DMA_ISR_TCIF4));
        0x0800029c:    480b        .H      LDR      r0,[pc,#44] ; [0x80002cc] = 0x40020000
        0x0800029e:    6800        .h      LDR      r0,[r0,#0]
        0x080002a0:    f3c03040    ..@0    UBFX     r0,r0,#13,#1
        0x080002a4:    b140        @.      CBZ      r0,0x80002b8 ; DMA1_Channel4_IRQHandler + 32
;;; .\../Src/stm32f1xx_it.c
;;;162        LL_DMA_ClearFlag_GI4(DMA1);
        0x080002a6:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1489     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF4);
        0x080002a8:    f44f5080    O..P    MOV      r0,#0x1000
        0x080002ac:    4907        .I      LDR      r1,[pc,#28] ; [0x80002cc] = 0x40020000
        0x080002ae:    6048        H`      STR      r0,[r1,#4]
;;;1490   }
        0x080002b0:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;163        Transfer_Complete_Callback();
        0x080002b2:    f001fcbf    ....    BL       Transfer_Complete_Callback ; 0x8001c34
        0x080002b6:    e007        ..      B        0x80002c8 ; DMA1_Channel4_IRQHandler + 48
;;;164    //    DMA1_Transfer_Complete_Callback();
;;;165      }
;;;166      else if(LL_DMA_IsActiveFlag_TE4(DMA1))
        0x080002b8:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1412     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF4) == (DMA_ISR_TEIF4));
        0x080002ba:    4804        .H      LDR      r0,[pc,#16] ; [0x80002cc] = 0x40020000
        0x080002bc:    6800        .h      LDR      r0,[r0,#0]
        0x080002be:    f3c030c0    ...0    UBFX     r0,r0,#15,#1
        0x080002c2:    b108        ..      CBZ      r0,0x80002c8 ; DMA1_Channel4_IRQHandler + 48
;;; .\../Src/stm32f1xx_it.c
;;;168        Transfer_Error_Callback();
        0x080002c4:    f001fce0    ....    BL       Transfer_Error_Callback ; 0x8001c88
;;;169      }
;;;170    
;;;171      /* USER CODE END DMA1_Channel4_IRQn 0 */
;;;172      
;;;173      /* USER CODE BEGIN DMA1_Channel4_IRQn 1 */
;;;174    
;;;175      /* USER CODE END DMA1_Channel4_IRQn 1 */
;;;176    }
        0x080002c8:    bd10        ..      POP      {r4,pc}
    $d
        0x080002ca:    0000        ..      DCW    0
        0x080002cc:    40020000    ...@    DCD    1073872896
    $t
    i.Handle_I2C_MasterDMA_IT
    Handle_I2C_MasterDMA_IT
;;; .\..\Src\i2c_interface.c
;;;216    {
        0x080002d0:    e92d4ff8    -..O    PUSH     {r3-r11,lr}
        0x080002d4:    4604        .F      MOV      r4,r0
        0x080002d6:    468a        .F      MOV      r10,r1
        0x080002d8:    4617        .F      MOV      r7,r2
        0x080002da:    461d        .F      MOV      r5,r3
        0x080002dc:    f8dd8028    ..(.    LDR      r8,[sp,#0x28]
;;;217    	if(ubTransferComplete == 1){
        0x080002e0:    4823        #H      LDR      r0,[pc,#140] ; [0x8000370] = 0x20000027
        0x080002e2:    7800        .x      LDRB     r0,[r0,#0]
        0x080002e4:    2801        .(      CMP      r0,#1
        0x080002e6:    d103        ..      BNE      0x80002f0 ; Handle_I2C_MasterDMA_IT + 32
;;;218    		ubTransferComplete = 0;
        0x080002e8:    2000        .       MOVS     r0,#0
        0x080002ea:    4921        !I      LDR      r1,[pc,#132] ; [0x8000370] = 0x20000027
        0x080002ec:    7008        .p      STRB     r0,[r1,#0]
        0x080002ee:    e004        ..      B        0x80002fa ; Handle_I2C_MasterDMA_IT + 42
;;;219    	} else {
;;;220      	while(!ubTransferComplete)
        0x080002f0:    bf00        ..      NOP      
        0x080002f2:    481f        .H      LDR      r0,[pc,#124] ; [0x8000370] = 0x20000027
        0x080002f4:    7800        .x      LDRB     r0,[r0,#0]
        0x080002f6:    2800        .(      CMP      r0,#0
        0x080002f8:    d0fb        ..      BEQ      0x80002f2 ; Handle_I2C_MasterDMA_IT + 34
;;;221      	{}
;;;222    //		return 1;
;;;223    	}
;;;224      LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_4, count);
        0x080002fa:    462a        *F      MOV      r2,r5
        0x080002fc:    2104        .!      MOVS     r1,#4
        0x080002fe:    481d        .H      LDR      r0,[pc,#116] ; [0x8000374] = 0x40020000
        0x08000300:    f000f906    ....    BL       LL_DMA_SetDataLength ; 0x8000510
;;;225      LL_DMA_ConfigAddresses(DMA1, LL_DMA_CHANNEL_4, (uint32_t)data, (uint32_t)LL_I2C_DMA_GetRegAddr(I2Cx), LL_DMA_DIRECTION_MEMORY_TO_PERIPH ); //  LL_DMA_GetDataTransferDirection(DMA1, LL_DMA_CHANNEL_4));
        0x08000304:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;467      return (uint32_t) & (I2Cx->DR);
        0x08000306:    f1040010    ....    ADD      r0,r4,#0x10
        0x0800030a:    4681        .F      MOV      r9,r0
        0x0800030c:    2010        .       MOVS     r0,#0x10
        0x0800030e:    464b        KF      MOV      r3,r9
        0x08000310:    463a        :F      MOV      r2,r7
        0x08000312:    2104        .!      MOVS     r1,#4
        0x08000314:    9000        ..      STR      r0,[sp,#0]
        0x08000316:    4817        .H      LDR      r0,[pc,#92] ; [0x8000374] = 0x40020000
        0x08000318:    f000f8b6    ....    BL       LL_DMA_ConfigAddresses ; 0x8000488
;;; .\..\Src\i2c_interface.c
;;;227      LL_DMA_EnableIT_TC(DMA1, LL_DMA_CHANNEL_4);
        0x0800031c:    2104        .!      MOVS     r1,#4
        0x0800031e:    4815        .H      LDR      r0,[pc,#84] ; [0x8000374] = 0x40020000
        0x08000320:    f000f8da    ....    BL       LL_DMA_EnableIT_TC ; 0x80004d8
;;;228      LL_DMA_EnableIT_TE(DMA1, LL_DMA_CHANNEL_4);
        0x08000324:    2104        .!      MOVS     r1,#4
        0x08000326:    4813        .H      LDR      r0,[pc,#76] ; [0x8000374] = 0x40020000
        0x08000328:    f000f8e4    ....    BL       LL_DMA_EnableIT_TE ; 0x80004f4
;;;229    
;;;230      /* (1) Enable DMA transfer **************************************************/
;;;231      LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_4);
        0x0800032c:    2104        .!      MOVS     r1,#4
        0x0800032e:    4811        .H      LDR      r0,[pc,#68] ; [0x8000374] = 0x40020000
        0x08000330:    f000f8c4    ....    BL       LL_DMA_EnableChannel ; 0x80004bc
;;;232      /* (2) Prepare acknowledge for Master data reception ************************/
;;;233      LL_I2C_AcknowledgeNextData(I2Cx, LL_I2C_ACK);
        0x08000334:    f44f6180    O..a    MOV      r1,#0x400
        0x08000338:    4620         F      MOV      r0,r4
        0x0800033a:    f000f99d    ....    BL       LL_I2C_AcknowledgeNextData ; 0x8000678
;;;234    
;;;235      /* (3) Initiate a Start condition to the Slave device ***********************/
;;;236      /* Master Generate Start condition */
;;;237      LL_I2C_GenerateStartCondition(I2Cx);
        0x0800033e:    4620         F      MOV      r0,r4
        0x08000340:    f000f9fe    ....    BL       LL_I2C_GenerateStartCondition ; 0x8000740
;;;238    
;;;239      /* (4) Loop until end of transfer completed (DMA TC raised) *****************/
;;;240    
;;;241    #if (USE_TIMEOUT == 1)
;;;242      int Timeout = timeout;
        0x08000344:    4646        FF      MOV      r6,r8
;;;243    #endif /* USE_TIMEOUT */
;;;244    
;;;245      /* Loop until DMA transfer complete event */
;;;246      while(!ubTransferComplete)
        0x08000346:    e00d        ..      B        0x8000364 ; Handle_I2C_MasterDMA_IT + 148
;;;247      {
;;;248    #if (USE_TIMEOUT == 1)
;;;249        /* Check Systick counter flag to decrement the time-out value */
;;;250        if (LL_SYSTICK_IsActiveCounterFlag()) 
        0x08000348:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;249      return ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == (SysTick_CTRL_COUNTFLAG_Msk));
        0x0800034a:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x0800034e:    6900        .i      LDR      r0,[r0,#0x10]
        0x08000350:    f3c04000    ...@    UBFX     r0,r0,#16,#1
        0x08000354:    b130        0.      CBZ      r0,0x8000364 ; Handle_I2C_MasterDMA_IT + 148
;;; .\..\Src\i2c_interface.c
;;;252          if(Timeout-- == 0)
        0x08000356:    1e30        0.      SUBS     r0,r6,#0
        0x08000358:    f1a60601    ....    SUB      r6,r6,#1
        0x0800035c:    d102        ..      BNE      0x8000364 ; Handle_I2C_MasterDMA_IT + 148
;;;253          {
;;;254            /* Time-out occurred. Set LED to blinking mode */
;;;255            return -1;
        0x0800035e:    1e40        @.      SUBS     r0,r0,#1
;;;256          }
;;;257        }
;;;258    #endif /* USE_TIMEOUT */
;;;259      }
;;;260    
;;;261    	return 0;
;;;262      /* (5) End of tranfer, Data consistency are checking into Slave process *****/
;;;263    }
        0x08000360:    e8bd8ff8    ....    POP      {r3-r11,pc}
        0x08000364:    4802        .H      LDR      r0,[pc,#8] ; [0x8000370] = 0x20000027
        0x08000366:    7800        .x      LDRB     r0,[r0,#0]
        0x08000368:    2800        .(      CMP      r0,#0
        0x0800036a:    d0ed        ..      BEQ      0x8000348 ; Handle_I2C_MasterDMA_IT + 120
        0x0800036c:    2000        .       MOVS     r0,#0
        0x0800036e:    e7f7        ..      B        0x8000360 ; Handle_I2C_MasterDMA_IT + 144
    $d
        0x08000370:    20000027    '..     DCD    536870951
        0x08000374:    40020000    ...@    DCD    1073872896
    $t
    i.Handle_I2C_MasterDMA_IT_async
    Handle_I2C_MasterDMA_IT_async
;;;264    
;;;265    int Handle_I2C_MasterDMA_IT_async(uint8_t address, uint8_t *data, uint16_t count)
;;;266    {
        0x08000378:    b5f8        ..      PUSH     {r3-r7,lr}
        0x0800037a:    4607        .F      MOV      r7,r0
        0x0800037c:    460c        .F      MOV      r4,r1
        0x0800037e:    4615        .F      MOV      r5,r2
;;;267    	if(ubTransferComplete == 1){
        0x08000380:    4818        .H      LDR      r0,[pc,#96] ; [0x80003e4] = 0x20000027
        0x08000382:    7800        .x      LDRB     r0,[r0,#0]
        0x08000384:    2801        .(      CMP      r0,#1
        0x08000386:    d103        ..      BNE      0x8000390 ; Handle_I2C_MasterDMA_IT_async + 24
;;;268    		ubTransferComplete = 0;
        0x08000388:    2000        .       MOVS     r0,#0
        0x0800038a:    4916        .I      LDR      r1,[pc,#88] ; [0x80003e4] = 0x20000027
        0x0800038c:    7008        .p      STRB     r0,[r1,#0]
        0x0800038e:    e001        ..      B        0x8000394 ; Handle_I2C_MasterDMA_IT_async + 28
;;;269    	} else {
;;;270    		return 1;
        0x08000390:    2001        .       MOVS     r0,#1
        0x08000392:    bdf8        ..      POP      {r3-r7,pc}
;;;271    	}
;;;272      LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_4, count);
        0x08000394:    462a        *F      MOV      r2,r5
        0x08000396:    2104        .!      MOVS     r1,#4
        0x08000398:    4813        .H      LDR      r0,[pc,#76] ; [0x80003e8] = 0x40020000
        0x0800039a:    f000f8b9    ....    BL       LL_DMA_SetDataLength ; 0x8000510
;;;273      LL_DMA_ConfigAddresses(DMA1, LL_DMA_CHANNEL_4, (uint32_t)data, (uint32_t)LL_I2C_DMA_GetRegAddr(I2C2), LL_DMA_DIRECTION_MEMORY_TO_PERIPH ); //  LL_DMA_GetDataTransferDirection(DMA1, LL_DMA_CHANNEL_4));
        0x0800039e:    4813        .H      LDR      r0,[pc,#76] ; [0x80003ec] = 0x40005800
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;467      return (uint32_t) & (I2Cx->DR);
        0x080003a0:    f1000110    ....    ADD      r1,r0,#0x10
        0x080003a4:    460e        .F      MOV      r6,r1
        0x080003a6:    2010        .       MOVS     r0,#0x10
        0x080003a8:    4633        3F      MOV      r3,r6
        0x080003aa:    4622        "F      MOV      r2,r4
        0x080003ac:    2104        .!      MOVS     r1,#4
        0x080003ae:    9000        ..      STR      r0,[sp,#0]
        0x080003b0:    480d        .H      LDR      r0,[pc,#52] ; [0x80003e8] = 0x40020000
        0x080003b2:    f000f869    ..i.    BL       LL_DMA_ConfigAddresses ; 0x8000488
;;; .\..\Src\i2c_interface.c
;;;275      LL_DMA_EnableIT_TC(DMA1, LL_DMA_CHANNEL_4);
        0x080003b6:    2104        .!      MOVS     r1,#4
        0x080003b8:    480b        .H      LDR      r0,[pc,#44] ; [0x80003e8] = 0x40020000
        0x080003ba:    f000f88d    ....    BL       LL_DMA_EnableIT_TC ; 0x80004d8
;;;276      LL_DMA_EnableIT_TE(DMA1, LL_DMA_CHANNEL_4);
        0x080003be:    2104        .!      MOVS     r1,#4
        0x080003c0:    4809        .H      LDR      r0,[pc,#36] ; [0x80003e8] = 0x40020000
        0x080003c2:    f000f897    ....    BL       LL_DMA_EnableIT_TE ; 0x80004f4
;;;277    
;;;278      /* (1) Enable DMA transfer **************************************************/
;;;279      LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_4);
        0x080003c6:    2104        .!      MOVS     r1,#4
        0x080003c8:    4807        .H      LDR      r0,[pc,#28] ; [0x80003e8] = 0x40020000
        0x080003ca:    f000f877    ..w.    BL       LL_DMA_EnableChannel ; 0x80004bc
;;;280      /* (2) Prepare acknowledge for Master data reception ************************/
;;;281      LL_I2C_AcknowledgeNextData(I2C2, LL_I2C_ACK);
        0x080003ce:    f44f6180    O..a    MOV      r1,#0x400
        0x080003d2:    4806        .H      LDR      r0,[pc,#24] ; [0x80003ec] = 0x40005800
        0x080003d4:    f000f950    ..P.    BL       LL_I2C_AcknowledgeNextData ; 0x8000678
;;;282    
;;;283      /* (3) Initiate a Start condition to the Slave device ***********************/
;;;284      /* Master Generate Start condition */
;;;285      LL_I2C_GenerateStartCondition(I2C2);
        0x080003d8:    4804        .H      LDR      r0,[pc,#16] ; [0x80003ec] = 0x40005800
        0x080003da:    f000f9b1    ....    BL       LL_I2C_GenerateStartCondition ; 0x8000740
;;;286    	return 0;
        0x080003de:    2000        .       MOVS     r0,#0
        0x080003e0:    e7d7        ..      B        0x8000392 ; Handle_I2C_MasterDMA_IT_async + 26
    $d
        0x080003e2:    0000        ..      DCW    0
        0x080003e4:    20000027    '..     DCD    536870951
        0x080003e8:    40020000    ...@    DCD    1073872896
        0x080003ec:    40005800    .X.@    DCD    1073764352
    $t
    i.I2C2_ER_IRQHandler
    I2C2_ER_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;304      while(1){
        0x080003f0:    bf00        ..      NOP      
        0x080003f2:    e7fe        ..      B        0x80003f2 ; I2C2_ER_IRQHandler + 2
    i.I2C2_EV_IRQHandler
    I2C2_EV_IRQHandler
;;; .\../Src/stm32f1xx_it.c (273)
        0x080003f4:    b508        ..      PUSH     {r3,lr}
;;;274      /* USER CODE BEGIN I2C2_EV_IRQn 0 */
;;;275      /* Check SB flag value in ISR register */
;;;276      if(LL_I2C_IsActiveFlag_SB(I2C2))
        0x080003f6:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1186     return (READ_BIT(I2Cx->SR1, I2C_SR1_SB) == (I2C_SR1_SB));
        0x080003f8:    4814        .H      LDR      r0,[pc,#80] ; [0x800044c] = 0x40005800
        0x080003fa:    6940        @i      LDR      r0,[r0,#0x14]
        0x080003fc:    f0000001    ....    AND      r0,r0,#1
        0x08000400:    b148        H.      CBZ      r0,0x8000416 ; I2C2_EV_IRQHandler + 34
;;; .\../Src/stm32f1xx_it.c
;;;279        LL_I2C_TransmitData8(I2C2, SSD1306_I2C_ADDR);
        0x08000402:    2078        x       MOVS     r0,#0x78
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1758     MODIFY_REG(I2Cx->DR, I2C_DR_DR, Data);
        0x08000404:    4911        .I      LDR      r1,[pc,#68] ; [0x800044c] = 0x40005800
        0x08000406:    6909        .i      LDR      r1,[r1,#0x10]
        0x08000408:    f02101ff    !...    BIC      r1,r1,#0xff
        0x0800040c:    4301        .C      ORRS     r1,r1,r0
        0x0800040e:    4a0f        .J      LDR      r2,[pc,#60] ; [0x800044c] = 0x40005800
        0x08000410:    6111        .a      STR      r1,[r2,#0x10]
;;;1759   }
        0x08000412:    bf00        ..      NOP      
        0x08000414:    e018        ..      B        0x8000448 ; I2C2_EV_IRQHandler + 84
;;; .\../Src/stm32f1xx_it.c
;;;282      else if(LL_I2C_IsActiveFlag_ADDR(I2C2))
        0x08000416:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1199     return (READ_BIT(I2Cx->SR1, I2C_SR1_ADDR) == (I2C_SR1_ADDR));
        0x08000418:    480c        .H      LDR      r0,[pc,#48] ; [0x800044c] = 0x40005800
        0x0800041a:    6940        @i      LDR      r0,[r0,#0x14]
        0x0800041c:    f3c00040    ..@.    UBFX     r0,r0,#1,#1
        0x08000420:    b190        ..      CBZ      r0,0x8000448 ; I2C2_EV_IRQHandler + 84
;;; .\../Src/stm32f1xx_it.c
;;;285        LL_I2C_EnableDMAReq_TX(I2C2);
        0x08000422:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;401      SET_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
        0x08000424:    4809        .H      LDR      r0,[pc,#36] ; [0x800044c] = 0x40005800
        0x08000426:    6840        @h      LDR      r0,[r0,#4]
        0x08000428:    f4406000    @..`    ORR      r0,r0,#0x800
        0x0800042c:    4907        .I      LDR      r1,[pc,#28] ; [0x800044c] = 0x40005800
        0x0800042e:    6048        H`      STR      r0,[r1,#4]
;;;402    }
        0x08000430:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;288        LL_I2C_ClearFlag_ADDR(I2C2);
        0x08000432:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1415     tmpreg = I2Cx->SR1;
        0x08000434:    4608        .F      MOV      r0,r1
        0x08000436:    6940        @i      LDR      r0,[r0,#0x14]
        0x08000438:    9000        ..      STR      r0,[sp,#0]
;;;1416     (void) tmpreg;
        0x0800043a:    bf00        ..      NOP      
;;;1417     tmpreg = I2Cx->SR2;
        0x0800043c:    4608        .F      MOV      r0,r1
        0x0800043e:    6980        .i      LDR      r0,[r0,#0x18]
        0x08000440:    9000        ..      STR      r0,[sp,#0]
;;;1418     (void) tmpreg;
        0x08000442:    bf00        ..      NOP      
;;;1419   }
        0x08000444:    bf00        ..      NOP      
        0x08000446:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;296    }
        0x08000448:    bd08        ..      POP      {r3,pc}
    $d
        0x0800044a:    0000        ..      DCW    0
        0x0800044c:    40005800    .X.@    DCD    1073764352
    $t
    i.LL_APB1_GRP1_EnableClock
    LL_APB1_GRP1_EnableClock
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_bus.h
;;;464    {
        0x08000450:    b508        ..      PUSH     {r3,lr}
;;;465      __IO uint32_t tmpreg;
;;;466      SET_BIT(RCC->APB1ENR, Periphs);
        0x08000452:    4905        .I      LDR      r1,[pc,#20] ; [0x8000468] = 0x40021000
        0x08000454:    69c9        .i      LDR      r1,[r1,#0x1c]
        0x08000456:    4301        .C      ORRS     r1,r1,r0
        0x08000458:    4a03        .J      LDR      r2,[pc,#12] ; [0x8000468] = 0x40021000
        0x0800045a:    61d1        .a      STR      r1,[r2,#0x1c]
;;;467      /* Delay after an RCC peripheral clock enabling */
;;;468      tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
        0x0800045c:    4611        .F      MOV      r1,r2
        0x0800045e:    69c9        .i      LDR      r1,[r1,#0x1c]
        0x08000460:    4001        .@      ANDS     r1,r1,r0
        0x08000462:    9100        ..      STR      r1,[sp,#0]
;;;469      (void)tmpreg;
        0x08000464:    bf00        ..      NOP      
;;;470    }
        0x08000466:    bd08        ..      POP      {r3,pc}
    $d
        0x08000468:    40021000    ...@    DCD    1073876992
    $t
    i.LL_APB2_GRP1_EnableClock
    LL_APB2_GRP1_EnableClock
;;;471    
;;;472    /**
;;;473      * @brief  Check if APB1 peripheral clock is enabled or not
;;;474      * @rmtoll APB1ENR      BKPEN         LL_APB1_GRP1_IsEnabledClock\n
;;;475      *         APB1ENR      CAN1EN        LL_APB1_GRP1_IsEnabledClock\n
;;;476      *         APB1ENR      CAN2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;477      *         APB1ENR      CECEN         LL_APB1_GRP1_IsEnabledClock\n
;;;478      *         APB1ENR      DACEN         LL_APB1_GRP1_IsEnabledClock\n
;;;479      *         APB1ENR      I2C1EN        LL_APB1_GRP1_IsEnabledClock\n
;;;480      *         APB1ENR      I2C2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;481      *         APB1ENR      PWREN         LL_APB1_GRP1_IsEnabledClock\n
;;;482      *         APB1ENR      SPI2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;483      *         APB1ENR      SPI3EN        LL_APB1_GRP1_IsEnabledClock\n
;;;484      *         APB1ENR      TIM12EN       LL_APB1_GRP1_IsEnabledClock\n
;;;485      *         APB1ENR      TIM13EN       LL_APB1_GRP1_IsEnabledClock\n
;;;486      *         APB1ENR      TIM14EN       LL_APB1_GRP1_IsEnabledClock\n
;;;487      *         APB1ENR      TIM2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;488      *         APB1ENR      TIM3EN        LL_APB1_GRP1_IsEnabledClock\n
;;;489      *         APB1ENR      TIM4EN        LL_APB1_GRP1_IsEnabledClock\n
;;;490      *         APB1ENR      TIM5EN        LL_APB1_GRP1_IsEnabledClock\n
;;;491      *         APB1ENR      TIM6EN        LL_APB1_GRP1_IsEnabledClock\n
;;;492      *         APB1ENR      TIM7EN        LL_APB1_GRP1_IsEnabledClock\n
;;;493      *         APB1ENR      UART4EN       LL_APB1_GRP1_IsEnabledClock\n
;;;494      *         APB1ENR      UART5EN       LL_APB1_GRP1_IsEnabledClock\n
;;;495      *         APB1ENR      USART2EN      LL_APB1_GRP1_IsEnabledClock\n
;;;496      *         APB1ENR      USART3EN      LL_APB1_GRP1_IsEnabledClock\n
;;;497      *         APB1ENR      USBEN         LL_APB1_GRP1_IsEnabledClock\n
;;;498      *         APB1ENR      WWDGEN        LL_APB1_GRP1_IsEnabledClock
;;;499      * @param  Periphs This parameter can be a combination of the following values:
;;;500      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;501      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;502      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;503      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;504      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;505      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;506      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;507      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;508      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;509      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;510      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;511      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;512      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;513      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;514      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;515      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;516      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;517      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;518      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;519      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;520      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;521      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;522      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;523      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;524      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;525      *
;;;526      *         (*) value not defined in all devices.
;;;527      * @retval State of Periphs (1 or 0).
;;;528    */
;;;529    __STATIC_INLINE uint32_t LL_APB1_GRP1_IsEnabledClock(uint32_t Periphs)
;;;530    {
;;;531      return (READ_BIT(RCC->APB1ENR, Periphs) == Periphs);
;;;532    }
;;;533    
;;;534    /**
;;;535      * @brief  Disable APB1 peripherals clock.
;;;536      * @rmtoll APB1ENR      BKPEN         LL_APB1_GRP1_DisableClock\n
;;;537      *         APB1ENR      CAN1EN        LL_APB1_GRP1_DisableClock\n
;;;538      *         APB1ENR      CAN2EN        LL_APB1_GRP1_DisableClock\n
;;;539      *         APB1ENR      CECEN         LL_APB1_GRP1_DisableClock\n
;;;540      *         APB1ENR      DACEN         LL_APB1_GRP1_DisableClock\n
;;;541      *         APB1ENR      I2C1EN        LL_APB1_GRP1_DisableClock\n
;;;542      *         APB1ENR      I2C2EN        LL_APB1_GRP1_DisableClock\n
;;;543      *         APB1ENR      PWREN         LL_APB1_GRP1_DisableClock\n
;;;544      *         APB1ENR      SPI2EN        LL_APB1_GRP1_DisableClock\n
;;;545      *         APB1ENR      SPI3EN        LL_APB1_GRP1_DisableClock\n
;;;546      *         APB1ENR      TIM12EN       LL_APB1_GRP1_DisableClock\n
;;;547      *         APB1ENR      TIM13EN       LL_APB1_GRP1_DisableClock\n
;;;548      *         APB1ENR      TIM14EN       LL_APB1_GRP1_DisableClock\n
;;;549      *         APB1ENR      TIM2EN        LL_APB1_GRP1_DisableClock\n
;;;550      *         APB1ENR      TIM3EN        LL_APB1_GRP1_DisableClock\n
;;;551      *         APB1ENR      TIM4EN        LL_APB1_GRP1_DisableClock\n
;;;552      *         APB1ENR      TIM5EN        LL_APB1_GRP1_DisableClock\n
;;;553      *         APB1ENR      TIM6EN        LL_APB1_GRP1_DisableClock\n
;;;554      *         APB1ENR      TIM7EN        LL_APB1_GRP1_DisableClock\n
;;;555      *         APB1ENR      UART4EN       LL_APB1_GRP1_DisableClock\n
;;;556      *         APB1ENR      UART5EN       LL_APB1_GRP1_DisableClock\n
;;;557      *         APB1ENR      USART2EN      LL_APB1_GRP1_DisableClock\n
;;;558      *         APB1ENR      USART3EN      LL_APB1_GRP1_DisableClock\n
;;;559      *         APB1ENR      USBEN         LL_APB1_GRP1_DisableClock\n
;;;560      *         APB1ENR      WWDGEN        LL_APB1_GRP1_DisableClock
;;;561      * @param  Periphs This parameter can be a combination of the following values:
;;;562      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;563      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;564      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;565      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;566      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;567      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;568      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;569      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;570      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;571      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;572      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;573      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;574      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;575      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;576      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;577      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;578      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;579      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;580      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;581      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;582      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;583      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;584      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;585      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;586      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;587      *
;;;588      *         (*) value not defined in all devices.
;;;589      * @retval None
;;;590    */
;;;591    __STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
;;;592    {
;;;593      CLEAR_BIT(RCC->APB1ENR, Periphs);
;;;594    }
;;;595    
;;;596    /**
;;;597      * @brief  Force APB1 peripherals reset.
;;;598      * @rmtoll APB1RSTR     BKPRST        LL_APB1_GRP1_ForceReset\n
;;;599      *         APB1RSTR     CAN1RST       LL_APB1_GRP1_ForceReset\n
;;;600      *         APB1RSTR     CAN2RST       LL_APB1_GRP1_ForceReset\n
;;;601      *         APB1RSTR     CECRST        LL_APB1_GRP1_ForceReset\n
;;;602      *         APB1RSTR     DACRST        LL_APB1_GRP1_ForceReset\n
;;;603      *         APB1RSTR     I2C1RST       LL_APB1_GRP1_ForceReset\n
;;;604      *         APB1RSTR     I2C2RST       LL_APB1_GRP1_ForceReset\n
;;;605      *         APB1RSTR     PWRRST        LL_APB1_GRP1_ForceReset\n
;;;606      *         APB1RSTR     SPI2RST       LL_APB1_GRP1_ForceReset\n
;;;607      *         APB1RSTR     SPI3RST       LL_APB1_GRP1_ForceReset\n
;;;608      *         APB1RSTR     TIM12RST      LL_APB1_GRP1_ForceReset\n
;;;609      *         APB1RSTR     TIM13RST      LL_APB1_GRP1_ForceReset\n
;;;610      *         APB1RSTR     TIM14RST      LL_APB1_GRP1_ForceReset\n
;;;611      *         APB1RSTR     TIM2RST       LL_APB1_GRP1_ForceReset\n
;;;612      *         APB1RSTR     TIM3RST       LL_APB1_GRP1_ForceReset\n
;;;613      *         APB1RSTR     TIM4RST       LL_APB1_GRP1_ForceReset\n
;;;614      *         APB1RSTR     TIM5RST       LL_APB1_GRP1_ForceReset\n
;;;615      *         APB1RSTR     TIM6RST       LL_APB1_GRP1_ForceReset\n
;;;616      *         APB1RSTR     TIM7RST       LL_APB1_GRP1_ForceReset\n
;;;617      *         APB1RSTR     UART4RST      LL_APB1_GRP1_ForceReset\n
;;;618      *         APB1RSTR     UART5RST      LL_APB1_GRP1_ForceReset\n
;;;619      *         APB1RSTR     USART2RST     LL_APB1_GRP1_ForceReset\n
;;;620      *         APB1RSTR     USART3RST     LL_APB1_GRP1_ForceReset\n
;;;621      *         APB1RSTR     USBRST        LL_APB1_GRP1_ForceReset\n
;;;622      *         APB1RSTR     WWDGRST       LL_APB1_GRP1_ForceReset
;;;623      * @param  Periphs This parameter can be a combination of the following values:
;;;624      *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
;;;625      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;626      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;627      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;628      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;629      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;630      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;631      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;632      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;633      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;634      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;635      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;636      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;637      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;638      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;639      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;640      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;641      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;642      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;643      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;644      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;645      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;646      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;647      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;648      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;649      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;650      *
;;;651      *         (*) value not defined in all devices.
;;;652      * @retval None
;;;653    */
;;;654    __STATIC_INLINE void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
;;;655    {
;;;656      SET_BIT(RCC->APB1RSTR, Periphs);
;;;657    }
;;;658    
;;;659    /**
;;;660      * @brief  Release APB1 peripherals reset.
;;;661      * @rmtoll APB1RSTR     BKPRST        LL_APB1_GRP1_ReleaseReset\n
;;;662      *         APB1RSTR     CAN1RST       LL_APB1_GRP1_ReleaseReset\n
;;;663      *         APB1RSTR     CAN2RST       LL_APB1_GRP1_ReleaseReset\n
;;;664      *         APB1RSTR     CECRST        LL_APB1_GRP1_ReleaseReset\n
;;;665      *         APB1RSTR     DACRST        LL_APB1_GRP1_ReleaseReset\n
;;;666      *         APB1RSTR     I2C1RST       LL_APB1_GRP1_ReleaseReset\n
;;;667      *         APB1RSTR     I2C2RST       LL_APB1_GRP1_ReleaseReset\n
;;;668      *         APB1RSTR     PWRRST        LL_APB1_GRP1_ReleaseReset\n
;;;669      *         APB1RSTR     SPI2RST       LL_APB1_GRP1_ReleaseReset\n
;;;670      *         APB1RSTR     SPI3RST       LL_APB1_GRP1_ReleaseReset\n
;;;671      *         APB1RSTR     TIM12RST      LL_APB1_GRP1_ReleaseReset\n
;;;672      *         APB1RSTR     TIM13RST      LL_APB1_GRP1_ReleaseReset\n
;;;673      *         APB1RSTR     TIM14RST      LL_APB1_GRP1_ReleaseReset\n
;;;674      *         APB1RSTR     TIM2RST       LL_APB1_GRP1_ReleaseReset\n
;;;675      *         APB1RSTR     TIM3RST       LL_APB1_GRP1_ReleaseReset\n
;;;676      *         APB1RSTR     TIM4RST       LL_APB1_GRP1_ReleaseReset\n
;;;677      *         APB1RSTR     TIM5RST       LL_APB1_GRP1_ReleaseReset\n
;;;678      *         APB1RSTR     TIM6RST       LL_APB1_GRP1_ReleaseReset\n
;;;679      *         APB1RSTR     TIM7RST       LL_APB1_GRP1_ReleaseReset\n
;;;680      *         APB1RSTR     UART4RST      LL_APB1_GRP1_ReleaseReset\n
;;;681      *         APB1RSTR     UART5RST      LL_APB1_GRP1_ReleaseReset\n
;;;682      *         APB1RSTR     USART2RST     LL_APB1_GRP1_ReleaseReset\n
;;;683      *         APB1RSTR     USART3RST     LL_APB1_GRP1_ReleaseReset\n
;;;684      *         APB1RSTR     USBRST        LL_APB1_GRP1_ReleaseReset\n
;;;685      *         APB1RSTR     WWDGRST       LL_APB1_GRP1_ReleaseReset
;;;686      * @param  Periphs This parameter can be a combination of the following values:
;;;687      *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
;;;688      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;689      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;690      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;691      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;692      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;693      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;694      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;695      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;696      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;697      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;698      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;699      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;700      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;701      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;702      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;703      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;704      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;705      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;706      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;707      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;708      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;709      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;710      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;711      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;712      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;713      *
;;;714      *         (*) value not defined in all devices.
;;;715      * @retval None
;;;716    */
;;;717    __STATIC_INLINE void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
;;;718    {
;;;719      CLEAR_BIT(RCC->APB1RSTR, Periphs);
;;;720    }
;;;721    
;;;722    /**
;;;723      * @}
;;;724      */
;;;725    
;;;726    /** @defgroup BUS_LL_EF_APB2 APB2
;;;727      * @{
;;;728      */
;;;729    
;;;730    /**
;;;731      * @brief  Enable APB2 peripherals clock.
;;;732      * @rmtoll APB2ENR      ADC1EN        LL_APB2_GRP1_EnableClock\n
;;;733      *         APB2ENR      ADC2EN        LL_APB2_GRP1_EnableClock\n
;;;734      *         APB2ENR      ADC3EN        LL_APB2_GRP1_EnableClock\n
;;;735      *         APB2ENR      AFIOEN        LL_APB2_GRP1_EnableClock\n
;;;736      *         APB2ENR      IOPAEN        LL_APB2_GRP1_EnableClock\n
;;;737      *         APB2ENR      IOPBEN        LL_APB2_GRP1_EnableClock\n
;;;738      *         APB2ENR      IOPCEN        LL_APB2_GRP1_EnableClock\n
;;;739      *         APB2ENR      IOPDEN        LL_APB2_GRP1_EnableClock\n
;;;740      *         APB2ENR      IOPEEN        LL_APB2_GRP1_EnableClock\n
;;;741      *         APB2ENR      IOPFEN        LL_APB2_GRP1_EnableClock\n
;;;742      *         APB2ENR      IOPGEN        LL_APB2_GRP1_EnableClock\n
;;;743      *         APB2ENR      SPI1EN        LL_APB2_GRP1_EnableClock\n
;;;744      *         APB2ENR      TIM10EN       LL_APB2_GRP1_EnableClock\n
;;;745      *         APB2ENR      TIM11EN       LL_APB2_GRP1_EnableClock\n
;;;746      *         APB2ENR      TIM15EN       LL_APB2_GRP1_EnableClock\n
;;;747      *         APB2ENR      TIM16EN       LL_APB2_GRP1_EnableClock\n
;;;748      *         APB2ENR      TIM17EN       LL_APB2_GRP1_EnableClock\n
;;;749      *         APB2ENR      TIM1EN        LL_APB2_GRP1_EnableClock\n
;;;750      *         APB2ENR      TIM8EN        LL_APB2_GRP1_EnableClock\n
;;;751      *         APB2ENR      TIM9EN        LL_APB2_GRP1_EnableClock\n
;;;752      *         APB2ENR      USART1EN      LL_APB2_GRP1_EnableClock
;;;753      * @param  Periphs This parameter can be a combination of the following values:
;;;754      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC1
;;;755      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC2 (*)
;;;756      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC3 (*)
;;;757      *         @arg @ref LL_APB2_GRP1_PERIPH_AFIO
;;;758      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOA
;;;759      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOB
;;;760      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOC
;;;761      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOD
;;;762      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOE (*)
;;;763      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOF (*)
;;;764      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOG (*)
;;;765      *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
;;;766      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM10 (*)
;;;767      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM11 (*)
;;;768      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15 (*)
;;;769      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16 (*)
;;;770      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
;;;771      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
;;;772      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
;;;773      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM9 (*)
;;;774      *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
;;;775      *
;;;776      *         (*) value not defined in all devices.
;;;777      * @retval None
;;;778    */
;;;779    __STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
;;;780    {
        0x0800046c:    b508        ..      PUSH     {r3,lr}
;;;781      __IO uint32_t tmpreg;
;;;782      SET_BIT(RCC->APB2ENR, Periphs);
        0x0800046e:    4905        .I      LDR      r1,[pc,#20] ; [0x8000484] = 0x40021000
        0x08000470:    6989        .i      LDR      r1,[r1,#0x18]
        0x08000472:    4301        .C      ORRS     r1,r1,r0
        0x08000474:    4a03        .J      LDR      r2,[pc,#12] ; [0x8000484] = 0x40021000
        0x08000476:    6191        .a      STR      r1,[r2,#0x18]
;;;783      /* Delay after an RCC peripheral clock enabling */
;;;784      tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
        0x08000478:    4611        .F      MOV      r1,r2
        0x0800047a:    6989        .i      LDR      r1,[r1,#0x18]
        0x0800047c:    4001        .@      ANDS     r1,r1,r0
        0x0800047e:    9100        ..      STR      r1,[sp,#0]
;;;785      (void)tmpreg;
        0x08000480:    bf00        ..      NOP      
;;;786    }
        0x08000482:    bd08        ..      POP      {r3,pc}
    $d
        0x08000484:    40021000    ...@    DCD    1073876992
    $t
    i.LL_DMA_ConfigAddresses
    LL_DMA_ConfigAddresses
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;949    {
        0x08000488:    b570        p.      PUSH     {r4-r6,lr}
        0x0800048a:    9c04        ..      LDR      r4,[sp,#0x10]
;;;950      /* Direction Memory to Periph */
;;;951      if (Direction == LL_DMA_DIRECTION_MEMORY_TO_PERIPH)
        0x0800048c:    2c10        .,      CMP      r4,#0x10
        0x0800048e:    d109        ..      BNE      0x80004a4 ; LL_DMA_ConfigAddresses + 28
;;;952      {
;;;953        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, SrcAddress);
        0x08000490:    1e4d        M.      SUBS     r5,r1,#1
        0x08000492:    4e09        .N      LDR      r6,[pc,#36] ; [0x80004b8] = 0x8003da4
        0x08000494:    5d75        u]      LDRB     r5,[r6,r5]
        0x08000496:    4405        .D      ADD      r5,r5,r0
        0x08000498:    60ea        .`      STR      r2,[r5,#0xc]
;;;954        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, DstAddress);
        0x0800049a:    1e4d        M.      SUBS     r5,r1,#1
        0x0800049c:    5d75        u]      LDRB     r5,[r6,r5]
        0x0800049e:    4405        .D      ADD      r5,r5,r0
        0x080004a0:    60ab        .`      STR      r3,[r5,#8]
        0x080004a2:    e008        ..      B        0x80004b6 ; LL_DMA_ConfigAddresses + 46
;;;955      }
;;;956      /* Direction Periph to Memory and Memory to Memory */
;;;957      else
;;;958      {
;;;959        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, SrcAddress);
        0x080004a4:    1e4d        M.      SUBS     r5,r1,#1
        0x080004a6:    4e04        .N      LDR      r6,[pc,#16] ; [0x80004b8] = 0x8003da4
        0x080004a8:    5d75        u]      LDRB     r5,[r6,r5]
        0x080004aa:    4405        .D      ADD      r5,r5,r0
        0x080004ac:    60aa        .`      STR      r2,[r5,#8]
;;;960        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, DstAddress);
        0x080004ae:    1e4d        M.      SUBS     r5,r1,#1
        0x080004b0:    5d75        u]      LDRB     r5,[r6,r5]
        0x080004b2:    4405        .D      ADD      r5,r5,r0
        0x080004b4:    60eb        .`      STR      r3,[r5,#0xc]
;;;961      }
;;;962    }
        0x080004b6:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x080004b8:    08003da4    .=..    DCD    134233508
    $t
    i.LL_DMA_EnableChannel
    LL_DMA_EnableChannel
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h (471)
        0x080004bc:    b510        ..      PUSH     {r4,lr}
;;;472      SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
        0x080004be:    1e4a        J.      SUBS     r2,r1,#1
        0x080004c0:    4b04        .K      LDR      r3,[pc,#16] ; [0x80004d4] = 0x8003da4
        0x080004c2:    5c9a        .\      LDRB     r2,[r3,r2]
        0x080004c4:    5882        .X      LDR      r2,[r0,r2]
        0x080004c6:    f0420301    B...    ORR      r3,r2,#1
        0x080004ca:    1e4a        J.      SUBS     r2,r1,#1
        0x080004cc:    4c01        .L      LDR      r4,[pc,#4] ; [0x80004d4] = 0x8003da4
        0x080004ce:    5ca2        .\      LDRB     r2,[r4,r2]
        0x080004d0:    5083        .P      STR      r3,[r0,r2]
;;;473    }
        0x080004d2:    bd10        ..      POP      {r4,pc}
    $d
        0x080004d4:    08003da4    .=..    DCD    134233508
    $t
    i.LL_DMA_EnableIT_TC
    LL_DMA_EnableIT_TC
;;;474    
;;;475    /**
;;;476      * @brief  Disable DMA channel.
;;;477      * @rmtoll CCR          EN            LL_DMA_DisableChannel
;;;478      * @param  DMAx DMAx Instance
;;;479      * @param  Channel This parameter can be one of the following values:
;;;480      *         @arg @ref LL_DMA_CHANNEL_1
;;;481      *         @arg @ref LL_DMA_CHANNEL_2
;;;482      *         @arg @ref LL_DMA_CHANNEL_3
;;;483      *         @arg @ref LL_DMA_CHANNEL_4
;;;484      *         @arg @ref LL_DMA_CHANNEL_5
;;;485      *         @arg @ref LL_DMA_CHANNEL_6
;;;486      *         @arg @ref LL_DMA_CHANNEL_7
;;;487      * @retval None
;;;488      */
;;;489    __STATIC_INLINE void LL_DMA_DisableChannel(DMA_TypeDef *DMAx, uint32_t Channel)
;;;490    {
;;;491      CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
;;;492    }
;;;493    
;;;494    /**
;;;495      * @brief  Check if DMA channel is enabled or disabled.
;;;496      * @rmtoll CCR          EN            LL_DMA_IsEnabledChannel
;;;497      * @param  DMAx DMAx Instance
;;;498      * @param  Channel This parameter can be one of the following values:
;;;499      *         @arg @ref LL_DMA_CHANNEL_1
;;;500      *         @arg @ref LL_DMA_CHANNEL_2
;;;501      *         @arg @ref LL_DMA_CHANNEL_3
;;;502      *         @arg @ref LL_DMA_CHANNEL_4
;;;503      *         @arg @ref LL_DMA_CHANNEL_5
;;;504      *         @arg @ref LL_DMA_CHANNEL_6
;;;505      *         @arg @ref LL_DMA_CHANNEL_7
;;;506      * @retval State of bit (1 or 0).
;;;507      */
;;;508    __STATIC_INLINE uint32_t LL_DMA_IsEnabledChannel(DMA_TypeDef *DMAx, uint32_t Channel)
;;;509    {
;;;510      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;511                       DMA_CCR_EN) == (DMA_CCR_EN));
;;;512    }
;;;513    
;;;514    /**
;;;515      * @brief  Configure all parameters link to DMA transfer.
;;;516      * @rmtoll CCR          DIR           LL_DMA_ConfigTransfer\n
;;;517      *         CCR          MEM2MEM       LL_DMA_ConfigTransfer\n
;;;518      *         CCR          CIRC          LL_DMA_ConfigTransfer\n
;;;519      *         CCR          PINC          LL_DMA_ConfigTransfer\n
;;;520      *         CCR          MINC          LL_DMA_ConfigTransfer\n
;;;521      *         CCR          PSIZE         LL_DMA_ConfigTransfer\n
;;;522      *         CCR          MSIZE         LL_DMA_ConfigTransfer\n
;;;523      *         CCR          PL            LL_DMA_ConfigTransfer
;;;524      * @param  DMAx DMAx Instance
;;;525      * @param  Channel This parameter can be one of the following values:
;;;526      *         @arg @ref LL_DMA_CHANNEL_1
;;;527      *         @arg @ref LL_DMA_CHANNEL_2
;;;528      *         @arg @ref LL_DMA_CHANNEL_3
;;;529      *         @arg @ref LL_DMA_CHANNEL_4
;;;530      *         @arg @ref LL_DMA_CHANNEL_5
;;;531      *         @arg @ref LL_DMA_CHANNEL_6
;;;532      *         @arg @ref LL_DMA_CHANNEL_7
;;;533      * @param  Configuration This parameter must be a combination of all the following values:
;;;534      *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY or @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH or @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
;;;535      *         @arg @ref LL_DMA_MODE_NORMAL or @ref LL_DMA_MODE_CIRCULAR
;;;536      *         @arg @ref LL_DMA_PERIPH_INCREMENT or @ref LL_DMA_PERIPH_NOINCREMENT
;;;537      *         @arg @ref LL_DMA_MEMORY_INCREMENT or @ref LL_DMA_MEMORY_NOINCREMENT
;;;538      *         @arg @ref LL_DMA_PDATAALIGN_BYTE or @ref LL_DMA_PDATAALIGN_HALFWORD or @ref LL_DMA_PDATAALIGN_WORD
;;;539      *         @arg @ref LL_DMA_MDATAALIGN_BYTE or @ref LL_DMA_MDATAALIGN_HALFWORD or @ref LL_DMA_MDATAALIGN_WORD
;;;540      *         @arg @ref LL_DMA_PRIORITY_LOW or @ref LL_DMA_PRIORITY_MEDIUM or @ref LL_DMA_PRIORITY_HIGH or @ref LL_DMA_PRIORITY_VERYHIGH
;;;541      * @retval None
;;;542      */
;;;543    __STATIC_INLINE void LL_DMA_ConfigTransfer(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Configuration)
;;;544    {
;;;545      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;546                 DMA_CCR_DIR | DMA_CCR_MEM2MEM | DMA_CCR_CIRC | DMA_CCR_PINC | DMA_CCR_MINC | DMA_CCR_PSIZE | DMA_CCR_MSIZE | DMA_CCR_PL,
;;;547                 Configuration);
;;;548    }
;;;549    
;;;550    /**
;;;551      * @brief  Set Data transfer direction (read from peripheral or from memory).
;;;552      * @rmtoll CCR          DIR           LL_DMA_SetDataTransferDirection\n
;;;553      *         CCR          MEM2MEM       LL_DMA_SetDataTransferDirection
;;;554      * @param  DMAx DMAx Instance
;;;555      * @param  Channel This parameter can be one of the following values:
;;;556      *         @arg @ref LL_DMA_CHANNEL_1
;;;557      *         @arg @ref LL_DMA_CHANNEL_2
;;;558      *         @arg @ref LL_DMA_CHANNEL_3
;;;559      *         @arg @ref LL_DMA_CHANNEL_4
;;;560      *         @arg @ref LL_DMA_CHANNEL_5
;;;561      *         @arg @ref LL_DMA_CHANNEL_6
;;;562      *         @arg @ref LL_DMA_CHANNEL_7
;;;563      * @param  Direction This parameter can be one of the following values:
;;;564      *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
;;;565      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
;;;566      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
;;;567      * @retval None
;;;568      */
;;;569    __STATIC_INLINE void LL_DMA_SetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Direction)
;;;570    {
;;;571      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;572                 DMA_CCR_DIR | DMA_CCR_MEM2MEM, Direction);
;;;573    }
;;;574    
;;;575    /**
;;;576      * @brief  Get Data transfer direction (read from peripheral or from memory).
;;;577      * @rmtoll CCR          DIR           LL_DMA_GetDataTransferDirection\n
;;;578      *         CCR          MEM2MEM       LL_DMA_GetDataTransferDirection
;;;579      * @param  DMAx DMAx Instance
;;;580      * @param  Channel This parameter can be one of the following values:
;;;581      *         @arg @ref LL_DMA_CHANNEL_1
;;;582      *         @arg @ref LL_DMA_CHANNEL_2
;;;583      *         @arg @ref LL_DMA_CHANNEL_3
;;;584      *         @arg @ref LL_DMA_CHANNEL_4
;;;585      *         @arg @ref LL_DMA_CHANNEL_5
;;;586      *         @arg @ref LL_DMA_CHANNEL_6
;;;587      *         @arg @ref LL_DMA_CHANNEL_7
;;;588      * @retval Returned value can be one of the following values:
;;;589      *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
;;;590      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
;;;591      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
;;;592      */
;;;593    __STATIC_INLINE uint32_t LL_DMA_GetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel)
;;;594    {
;;;595      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;596                       DMA_CCR_DIR | DMA_CCR_MEM2MEM));
;;;597    }
;;;598    
;;;599    /**
;;;600      * @brief  Set DMA mode circular or normal.
;;;601      * @note The circular buffer mode cannot be used if the memory-to-memory
;;;602      * data transfer is configured on the selected Channel.
;;;603      * @rmtoll CCR          CIRC          LL_DMA_SetMode
;;;604      * @param  DMAx DMAx Instance
;;;605      * @param  Channel This parameter can be one of the following values:
;;;606      *         @arg @ref LL_DMA_CHANNEL_1
;;;607      *         @arg @ref LL_DMA_CHANNEL_2
;;;608      *         @arg @ref LL_DMA_CHANNEL_3
;;;609      *         @arg @ref LL_DMA_CHANNEL_4
;;;610      *         @arg @ref LL_DMA_CHANNEL_5
;;;611      *         @arg @ref LL_DMA_CHANNEL_6
;;;612      *         @arg @ref LL_DMA_CHANNEL_7
;;;613      * @param  Mode This parameter can be one of the following values:
;;;614      *         @arg @ref LL_DMA_MODE_NORMAL
;;;615      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;616      * @retval None
;;;617      */
;;;618    __STATIC_INLINE void LL_DMA_SetMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Mode)
;;;619    {
;;;620      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
;;;621                 Mode);
;;;622    }
;;;623    
;;;624    /**
;;;625      * @brief  Get DMA mode circular or normal.
;;;626      * @rmtoll CCR          CIRC          LL_DMA_GetMode
;;;627      * @param  DMAx DMAx Instance
;;;628      * @param  Channel This parameter can be one of the following values:
;;;629      *         @arg @ref LL_DMA_CHANNEL_1
;;;630      *         @arg @ref LL_DMA_CHANNEL_2
;;;631      *         @arg @ref LL_DMA_CHANNEL_3
;;;632      *         @arg @ref LL_DMA_CHANNEL_4
;;;633      *         @arg @ref LL_DMA_CHANNEL_5
;;;634      *         @arg @ref LL_DMA_CHANNEL_6
;;;635      *         @arg @ref LL_DMA_CHANNEL_7
;;;636      * @retval Returned value can be one of the following values:
;;;637      *         @arg @ref LL_DMA_MODE_NORMAL
;;;638      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;639      */
;;;640    __STATIC_INLINE uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;641    {
;;;642      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;643                       DMA_CCR_CIRC));
;;;644    }
;;;645    
;;;646    /**
;;;647      * @brief  Set Peripheral increment mode.
;;;648      * @rmtoll CCR          PINC          LL_DMA_SetPeriphIncMode
;;;649      * @param  DMAx DMAx Instance
;;;650      * @param  Channel This parameter can be one of the following values:
;;;651      *         @arg @ref LL_DMA_CHANNEL_1
;;;652      *         @arg @ref LL_DMA_CHANNEL_2
;;;653      *         @arg @ref LL_DMA_CHANNEL_3
;;;654      *         @arg @ref LL_DMA_CHANNEL_4
;;;655      *         @arg @ref LL_DMA_CHANNEL_5
;;;656      *         @arg @ref LL_DMA_CHANNEL_6
;;;657      *         @arg @ref LL_DMA_CHANNEL_7
;;;658      * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;660      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
;;;664    {
;;;665      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
;;;666                 PeriphOrM2MSrcIncMode);
;;;667    }
;;;668    
;;;669    /**
;;;670      * @brief  Get Peripheral increment mode.
;;;671      * @rmtoll CCR          PINC          LL_DMA_GetPeriphIncMode
;;;672      * @param  DMAx DMAx Instance
;;;673      * @param  Channel This parameter can be one of the following values:
;;;674      *         @arg @ref LL_DMA_CHANNEL_1
;;;675      *         @arg @ref LL_DMA_CHANNEL_2
;;;676      *         @arg @ref LL_DMA_CHANNEL_3
;;;677      *         @arg @ref LL_DMA_CHANNEL_4
;;;678      *         @arg @ref LL_DMA_CHANNEL_5
;;;679      *         @arg @ref LL_DMA_CHANNEL_6
;;;680      *         @arg @ref LL_DMA_CHANNEL_7
;;;681      * @retval Returned value can be one of the following values:
;;;682      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;683      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;684      */
;;;685    __STATIC_INLINE uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;686    {
;;;687      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;688                       DMA_CCR_PINC));
;;;689    }
;;;690    
;;;691    /**
;;;692      * @brief  Set Memory increment mode.
;;;693      * @rmtoll CCR          MINC          LL_DMA_SetMemoryIncMode
;;;694      * @param  DMAx DMAx Instance
;;;695      * @param  Channel This parameter can be one of the following values:
;;;696      *         @arg @ref LL_DMA_CHANNEL_1
;;;697      *         @arg @ref LL_DMA_CHANNEL_2
;;;698      *         @arg @ref LL_DMA_CHANNEL_3
;;;699      *         @arg @ref LL_DMA_CHANNEL_4
;;;700      *         @arg @ref LL_DMA_CHANNEL_5
;;;701      *         @arg @ref LL_DMA_CHANNEL_6
;;;702      *         @arg @ref LL_DMA_CHANNEL_7
;;;703      * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
;;;704      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;705      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;706      * @retval None
;;;707      */
;;;708    __STATIC_INLINE void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
;;;709    {
;;;710      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
;;;711                 MemoryOrM2MDstIncMode);
;;;712    }
;;;713    
;;;714    /**
;;;715      * @brief  Get Memory increment mode.
;;;716      * @rmtoll CCR          MINC          LL_DMA_GetMemoryIncMode
;;;717      * @param  DMAx DMAx Instance
;;;718      * @param  Channel This parameter can be one of the following values:
;;;719      *         @arg @ref LL_DMA_CHANNEL_1
;;;720      *         @arg @ref LL_DMA_CHANNEL_2
;;;721      *         @arg @ref LL_DMA_CHANNEL_3
;;;722      *         @arg @ref LL_DMA_CHANNEL_4
;;;723      *         @arg @ref LL_DMA_CHANNEL_5
;;;724      *         @arg @ref LL_DMA_CHANNEL_6
;;;725      *         @arg @ref LL_DMA_CHANNEL_7
;;;726      * @retval Returned value can be one of the following values:
;;;727      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;728      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;729      */
;;;730    __STATIC_INLINE uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;731    {
;;;732      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;733                       DMA_CCR_MINC));
;;;734    }
;;;735    
;;;736    /**
;;;737      * @brief  Set Peripheral size.
;;;738      * @rmtoll CCR          PSIZE         LL_DMA_SetPeriphSize
;;;739      * @param  DMAx DMAx Instance
;;;740      * @param  Channel This parameter can be one of the following values:
;;;741      *         @arg @ref LL_DMA_CHANNEL_1
;;;742      *         @arg @ref LL_DMA_CHANNEL_2
;;;743      *         @arg @ref LL_DMA_CHANNEL_3
;;;744      *         @arg @ref LL_DMA_CHANNEL_4
;;;745      *         @arg @ref LL_DMA_CHANNEL_5
;;;746      *         @arg @ref LL_DMA_CHANNEL_6
;;;747      *         @arg @ref LL_DMA_CHANNEL_7
;;;748      * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
;;;749      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;750      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;751      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;752      * @retval None
;;;753      */
;;;754    __STATIC_INLINE void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
;;;755    {
;;;756      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
;;;757                 PeriphOrM2MSrcDataSize);
;;;758    }
;;;759    
;;;760    /**
;;;761      * @brief  Get Peripheral size.
;;;762      * @rmtoll CCR          PSIZE         LL_DMA_GetPeriphSize
;;;763      * @param  DMAx DMAx Instance
;;;764      * @param  Channel This parameter can be one of the following values:
;;;765      *         @arg @ref LL_DMA_CHANNEL_1
;;;766      *         @arg @ref LL_DMA_CHANNEL_2
;;;767      *         @arg @ref LL_DMA_CHANNEL_3
;;;768      *         @arg @ref LL_DMA_CHANNEL_4
;;;769      *         @arg @ref LL_DMA_CHANNEL_5
;;;770      *         @arg @ref LL_DMA_CHANNEL_6
;;;771      *         @arg @ref LL_DMA_CHANNEL_7
;;;772      * @retval Returned value can be one of the following values:
;;;773      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;774      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;775      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;776      */
;;;777    __STATIC_INLINE uint32_t LL_DMA_GetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel)
;;;778    {
;;;779      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;780                       DMA_CCR_PSIZE));
;;;781    }
;;;782    
;;;783    /**
;;;784      * @brief  Set Memory size.
;;;785      * @rmtoll CCR          MSIZE         LL_DMA_SetMemorySize
;;;786      * @param  DMAx DMAx Instance
;;;787      * @param  Channel This parameter can be one of the following values:
;;;788      *         @arg @ref LL_DMA_CHANNEL_1
;;;789      *         @arg @ref LL_DMA_CHANNEL_2
;;;790      *         @arg @ref LL_DMA_CHANNEL_3
;;;791      *         @arg @ref LL_DMA_CHANNEL_4
;;;792      *         @arg @ref LL_DMA_CHANNEL_5
;;;793      *         @arg @ref LL_DMA_CHANNEL_6
;;;794      *         @arg @ref LL_DMA_CHANNEL_7
;;;795      * @param  MemoryOrM2MDstDataSize This parameter can be one of the following values:
;;;796      *         @arg @ref LL_DMA_MDATAALIGN_BYTE
;;;797      *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
;;;798      *         @arg @ref LL_DMA_MDATAALIGN_WORD
;;;799      * @retval None
;;;800      */
;;;801    __STATIC_INLINE void LL_DMA_SetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstDataSize)
;;;802    {
;;;803      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
;;;804                 MemoryOrM2MDstDataSize);
;;;805    }
;;;806    
;;;807    /**
;;;808      * @brief  Get Memory size.
;;;809      * @rmtoll CCR          MSIZE         LL_DMA_GetMemorySize
;;;810      * @param  DMAx DMAx Instance
;;;811      * @param  Channel This parameter can be one of the following values:
;;;812      *         @arg @ref LL_DMA_CHANNEL_1
;;;813      *         @arg @ref LL_DMA_CHANNEL_2
;;;814      *         @arg @ref LL_DMA_CHANNEL_3
;;;815      *         @arg @ref LL_DMA_CHANNEL_4
;;;816      *         @arg @ref LL_DMA_CHANNEL_5
;;;817      *         @arg @ref LL_DMA_CHANNEL_6
;;;818      *         @arg @ref LL_DMA_CHANNEL_7
;;;819      * @retval Returned value can be one of the following values:
;;;820      *         @arg @ref LL_DMA_MDATAALIGN_BYTE
;;;821      *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
;;;822      *         @arg @ref LL_DMA_MDATAALIGN_WORD
;;;823      */
;;;824    __STATIC_INLINE uint32_t LL_DMA_GetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel)
;;;825    {
;;;826      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;827                       DMA_CCR_MSIZE));
;;;828    }
;;;829    
;;;830    /**
;;;831      * @brief  Set Channel priority level.
;;;832      * @rmtoll CCR          PL            LL_DMA_SetChannelPriorityLevel
;;;833      * @param  DMAx DMAx Instance
;;;834      * @param  Channel This parameter can be one of the following values:
;;;835      *         @arg @ref LL_DMA_CHANNEL_1
;;;836      *         @arg @ref LL_DMA_CHANNEL_2
;;;837      *         @arg @ref LL_DMA_CHANNEL_3
;;;838      *         @arg @ref LL_DMA_CHANNEL_4
;;;839      *         @arg @ref LL_DMA_CHANNEL_5
;;;840      *         @arg @ref LL_DMA_CHANNEL_6
;;;841      *         @arg @ref LL_DMA_CHANNEL_7
;;;842      * @param  Priority This parameter can be one of the following values:
;;;843      *         @arg @ref LL_DMA_PRIORITY_LOW
;;;844      *         @arg @ref LL_DMA_PRIORITY_MEDIUM
;;;845      *         @arg @ref LL_DMA_PRIORITY_HIGH
;;;846      *         @arg @ref LL_DMA_PRIORITY_VERYHIGH
;;;847      * @retval None
;;;848      */
;;;849    __STATIC_INLINE void LL_DMA_SetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Priority)
;;;850    {
;;;851      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
;;;852                 Priority);
;;;853    }
;;;854    
;;;855    /**
;;;856      * @brief  Get Channel priority level.
;;;857      * @rmtoll CCR          PL            LL_DMA_GetChannelPriorityLevel
;;;858      * @param  DMAx DMAx Instance
;;;859      * @param  Channel This parameter can be one of the following values:
;;;860      *         @arg @ref LL_DMA_CHANNEL_1
;;;861      *         @arg @ref LL_DMA_CHANNEL_2
;;;862      *         @arg @ref LL_DMA_CHANNEL_3
;;;863      *         @arg @ref LL_DMA_CHANNEL_4
;;;864      *         @arg @ref LL_DMA_CHANNEL_5
;;;865      *         @arg @ref LL_DMA_CHANNEL_6
;;;866      *         @arg @ref LL_DMA_CHANNEL_7
;;;867      * @retval Returned value can be one of the following values:
;;;868      *         @arg @ref LL_DMA_PRIORITY_LOW
;;;869      *         @arg @ref LL_DMA_PRIORITY_MEDIUM
;;;870      *         @arg @ref LL_DMA_PRIORITY_HIGH
;;;871      *         @arg @ref LL_DMA_PRIORITY_VERYHIGH
;;;872      */
;;;873    __STATIC_INLINE uint32_t LL_DMA_GetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel)
;;;874    {
;;;875      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;876                       DMA_CCR_PL));
;;;877    }
;;;878    
;;;879    /**
;;;880      * @brief  Set Number of data to transfer.
;;;881      * @note   This action has no effect if
;;;882      *         channel is enabled.
;;;883      * @rmtoll CNDTR        NDT           LL_DMA_SetDataLength
;;;884      * @param  DMAx DMAx Instance
;;;885      * @param  Channel This parameter can be one of the following values:
;;;886      *         @arg @ref LL_DMA_CHANNEL_1
;;;887      *         @arg @ref LL_DMA_CHANNEL_2
;;;888      *         @arg @ref LL_DMA_CHANNEL_3
;;;889      *         @arg @ref LL_DMA_CHANNEL_4
;;;890      *         @arg @ref LL_DMA_CHANNEL_5
;;;891      *         @arg @ref LL_DMA_CHANNEL_6
;;;892      *         @arg @ref LL_DMA_CHANNEL_7
;;;893      * @param  NbData Between Min_Data = 0 and Max_Data = 0x0000FFFF
;;;894      * @retval None
;;;895      */
;;;896    __STATIC_INLINE void LL_DMA_SetDataLength(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t NbData)
;;;897    {
;;;898      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
;;;899                 DMA_CNDTR_NDT, NbData);
;;;900    }
;;;901    
;;;902    /**
;;;903      * @brief  Get Number of data to transfer.
;;;904      * @note   Once the channel is enabled, the return value indicate the
;;;905      *         remaining bytes to be transmitted.
;;;906      * @rmtoll CNDTR        NDT           LL_DMA_GetDataLength
;;;907      * @param  DMAx DMAx Instance
;;;908      * @param  Channel This parameter can be one of the following values:
;;;909      *         @arg @ref LL_DMA_CHANNEL_1
;;;910      *         @arg @ref LL_DMA_CHANNEL_2
;;;911      *         @arg @ref LL_DMA_CHANNEL_3
;;;912      *         @arg @ref LL_DMA_CHANNEL_4
;;;913      *         @arg @ref LL_DMA_CHANNEL_5
;;;914      *         @arg @ref LL_DMA_CHANNEL_6
;;;915      *         @arg @ref LL_DMA_CHANNEL_7
;;;916      * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;917      */
;;;918    __STATIC_INLINE uint32_t LL_DMA_GetDataLength(DMA_TypeDef *DMAx, uint32_t Channel)
;;;919    {
;;;920      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
;;;921                       DMA_CNDTR_NDT));
;;;922    }
;;;923    
;;;924    /**
;;;925      * @brief  Configure the Source and Destination addresses.
;;;926      * @note   This API must not be called when the DMA channel is enabled.
;;;927      * @note   Each IP using DMA provides an API to get directly the register adress (LL_PPP_DMA_GetRegAddr).
;;;928      * @rmtoll CPAR         PA            LL_DMA_ConfigAddresses\n
;;;929      *         CMAR         MA            LL_DMA_ConfigAddresses
;;;930      * @param  DMAx DMAx Instance
;;;931      * @param  Channel This parameter can be one of the following values:
;;;932      *         @arg @ref LL_DMA_CHANNEL_1
;;;933      *         @arg @ref LL_DMA_CHANNEL_2
;;;934      *         @arg @ref LL_DMA_CHANNEL_3
;;;935      *         @arg @ref LL_DMA_CHANNEL_4
;;;936      *         @arg @ref LL_DMA_CHANNEL_5
;;;937      *         @arg @ref LL_DMA_CHANNEL_6
;;;938      *         @arg @ref LL_DMA_CHANNEL_7
;;;939      * @param  SrcAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;940      * @param  DstAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;941      * @param  Direction This parameter can be one of the following values:
;;;942      *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
;;;943      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
;;;944      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
;;;945      * @retval None
;;;946      */
;;;947    __STATIC_INLINE void LL_DMA_ConfigAddresses(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcAddress,
;;;948                                                uint32_t DstAddress, uint32_t Direction)
;;;949    {
;;;950      /* Direction Memory to Periph */
;;;951      if (Direction == LL_DMA_DIRECTION_MEMORY_TO_PERIPH)
;;;952      {
;;;953        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, SrcAddress);
;;;954        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, DstAddress);
;;;955      }
;;;956      /* Direction Periph to Memory and Memory to Memory */
;;;957      else
;;;958      {
;;;959        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, SrcAddress);
;;;960        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, DstAddress);
;;;961      }
;;;962    }
;;;963    
;;;964    /**
;;;965      * @brief  Set the Memory address.
;;;966      * @note   Interface used for direction LL_DMA_DIRECTION_PERIPH_TO_MEMORY or LL_DMA_DIRECTION_MEMORY_TO_PERIPH only.
;;;967      * @note   This API must not be called when the DMA channel is enabled.
;;;968      * @rmtoll CMAR         MA            LL_DMA_SetMemoryAddress
;;;969      * @param  DMAx DMAx Instance
;;;970      * @param  Channel This parameter can be one of the following values:
;;;971      *         @arg @ref LL_DMA_CHANNEL_1
;;;972      *         @arg @ref LL_DMA_CHANNEL_2
;;;973      *         @arg @ref LL_DMA_CHANNEL_3
;;;974      *         @arg @ref LL_DMA_CHANNEL_4
;;;975      *         @arg @ref LL_DMA_CHANNEL_5
;;;976      *         @arg @ref LL_DMA_CHANNEL_6
;;;977      *         @arg @ref LL_DMA_CHANNEL_7
;;;978      * @param  MemoryAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;979      * @retval None
;;;980      */
;;;981    __STATIC_INLINE void LL_DMA_SetMemoryAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress)
;;;982    {
;;;983      WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, MemoryAddress);
;;;984    }
;;;985    
;;;986    /**
;;;987      * @brief  Set the Peripheral address.
;;;988      * @note   Interface used for direction LL_DMA_DIRECTION_PERIPH_TO_MEMORY or LL_DMA_DIRECTION_MEMORY_TO_PERIPH only.
;;;989      * @note   This API must not be called when the DMA channel is enabled.
;;;990      * @rmtoll CPAR         PA            LL_DMA_SetPeriphAddress
;;;991      * @param  DMAx DMAx Instance
;;;992      * @param  Channel This parameter can be one of the following values:
;;;993      *         @arg @ref LL_DMA_CHANNEL_1
;;;994      *         @arg @ref LL_DMA_CHANNEL_2
;;;995      *         @arg @ref LL_DMA_CHANNEL_3
;;;996      *         @arg @ref LL_DMA_CHANNEL_4
;;;997      *         @arg @ref LL_DMA_CHANNEL_5
;;;998      *         @arg @ref LL_DMA_CHANNEL_6
;;;999      *         @arg @ref LL_DMA_CHANNEL_7
;;;1000     * @param  PeriphAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;1001     * @retval None
;;;1002     */
;;;1003   __STATIC_INLINE void LL_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphAddress)
;;;1004   {
;;;1005     WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, PeriphAddress);
;;;1006   }
;;;1007   
;;;1008   /**
;;;1009     * @brief  Get Memory address.
;;;1010     * @note   Interface used for direction LL_DMA_DIRECTION_PERIPH_TO_MEMORY or LL_DMA_DIRECTION_MEMORY_TO_PERIPH only.
;;;1011     * @rmtoll CMAR         MA            LL_DMA_GetMemoryAddress
;;;1012     * @param  DMAx DMAx Instance
;;;1013     * @param  Channel This parameter can be one of the following values:
;;;1014     *         @arg @ref LL_DMA_CHANNEL_1
;;;1015     *         @arg @ref LL_DMA_CHANNEL_2
;;;1016     *         @arg @ref LL_DMA_CHANNEL_3
;;;1017     *         @arg @ref LL_DMA_CHANNEL_4
;;;1018     *         @arg @ref LL_DMA_CHANNEL_5
;;;1019     *         @arg @ref LL_DMA_CHANNEL_6
;;;1020     *         @arg @ref LL_DMA_CHANNEL_7
;;;1021     * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;1022     */
;;;1023   __STATIC_INLINE uint32_t LL_DMA_GetMemoryAddress(DMA_TypeDef *DMAx, uint32_t Channel)
;;;1024   {
;;;1025     return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR));
;;;1026   }
;;;1027   
;;;1028   /**
;;;1029     * @brief  Get Peripheral address.
;;;1030     * @note   Interface used for direction LL_DMA_DIRECTION_PERIPH_TO_MEMORY or LL_DMA_DIRECTION_MEMORY_TO_PERIPH only.
;;;1031     * @rmtoll CPAR         PA            LL_DMA_GetPeriphAddress
;;;1032     * @param  DMAx DMAx Instance
;;;1033     * @param  Channel This parameter can be one of the following values:
;;;1034     *         @arg @ref LL_DMA_CHANNEL_1
;;;1035     *         @arg @ref LL_DMA_CHANNEL_2
;;;1036     *         @arg @ref LL_DMA_CHANNEL_3
;;;1037     *         @arg @ref LL_DMA_CHANNEL_4
;;;1038     *         @arg @ref LL_DMA_CHANNEL_5
;;;1039     *         @arg @ref LL_DMA_CHANNEL_6
;;;1040     *         @arg @ref LL_DMA_CHANNEL_7
;;;1041     * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;1042     */
;;;1043   __STATIC_INLINE uint32_t LL_DMA_GetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel)
;;;1044   {
;;;1045     return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR));
;;;1046   }
;;;1047   
;;;1048   /**
;;;1049     * @brief  Set the Memory to Memory Source address.
;;;1050     * @note   Interface used for direction LL_DMA_DIRECTION_MEMORY_TO_MEMORY only.
;;;1051     * @note   This API must not be called when the DMA channel is enabled.
;;;1052     * @rmtoll CPAR         PA            LL_DMA_SetM2MSrcAddress
;;;1053     * @param  DMAx DMAx Instance
;;;1054     * @param  Channel This parameter can be one of the following values:
;;;1055     *         @arg @ref LL_DMA_CHANNEL_1
;;;1056     *         @arg @ref LL_DMA_CHANNEL_2
;;;1057     *         @arg @ref LL_DMA_CHANNEL_3
;;;1058     *         @arg @ref LL_DMA_CHANNEL_4
;;;1059     *         @arg @ref LL_DMA_CHANNEL_5
;;;1060     *         @arg @ref LL_DMA_CHANNEL_6
;;;1061     *         @arg @ref LL_DMA_CHANNEL_7
;;;1062     * @param  MemoryAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;1063     * @retval None
;;;1064     */
;;;1065   __STATIC_INLINE void LL_DMA_SetM2MSrcAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress)
;;;1066   {
;;;1067     WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, MemoryAddress);
;;;1068   }
;;;1069   
;;;1070   /**
;;;1071     * @brief  Set the Memory to Memory Destination address.
;;;1072     * @note   Interface used for direction LL_DMA_DIRECTION_MEMORY_TO_MEMORY only.
;;;1073     * @note   This API must not be called when the DMA channel is enabled.
;;;1074     * @rmtoll CMAR         MA            LL_DMA_SetM2MDstAddress
;;;1075     * @param  DMAx DMAx Instance
;;;1076     * @param  Channel This parameter can be one of the following values:
;;;1077     *         @arg @ref LL_DMA_CHANNEL_1
;;;1078     *         @arg @ref LL_DMA_CHANNEL_2
;;;1079     *         @arg @ref LL_DMA_CHANNEL_3
;;;1080     *         @arg @ref LL_DMA_CHANNEL_4
;;;1081     *         @arg @ref LL_DMA_CHANNEL_5
;;;1082     *         @arg @ref LL_DMA_CHANNEL_6
;;;1083     *         @arg @ref LL_DMA_CHANNEL_7
;;;1084     * @param  MemoryAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;1085     * @retval None
;;;1086     */
;;;1087   __STATIC_INLINE void LL_DMA_SetM2MDstAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryAddress)
;;;1088   {
;;;1089     WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, MemoryAddress);
;;;1090   }
;;;1091   
;;;1092   /**
;;;1093     * @brief  Get the Memory to Memory Source address.
;;;1094     * @note   Interface used for direction LL_DMA_DIRECTION_MEMORY_TO_MEMORY only.
;;;1095     * @rmtoll CPAR         PA            LL_DMA_GetM2MSrcAddress
;;;1096     * @param  DMAx DMAx Instance
;;;1097     * @param  Channel This parameter can be one of the following values:
;;;1098     *         @arg @ref LL_DMA_CHANNEL_1
;;;1099     *         @arg @ref LL_DMA_CHANNEL_2
;;;1100     *         @arg @ref LL_DMA_CHANNEL_3
;;;1101     *         @arg @ref LL_DMA_CHANNEL_4
;;;1102     *         @arg @ref LL_DMA_CHANNEL_5
;;;1103     *         @arg @ref LL_DMA_CHANNEL_6
;;;1104     *         @arg @ref LL_DMA_CHANNEL_7
;;;1105     * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;1106     */
;;;1107   __STATIC_INLINE uint32_t LL_DMA_GetM2MSrcAddress(DMA_TypeDef *DMAx, uint32_t Channel)
;;;1108   {
;;;1109     return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR));
;;;1110   }
;;;1111   
;;;1112   /**
;;;1113     * @brief  Get the Memory to Memory Destination address.
;;;1114     * @note   Interface used for direction LL_DMA_DIRECTION_MEMORY_TO_MEMORY only.
;;;1115     * @rmtoll CMAR         MA            LL_DMA_GetM2MDstAddress
;;;1116     * @param  DMAx DMAx Instance
;;;1117     * @param  Channel This parameter can be one of the following values:
;;;1118     *         @arg @ref LL_DMA_CHANNEL_1
;;;1119     *         @arg @ref LL_DMA_CHANNEL_2
;;;1120     *         @arg @ref LL_DMA_CHANNEL_3
;;;1121     *         @arg @ref LL_DMA_CHANNEL_4
;;;1122     *         @arg @ref LL_DMA_CHANNEL_5
;;;1123     *         @arg @ref LL_DMA_CHANNEL_6
;;;1124     *         @arg @ref LL_DMA_CHANNEL_7
;;;1125     * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;1126     */
;;;1127   __STATIC_INLINE uint32_t LL_DMA_GetM2MDstAddress(DMA_TypeDef *DMAx, uint32_t Channel)
;;;1128   {
;;;1129     return (READ_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR));
;;;1130   }
;;;1131   
;;;1132   /**
;;;1133     * @}
;;;1134     */
;;;1135   
;;;1136   /** @defgroup DMA_LL_EF_FLAG_Management FLAG_Management
;;;1137     * @{
;;;1138     */
;;;1139   
;;;1140   /**
;;;1141     * @brief  Get Channel 1 global interrupt flag.
;;;1142     * @rmtoll ISR          GIF1          LL_DMA_IsActiveFlag_GI1
;;;1143     * @param  DMAx DMAx Instance
;;;1144     * @retval State of bit (1 or 0).
;;;1145     */
;;;1146   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI1(DMA_TypeDef *DMAx)
;;;1147   {
;;;1148     return (READ_BIT(DMAx->ISR, DMA_ISR_GIF1) == (DMA_ISR_GIF1));
;;;1149   }
;;;1150   
;;;1151   /**
;;;1152     * @brief  Get Channel 2 global interrupt flag.
;;;1153     * @rmtoll ISR          GIF2          LL_DMA_IsActiveFlag_GI2
;;;1154     * @param  DMAx DMAx Instance
;;;1155     * @retval State of bit (1 or 0).
;;;1156     */
;;;1157   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI2(DMA_TypeDef *DMAx)
;;;1158   {
;;;1159     return (READ_BIT(DMAx->ISR, DMA_ISR_GIF2) == (DMA_ISR_GIF2));
;;;1160   }
;;;1161   
;;;1162   /**
;;;1163     * @brief  Get Channel 3 global interrupt flag.
;;;1164     * @rmtoll ISR          GIF3          LL_DMA_IsActiveFlag_GI3
;;;1165     * @param  DMAx DMAx Instance
;;;1166     * @retval State of bit (1 or 0).
;;;1167     */
;;;1168   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI3(DMA_TypeDef *DMAx)
;;;1169   {
;;;1170     return (READ_BIT(DMAx->ISR, DMA_ISR_GIF3) == (DMA_ISR_GIF3));
;;;1171   }
;;;1172   
;;;1173   /**
;;;1174     * @brief  Get Channel 4 global interrupt flag.
;;;1175     * @rmtoll ISR          GIF4          LL_DMA_IsActiveFlag_GI4
;;;1176     * @param  DMAx DMAx Instance
;;;1177     * @retval State of bit (1 or 0).
;;;1178     */
;;;1179   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI4(DMA_TypeDef *DMAx)
;;;1180   {
;;;1181     return (READ_BIT(DMAx->ISR, DMA_ISR_GIF4) == (DMA_ISR_GIF4));
;;;1182   }
;;;1183   
;;;1184   /**
;;;1185     * @brief  Get Channel 5 global interrupt flag.
;;;1186     * @rmtoll ISR          GIF5          LL_DMA_IsActiveFlag_GI5
;;;1187     * @param  DMAx DMAx Instance
;;;1188     * @retval State of bit (1 or 0).
;;;1189     */
;;;1190   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI5(DMA_TypeDef *DMAx)
;;;1191   {
;;;1192     return (READ_BIT(DMAx->ISR, DMA_ISR_GIF5) == (DMA_ISR_GIF5));
;;;1193   }
;;;1194   
;;;1195   /**
;;;1196     * @brief  Get Channel 6 global interrupt flag.
;;;1197     * @rmtoll ISR          GIF6          LL_DMA_IsActiveFlag_GI6
;;;1198     * @param  DMAx DMAx Instance
;;;1199     * @retval State of bit (1 or 0).
;;;1200     */
;;;1201   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI6(DMA_TypeDef *DMAx)
;;;1202   {
;;;1203     return (READ_BIT(DMAx->ISR, DMA_ISR_GIF6) == (DMA_ISR_GIF6));
;;;1204   }
;;;1205   
;;;1206   /**
;;;1207     * @brief  Get Channel 7 global interrupt flag.
;;;1208     * @rmtoll ISR          GIF7          LL_DMA_IsActiveFlag_GI7
;;;1209     * @param  DMAx DMAx Instance
;;;1210     * @retval State of bit (1 or 0).
;;;1211     */
;;;1212   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_GI7(DMA_TypeDef *DMAx)
;;;1213   {
;;;1214     return (READ_BIT(DMAx->ISR, DMA_ISR_GIF7) == (DMA_ISR_GIF7));
;;;1215   }
;;;1216   
;;;1217   /**
;;;1218     * @brief  Get Channel 1 transfer complete flag.
;;;1219     * @rmtoll ISR          TCIF1         LL_DMA_IsActiveFlag_TC1
;;;1220     * @param  DMAx DMAx Instance
;;;1221     * @retval State of bit (1 or 0).
;;;1222     */
;;;1223   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC1(DMA_TypeDef *DMAx)
;;;1224   {
;;;1225     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF1) == (DMA_ISR_TCIF1));
;;;1226   }
;;;1227   
;;;1228   /**
;;;1229     * @brief  Get Channel 2 transfer complete flag.
;;;1230     * @rmtoll ISR          TCIF2         LL_DMA_IsActiveFlag_TC2
;;;1231     * @param  DMAx DMAx Instance
;;;1232     * @retval State of bit (1 or 0).
;;;1233     */
;;;1234   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC2(DMA_TypeDef *DMAx)
;;;1235   {
;;;1236     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF2) == (DMA_ISR_TCIF2));
;;;1237   }
;;;1238   
;;;1239   /**
;;;1240     * @brief  Get Channel 3 transfer complete flag.
;;;1241     * @rmtoll ISR          TCIF3         LL_DMA_IsActiveFlag_TC3
;;;1242     * @param  DMAx DMAx Instance
;;;1243     * @retval State of bit (1 or 0).
;;;1244     */
;;;1245   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC3(DMA_TypeDef *DMAx)
;;;1246   {
;;;1247     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF3) == (DMA_ISR_TCIF3));
;;;1248   }
;;;1249   
;;;1250   /**
;;;1251     * @brief  Get Channel 4 transfer complete flag.
;;;1252     * @rmtoll ISR          TCIF4         LL_DMA_IsActiveFlag_TC4
;;;1253     * @param  DMAx DMAx Instance
;;;1254     * @retval State of bit (1 or 0).
;;;1255     */
;;;1256   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC4(DMA_TypeDef *DMAx)
;;;1257   {
;;;1258     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF4) == (DMA_ISR_TCIF4));
;;;1259   }
;;;1260   
;;;1261   /**
;;;1262     * @brief  Get Channel 5 transfer complete flag.
;;;1263     * @rmtoll ISR          TCIF5         LL_DMA_IsActiveFlag_TC5
;;;1264     * @param  DMAx DMAx Instance
;;;1265     * @retval State of bit (1 or 0).
;;;1266     */
;;;1267   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC5(DMA_TypeDef *DMAx)
;;;1268   {
;;;1269     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF5) == (DMA_ISR_TCIF5));
;;;1270   }
;;;1271   
;;;1272   /**
;;;1273     * @brief  Get Channel 6 transfer complete flag.
;;;1274     * @rmtoll ISR          TCIF6         LL_DMA_IsActiveFlag_TC6
;;;1275     * @param  DMAx DMAx Instance
;;;1276     * @retval State of bit (1 or 0).
;;;1277     */
;;;1278   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC6(DMA_TypeDef *DMAx)
;;;1279   {
;;;1280     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF6) == (DMA_ISR_TCIF6));
;;;1281   }
;;;1282   
;;;1283   /**
;;;1284     * @brief  Get Channel 7 transfer complete flag.
;;;1285     * @rmtoll ISR          TCIF7         LL_DMA_IsActiveFlag_TC7
;;;1286     * @param  DMAx DMAx Instance
;;;1287     * @retval State of bit (1 or 0).
;;;1288     */
;;;1289   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC7(DMA_TypeDef *DMAx)
;;;1290   {
;;;1291     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF7) == (DMA_ISR_TCIF7));
;;;1292   }
;;;1293   
;;;1294   /**
;;;1295     * @brief  Get Channel 1 half transfer flag.
;;;1296     * @rmtoll ISR          HTIF1         LL_DMA_IsActiveFlag_HT1
;;;1297     * @param  DMAx DMAx Instance
;;;1298     * @retval State of bit (1 or 0).
;;;1299     */
;;;1300   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT1(DMA_TypeDef *DMAx)
;;;1301   {
;;;1302     return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF1) == (DMA_ISR_HTIF1));
;;;1303   }
;;;1304   
;;;1305   /**
;;;1306     * @brief  Get Channel 2 half transfer flag.
;;;1307     * @rmtoll ISR          HTIF2         LL_DMA_IsActiveFlag_HT2
;;;1308     * @param  DMAx DMAx Instance
;;;1309     * @retval State of bit (1 or 0).
;;;1310     */
;;;1311   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT2(DMA_TypeDef *DMAx)
;;;1312   {
;;;1313     return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF2) == (DMA_ISR_HTIF2));
;;;1314   }
;;;1315   
;;;1316   /**
;;;1317     * @brief  Get Channel 3 half transfer flag.
;;;1318     * @rmtoll ISR          HTIF3         LL_DMA_IsActiveFlag_HT3
;;;1319     * @param  DMAx DMAx Instance
;;;1320     * @retval State of bit (1 or 0).
;;;1321     */
;;;1322   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT3(DMA_TypeDef *DMAx)
;;;1323   {
;;;1324     return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF3) == (DMA_ISR_HTIF3));
;;;1325   }
;;;1326   
;;;1327   /**
;;;1328     * @brief  Get Channel 4 half transfer flag.
;;;1329     * @rmtoll ISR          HTIF4         LL_DMA_IsActiveFlag_HT4
;;;1330     * @param  DMAx DMAx Instance
;;;1331     * @retval State of bit (1 or 0).
;;;1332     */
;;;1333   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT4(DMA_TypeDef *DMAx)
;;;1334   {
;;;1335     return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF4) == (DMA_ISR_HTIF4));
;;;1336   }
;;;1337   
;;;1338   /**
;;;1339     * @brief  Get Channel 5 half transfer flag.
;;;1340     * @rmtoll ISR          HTIF5         LL_DMA_IsActiveFlag_HT5
;;;1341     * @param  DMAx DMAx Instance
;;;1342     * @retval State of bit (1 or 0).
;;;1343     */
;;;1344   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT5(DMA_TypeDef *DMAx)
;;;1345   {
;;;1346     return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF5) == (DMA_ISR_HTIF5));
;;;1347   }
;;;1348   
;;;1349   /**
;;;1350     * @brief  Get Channel 6 half transfer flag.
;;;1351     * @rmtoll ISR          HTIF6         LL_DMA_IsActiveFlag_HT6
;;;1352     * @param  DMAx DMAx Instance
;;;1353     * @retval State of bit (1 or 0).
;;;1354     */
;;;1355   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT6(DMA_TypeDef *DMAx)
;;;1356   {
;;;1357     return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF6) == (DMA_ISR_HTIF6));
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get Channel 7 half transfer flag.
;;;1362     * @rmtoll ISR          HTIF7         LL_DMA_IsActiveFlag_HT7
;;;1363     * @param  DMAx DMAx Instance
;;;1364     * @retval State of bit (1 or 0).
;;;1365     */
;;;1366   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_HT7(DMA_TypeDef *DMAx)
;;;1367   {
;;;1368     return (READ_BIT(DMAx->ISR, DMA_ISR_HTIF7) == (DMA_ISR_HTIF7));
;;;1369   }
;;;1370   
;;;1371   /**
;;;1372     * @brief  Get Channel 1 transfer error flag.
;;;1373     * @rmtoll ISR          TEIF1         LL_DMA_IsActiveFlag_TE1
;;;1374     * @param  DMAx DMAx Instance
;;;1375     * @retval State of bit (1 or 0).
;;;1376     */
;;;1377   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE1(DMA_TypeDef *DMAx)
;;;1378   {
;;;1379     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF1) == (DMA_ISR_TEIF1));
;;;1380   }
;;;1381   
;;;1382   /**
;;;1383     * @brief  Get Channel 2 transfer error flag.
;;;1384     * @rmtoll ISR          TEIF2         LL_DMA_IsActiveFlag_TE2
;;;1385     * @param  DMAx DMAx Instance
;;;1386     * @retval State of bit (1 or 0).
;;;1387     */
;;;1388   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE2(DMA_TypeDef *DMAx)
;;;1389   {
;;;1390     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF2) == (DMA_ISR_TEIF2));
;;;1391   }
;;;1392   
;;;1393   /**
;;;1394     * @brief  Get Channel 3 transfer error flag.
;;;1395     * @rmtoll ISR          TEIF3         LL_DMA_IsActiveFlag_TE3
;;;1396     * @param  DMAx DMAx Instance
;;;1397     * @retval State of bit (1 or 0).
;;;1398     */
;;;1399   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE3(DMA_TypeDef *DMAx)
;;;1400   {
;;;1401     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF3) == (DMA_ISR_TEIF3));
;;;1402   }
;;;1403   
;;;1404   /**
;;;1405     * @brief  Get Channel 4 transfer error flag.
;;;1406     * @rmtoll ISR          TEIF4         LL_DMA_IsActiveFlag_TE4
;;;1407     * @param  DMAx DMAx Instance
;;;1408     * @retval State of bit (1 or 0).
;;;1409     */
;;;1410   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE4(DMA_TypeDef *DMAx)
;;;1411   {
;;;1412     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF4) == (DMA_ISR_TEIF4));
;;;1413   }
;;;1414   
;;;1415   /**
;;;1416     * @brief  Get Channel 5 transfer error flag.
;;;1417     * @rmtoll ISR          TEIF5         LL_DMA_IsActiveFlag_TE5
;;;1418     * @param  DMAx DMAx Instance
;;;1419     * @retval State of bit (1 or 0).
;;;1420     */
;;;1421   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE5(DMA_TypeDef *DMAx)
;;;1422   {
;;;1423     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF5) == (DMA_ISR_TEIF5));
;;;1424   }
;;;1425   
;;;1426   /**
;;;1427     * @brief  Get Channel 6 transfer error flag.
;;;1428     * @rmtoll ISR          TEIF6         LL_DMA_IsActiveFlag_TE6
;;;1429     * @param  DMAx DMAx Instance
;;;1430     * @retval State of bit (1 or 0).
;;;1431     */
;;;1432   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE6(DMA_TypeDef *DMAx)
;;;1433   {
;;;1434     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF6) == (DMA_ISR_TEIF6));
;;;1435   }
;;;1436   
;;;1437   /**
;;;1438     * @brief  Get Channel 7 transfer error flag.
;;;1439     * @rmtoll ISR          TEIF7         LL_DMA_IsActiveFlag_TE7
;;;1440     * @param  DMAx DMAx Instance
;;;1441     * @retval State of bit (1 or 0).
;;;1442     */
;;;1443   __STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TE7(DMA_TypeDef *DMAx)
;;;1444   {
;;;1445     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF7) == (DMA_ISR_TEIF7));
;;;1446   }
;;;1447   
;;;1448   /**
;;;1449     * @brief  Clear Channel 1 global interrupt flag.
;;;1450     * @rmtoll IFCR         CGIF1         LL_DMA_ClearFlag_GI1
;;;1451     * @param  DMAx DMAx Instance
;;;1452     * @retval None
;;;1453     */
;;;1454   __STATIC_INLINE void LL_DMA_ClearFlag_GI1(DMA_TypeDef *DMAx)
;;;1455   {
;;;1456     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF1);
;;;1457   }
;;;1458   
;;;1459   /**
;;;1460     * @brief  Clear Channel 2 global interrupt flag.
;;;1461     * @rmtoll IFCR         CGIF2         LL_DMA_ClearFlag_GI2
;;;1462     * @param  DMAx DMAx Instance
;;;1463     * @retval None
;;;1464     */
;;;1465   __STATIC_INLINE void LL_DMA_ClearFlag_GI2(DMA_TypeDef *DMAx)
;;;1466   {
;;;1467     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF2);
;;;1468   }
;;;1469   
;;;1470   /**
;;;1471     * @brief  Clear Channel 3 global interrupt flag.
;;;1472     * @rmtoll IFCR         CGIF3         LL_DMA_ClearFlag_GI3
;;;1473     * @param  DMAx DMAx Instance
;;;1474     * @retval None
;;;1475     */
;;;1476   __STATIC_INLINE void LL_DMA_ClearFlag_GI3(DMA_TypeDef *DMAx)
;;;1477   {
;;;1478     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF3);
;;;1479   }
;;;1480   
;;;1481   /**
;;;1482     * @brief  Clear Channel 4 global interrupt flag.
;;;1483     * @rmtoll IFCR         CGIF4         LL_DMA_ClearFlag_GI4
;;;1484     * @param  DMAx DMAx Instance
;;;1485     * @retval None
;;;1486     */
;;;1487   __STATIC_INLINE void LL_DMA_ClearFlag_GI4(DMA_TypeDef *DMAx)
;;;1488   {
;;;1489     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF4);
;;;1490   }
;;;1491   
;;;1492   /**
;;;1493     * @brief  Clear Channel 5 global interrupt flag.
;;;1494     * @rmtoll IFCR         CGIF5         LL_DMA_ClearFlag_GI5
;;;1495     * @param  DMAx DMAx Instance
;;;1496     * @retval None
;;;1497     */
;;;1498   __STATIC_INLINE void LL_DMA_ClearFlag_GI5(DMA_TypeDef *DMAx)
;;;1499   {
;;;1500     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF5);
;;;1501   }
;;;1502   
;;;1503   /**
;;;1504     * @brief  Clear Channel 6 global interrupt flag.
;;;1505     * @rmtoll IFCR         CGIF6         LL_DMA_ClearFlag_GI6
;;;1506     * @param  DMAx DMAx Instance
;;;1507     * @retval None
;;;1508     */
;;;1509   __STATIC_INLINE void LL_DMA_ClearFlag_GI6(DMA_TypeDef *DMAx)
;;;1510   {
;;;1511     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF6);
;;;1512   }
;;;1513   
;;;1514   /**
;;;1515     * @brief  Clear Channel 7 global interrupt flag.
;;;1516     * @rmtoll IFCR         CGIF7         LL_DMA_ClearFlag_GI7
;;;1517     * @param  DMAx DMAx Instance
;;;1518     * @retval None
;;;1519     */
;;;1520   __STATIC_INLINE void LL_DMA_ClearFlag_GI7(DMA_TypeDef *DMAx)
;;;1521   {
;;;1522     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF7);
;;;1523   }
;;;1524   
;;;1525   /**
;;;1526     * @brief  Clear Channel 1  transfer complete flag.
;;;1527     * @rmtoll IFCR         CTCIF1        LL_DMA_ClearFlag_TC1
;;;1528     * @param  DMAx DMAx Instance
;;;1529     * @retval None
;;;1530     */
;;;1531   __STATIC_INLINE void LL_DMA_ClearFlag_TC1(DMA_TypeDef *DMAx)
;;;1532   {
;;;1533     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF1);
;;;1534   }
;;;1535   
;;;1536   /**
;;;1537     * @brief  Clear Channel 2  transfer complete flag.
;;;1538     * @rmtoll IFCR         CTCIF2        LL_DMA_ClearFlag_TC2
;;;1539     * @param  DMAx DMAx Instance
;;;1540     * @retval None
;;;1541     */
;;;1542   __STATIC_INLINE void LL_DMA_ClearFlag_TC2(DMA_TypeDef *DMAx)
;;;1543   {
;;;1544     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF2);
;;;1545   }
;;;1546   
;;;1547   /**
;;;1548     * @brief  Clear Channel 3  transfer complete flag.
;;;1549     * @rmtoll IFCR         CTCIF3        LL_DMA_ClearFlag_TC3
;;;1550     * @param  DMAx DMAx Instance
;;;1551     * @retval None
;;;1552     */
;;;1553   __STATIC_INLINE void LL_DMA_ClearFlag_TC3(DMA_TypeDef *DMAx)
;;;1554   {
;;;1555     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF3);
;;;1556   }
;;;1557   
;;;1558   /**
;;;1559     * @brief  Clear Channel 4  transfer complete flag.
;;;1560     * @rmtoll IFCR         CTCIF4        LL_DMA_ClearFlag_TC4
;;;1561     * @param  DMAx DMAx Instance
;;;1562     * @retval None
;;;1563     */
;;;1564   __STATIC_INLINE void LL_DMA_ClearFlag_TC4(DMA_TypeDef *DMAx)
;;;1565   {
;;;1566     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF4);
;;;1567   }
;;;1568   
;;;1569   /**
;;;1570     * @brief  Clear Channel 5  transfer complete flag.
;;;1571     * @rmtoll IFCR         CTCIF5        LL_DMA_ClearFlag_TC5
;;;1572     * @param  DMAx DMAx Instance
;;;1573     * @retval None
;;;1574     */
;;;1575   __STATIC_INLINE void LL_DMA_ClearFlag_TC5(DMA_TypeDef *DMAx)
;;;1576   {
;;;1577     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF5);
;;;1578   }
;;;1579   
;;;1580   /**
;;;1581     * @brief  Clear Channel 6  transfer complete flag.
;;;1582     * @rmtoll IFCR         CTCIF6        LL_DMA_ClearFlag_TC6
;;;1583     * @param  DMAx DMAx Instance
;;;1584     * @retval None
;;;1585     */
;;;1586   __STATIC_INLINE void LL_DMA_ClearFlag_TC6(DMA_TypeDef *DMAx)
;;;1587   {
;;;1588     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF6);
;;;1589   }
;;;1590   
;;;1591   /**
;;;1592     * @brief  Clear Channel 7  transfer complete flag.
;;;1593     * @rmtoll IFCR         CTCIF7        LL_DMA_ClearFlag_TC7
;;;1594     * @param  DMAx DMAx Instance
;;;1595     * @retval None
;;;1596     */
;;;1597   __STATIC_INLINE void LL_DMA_ClearFlag_TC7(DMA_TypeDef *DMAx)
;;;1598   {
;;;1599     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTCIF7);
;;;1600   }
;;;1601   
;;;1602   /**
;;;1603     * @brief  Clear Channel 1  half transfer flag.
;;;1604     * @rmtoll IFCR         CHTIF1        LL_DMA_ClearFlag_HT1
;;;1605     * @param  DMAx DMAx Instance
;;;1606     * @retval None
;;;1607     */
;;;1608   __STATIC_INLINE void LL_DMA_ClearFlag_HT1(DMA_TypeDef *DMAx)
;;;1609   {
;;;1610     WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF1);
;;;1611   }
;;;1612   
;;;1613   /**
;;;1614     * @brief  Clear Channel 2  half transfer flag.
;;;1615     * @rmtoll IFCR         CHTIF2        LL_DMA_ClearFlag_HT2
;;;1616     * @param  DMAx DMAx Instance
;;;1617     * @retval None
;;;1618     */
;;;1619   __STATIC_INLINE void LL_DMA_ClearFlag_HT2(DMA_TypeDef *DMAx)
;;;1620   {
;;;1621     WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF2);
;;;1622   }
;;;1623   
;;;1624   /**
;;;1625     * @brief  Clear Channel 3  half transfer flag.
;;;1626     * @rmtoll IFCR         CHTIF3        LL_DMA_ClearFlag_HT3
;;;1627     * @param  DMAx DMAx Instance
;;;1628     * @retval None
;;;1629     */
;;;1630   __STATIC_INLINE void LL_DMA_ClearFlag_HT3(DMA_TypeDef *DMAx)
;;;1631   {
;;;1632     WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF3);
;;;1633   }
;;;1634   
;;;1635   /**
;;;1636     * @brief  Clear Channel 4  half transfer flag.
;;;1637     * @rmtoll IFCR         CHTIF4        LL_DMA_ClearFlag_HT4
;;;1638     * @param  DMAx DMAx Instance
;;;1639     * @retval None
;;;1640     */
;;;1641   __STATIC_INLINE void LL_DMA_ClearFlag_HT4(DMA_TypeDef *DMAx)
;;;1642   {
;;;1643     WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF4);
;;;1644   }
;;;1645   
;;;1646   /**
;;;1647     * @brief  Clear Channel 5  half transfer flag.
;;;1648     * @rmtoll IFCR         CHTIF5        LL_DMA_ClearFlag_HT5
;;;1649     * @param  DMAx DMAx Instance
;;;1650     * @retval None
;;;1651     */
;;;1652   __STATIC_INLINE void LL_DMA_ClearFlag_HT5(DMA_TypeDef *DMAx)
;;;1653   {
;;;1654     WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF5);
;;;1655   }
;;;1656   
;;;1657   /**
;;;1658     * @brief  Clear Channel 6  half transfer flag.
;;;1659     * @rmtoll IFCR         CHTIF6        LL_DMA_ClearFlag_HT6
;;;1660     * @param  DMAx DMAx Instance
;;;1661     * @retval None
;;;1662     */
;;;1663   __STATIC_INLINE void LL_DMA_ClearFlag_HT6(DMA_TypeDef *DMAx)
;;;1664   {
;;;1665     WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF6);
;;;1666   }
;;;1667   
;;;1668   /**
;;;1669     * @brief  Clear Channel 7  half transfer flag.
;;;1670     * @rmtoll IFCR         CHTIF7        LL_DMA_ClearFlag_HT7
;;;1671     * @param  DMAx DMAx Instance
;;;1672     * @retval None
;;;1673     */
;;;1674   __STATIC_INLINE void LL_DMA_ClearFlag_HT7(DMA_TypeDef *DMAx)
;;;1675   {
;;;1676     WRITE_REG(DMAx->IFCR, DMA_IFCR_CHTIF7);
;;;1677   }
;;;1678   
;;;1679   /**
;;;1680     * @brief  Clear Channel 1 transfer error flag.
;;;1681     * @rmtoll IFCR         CTEIF1        LL_DMA_ClearFlag_TE1
;;;1682     * @param  DMAx DMAx Instance
;;;1683     * @retval None
;;;1684     */
;;;1685   __STATIC_INLINE void LL_DMA_ClearFlag_TE1(DMA_TypeDef *DMAx)
;;;1686   {
;;;1687     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF1);
;;;1688   }
;;;1689   
;;;1690   /**
;;;1691     * @brief  Clear Channel 2 transfer error flag.
;;;1692     * @rmtoll IFCR         CTEIF2        LL_DMA_ClearFlag_TE2
;;;1693     * @param  DMAx DMAx Instance
;;;1694     * @retval None
;;;1695     */
;;;1696   __STATIC_INLINE void LL_DMA_ClearFlag_TE2(DMA_TypeDef *DMAx)
;;;1697   {
;;;1698     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF2);
;;;1699   }
;;;1700   
;;;1701   /**
;;;1702     * @brief  Clear Channel 3 transfer error flag.
;;;1703     * @rmtoll IFCR         CTEIF3        LL_DMA_ClearFlag_TE3
;;;1704     * @param  DMAx DMAx Instance
;;;1705     * @retval None
;;;1706     */
;;;1707   __STATIC_INLINE void LL_DMA_ClearFlag_TE3(DMA_TypeDef *DMAx)
;;;1708   {
;;;1709     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF3);
;;;1710   }
;;;1711   
;;;1712   /**
;;;1713     * @brief  Clear Channel 4 transfer error flag.
;;;1714     * @rmtoll IFCR         CTEIF4        LL_DMA_ClearFlag_TE4
;;;1715     * @param  DMAx DMAx Instance
;;;1716     * @retval None
;;;1717     */
;;;1718   __STATIC_INLINE void LL_DMA_ClearFlag_TE4(DMA_TypeDef *DMAx)
;;;1719   {
;;;1720     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF4);
;;;1721   }
;;;1722   
;;;1723   /**
;;;1724     * @brief  Clear Channel 5 transfer error flag.
;;;1725     * @rmtoll IFCR         CTEIF5        LL_DMA_ClearFlag_TE5
;;;1726     * @param  DMAx DMAx Instance
;;;1727     * @retval None
;;;1728     */
;;;1729   __STATIC_INLINE void LL_DMA_ClearFlag_TE5(DMA_TypeDef *DMAx)
;;;1730   {
;;;1731     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF5);
;;;1732   }
;;;1733   
;;;1734   /**
;;;1735     * @brief  Clear Channel 6 transfer error flag.
;;;1736     * @rmtoll IFCR         CTEIF6        LL_DMA_ClearFlag_TE6
;;;1737     * @param  DMAx DMAx Instance
;;;1738     * @retval None
;;;1739     */
;;;1740   __STATIC_INLINE void LL_DMA_ClearFlag_TE6(DMA_TypeDef *DMAx)
;;;1741   {
;;;1742     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF6);
;;;1743   }
;;;1744   
;;;1745   /**
;;;1746     * @brief  Clear Channel 7 transfer error flag.
;;;1747     * @rmtoll IFCR         CTEIF7        LL_DMA_ClearFlag_TE7
;;;1748     * @param  DMAx DMAx Instance
;;;1749     * @retval None
;;;1750     */
;;;1751   __STATIC_INLINE void LL_DMA_ClearFlag_TE7(DMA_TypeDef *DMAx)
;;;1752   {
;;;1753     WRITE_REG(DMAx->IFCR, DMA_IFCR_CTEIF7);
;;;1754   }
;;;1755   
;;;1756   /**
;;;1757     * @}
;;;1758     */
;;;1759   
;;;1760   /** @defgroup DMA_LL_EF_IT_Management IT_Management
;;;1761     * @{
;;;1762     */
;;;1763   
;;;1764   /**
;;;1765     * @brief  Enable Transfer complete interrupt.
;;;1766     * @rmtoll CCR          TCIE          LL_DMA_EnableIT_TC
;;;1767     * @param  DMAx DMAx Instance
;;;1768     * @param  Channel This parameter can be one of the following values:
;;;1769     *         @arg @ref LL_DMA_CHANNEL_1
;;;1770     *         @arg @ref LL_DMA_CHANNEL_2
;;;1771     *         @arg @ref LL_DMA_CHANNEL_3
;;;1772     *         @arg @ref LL_DMA_CHANNEL_4
;;;1773     *         @arg @ref LL_DMA_CHANNEL_5
;;;1774     *         @arg @ref LL_DMA_CHANNEL_6
;;;1775     *         @arg @ref LL_DMA_CHANNEL_7
;;;1776     * @retval None
;;;1777     */
;;;1778   __STATIC_INLINE void LL_DMA_EnableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel)
;;;1779   {
        0x080004d8:    b510        ..      PUSH     {r4,lr}
;;;1780     SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TCIE);
        0x080004da:    1e4a        J.      SUBS     r2,r1,#1
        0x080004dc:    4b04        .K      LDR      r3,[pc,#16] ; [0x80004f0] = 0x8003da4
        0x080004de:    5c9a        .\      LDRB     r2,[r3,r2]
        0x080004e0:    5882        .X      LDR      r2,[r0,r2]
        0x080004e2:    f0420302    B...    ORR      r3,r2,#2
        0x080004e6:    1e4a        J.      SUBS     r2,r1,#1
        0x080004e8:    4c01        .L      LDR      r4,[pc,#4] ; [0x80004f0] = 0x8003da4
        0x080004ea:    5ca2        .\      LDRB     r2,[r4,r2]
        0x080004ec:    5083        .P      STR      r3,[r0,r2]
;;;1781   }
        0x080004ee:    bd10        ..      POP      {r4,pc}
    $d
        0x080004f0:    08003da4    .=..    DCD    134233508
    $t
    i.LL_DMA_EnableIT_TE
    LL_DMA_EnableIT_TE
;;;1782   
;;;1783   /**
;;;1784     * @brief  Enable Half transfer interrupt.
;;;1785     * @rmtoll CCR          HTIE          LL_DMA_EnableIT_HT
;;;1786     * @param  DMAx DMAx Instance
;;;1787     * @param  Channel This parameter can be one of the following values:
;;;1788     *         @arg @ref LL_DMA_CHANNEL_1
;;;1789     *         @arg @ref LL_DMA_CHANNEL_2
;;;1790     *         @arg @ref LL_DMA_CHANNEL_3
;;;1791     *         @arg @ref LL_DMA_CHANNEL_4
;;;1792     *         @arg @ref LL_DMA_CHANNEL_5
;;;1793     *         @arg @ref LL_DMA_CHANNEL_6
;;;1794     *         @arg @ref LL_DMA_CHANNEL_7
;;;1795     * @retval None
;;;1796     */
;;;1797   __STATIC_INLINE void LL_DMA_EnableIT_HT(DMA_TypeDef *DMAx, uint32_t Channel)
;;;1798   {
;;;1799     SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_HTIE);
;;;1800   }
;;;1801   
;;;1802   /**
;;;1803     * @brief  Enable Transfer error interrupt.
;;;1804     * @rmtoll CCR          TEIE          LL_DMA_EnableIT_TE
;;;1805     * @param  DMAx DMAx Instance
;;;1806     * @param  Channel This parameter can be one of the following values:
;;;1807     *         @arg @ref LL_DMA_CHANNEL_1
;;;1808     *         @arg @ref LL_DMA_CHANNEL_2
;;;1809     *         @arg @ref LL_DMA_CHANNEL_3
;;;1810     *         @arg @ref LL_DMA_CHANNEL_4
;;;1811     *         @arg @ref LL_DMA_CHANNEL_5
;;;1812     *         @arg @ref LL_DMA_CHANNEL_6
;;;1813     *         @arg @ref LL_DMA_CHANNEL_7
;;;1814     * @retval None
;;;1815     */
;;;1816   __STATIC_INLINE void LL_DMA_EnableIT_TE(DMA_TypeDef *DMAx, uint32_t Channel)
;;;1817   {
        0x080004f4:    b510        ..      PUSH     {r4,lr}
;;;1818     SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_TEIE);
        0x080004f6:    1e4a        J.      SUBS     r2,r1,#1
        0x080004f8:    4b04        .K      LDR      r3,[pc,#16] ; [0x800050c] = 0x8003da4
        0x080004fa:    5c9a        .\      LDRB     r2,[r3,r2]
        0x080004fc:    5882        .X      LDR      r2,[r0,r2]
        0x080004fe:    f0420308    B...    ORR      r3,r2,#8
        0x08000502:    1e4a        J.      SUBS     r2,r1,#1
        0x08000504:    4c01        .L      LDR      r4,[pc,#4] ; [0x800050c] = 0x8003da4
        0x08000506:    5ca2        .\      LDRB     r2,[r4,r2]
        0x08000508:    5083        .P      STR      r3,[r0,r2]
;;;1819   }
        0x0800050a:    bd10        ..      POP      {r4,pc}
    $d
        0x0800050c:    08003da4    .=..    DCD    134233508
    $t
    i.LL_DMA_SetDataLength
    LL_DMA_SetDataLength
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h (897)
        0x08000510:    b530        0.      PUSH     {r4,r5,lr}
;;;898      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
        0x08000512:    1e4b        K.      SUBS     r3,r1,#1
        0x08000514:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000530] = 0x8003da4
        0x08000516:    5ce3        .\      LDRB     r3,[r4,r3]
        0x08000518:    4403        .D      ADD      r3,r3,r0
        0x0800051a:    685b        [h      LDR      r3,[r3,#4]
        0x0800051c:    f36f030f    o...    BFC      r3,#0,#16
        0x08000520:    4313        .C      ORRS     r3,r3,r2
        0x08000522:    1e4c        L.      SUBS     r4,r1,#1
        0x08000524:    4d02        .M      LDR      r5,[pc,#8] ; [0x8000530] = 0x8003da4
        0x08000526:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x08000528:    4404        .D      ADD      r4,r4,r0
        0x0800052a:    6063        c`      STR      r3,[r4,#4]
;;;899                 DMA_CNDTR_NDT, NbData);
;;;900    }
        0x0800052c:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0800052e:    0000        ..      DCW    0
        0x08000530:    08003da4    .=..    DCD    134233508
    $t
    i.LL_GPIO_Init
    LL_GPIO_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;172    {
        0x08000534:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08000538:    4602        .F      MOV      r2,r0
        0x0800053a:    460b        .F      MOV      r3,r1
;;;173      uint32_t pinmask;
;;;174      uint32_t pinpos;
;;;175      uint32_t currentpin;
;;;176    
;;;177      /* Check the parameters */
;;;178      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;179      assert_param(IS_LL_GPIO_PIN(GPIO_InitStruct->Pin));
;;;180    
;;;181      /* ------------------------- Configure the port pins ---------------- */
;;;182      /* Initialize  pinpos on first pin set */
;;;183    
;;;184      pinmask = ((GPIO_InitStruct->Pin) << GPIO_PIN_MASK_POS) >> GPIO_PIN_NB;
        0x0800053c:    6818        .h      LDR      r0,[r3,#0]
        0x0800053e:    f3c0250f    ...%    UBFX     r5,r0,#8,#16
;;;185      pinpos = POSITION_VAL(pinmask);
        0x08000542:    fa95f0a5    ....    RBIT     r0,r5
        0x08000546:    fab0f480    ....    CLZ      r4,r0
;;;186    
;;;187      /* Configure the port pins */
;;;188      while ((pinmask  >> pinpos) != 0U)
        0x0800054a:    e07c        |.      B        0x8000646 ; LL_GPIO_Init + 274
;;;189      {
;;;190        /* skip if bit is not set */
;;;191        if ((pinmask & (1U << pinpos)) != 0U)
        0x0800054c:    2001        .       MOVS     r0,#1
        0x0800054e:    40a0        .@      LSLS     r0,r0,r4
        0x08000550:    4028        (@      ANDS     r0,r0,r5
        0x08000552:    2800        .(      CMP      r0,#0
        0x08000554:    d076        v.      BEQ      0x8000644 ; LL_GPIO_Init + 272
;;;192        {
;;;193          /* Get current io position */
;;;194          if (pinpos < GPIO_PIN_MASK_POS)
        0x08000556:    2c08        .,      CMP      r4,#8
        0x08000558:    d204        ..      BCS      0x8000564 ; LL_GPIO_Init + 48
;;;195          {
;;;196            currentpin = (0x00000101U << pinpos);
        0x0800055a:    f2401001    @...    MOV      r0,#0x101
        0x0800055e:    fa00f104    ....    LSL      r1,r0,r4
        0x08000562:    e006        ..      B        0x8000572 ; LL_GPIO_Init + 62
;;;197          }
;;;198          else
;;;199          {
;;;200            currentpin = ((0x00010001U << (pinpos - GPIO_PIN_MASK_POS)) | 0x04000000U);
        0x08000564:    f1a40008    ....    SUB      r0,r4,#8
        0x08000568:    f04f1601    O...    MOV      r6,#0x10001
        0x0800056c:    4086        .@      LSLS     r6,r6,r0
        0x0800056e:    f0466180    F..a    ORR      r1,r6,#0x4000000
;;;201          }
;;;202    
;;;203          /* Check Pin Mode and Pin Pull parameters */
;;;204          assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
;;;205          assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));
;;;206    
;;;207          /* Pin Mode configuration */
;;;208          LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
        0x08000572:    6858        Xh      LDR      r0,[r3,#4]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;360      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x08000574:    eb026611    ...f    ADD      r6,r2,r1,LSR #24
;;;361      MODIFY_REG(*pReg, ((GPIO_CRL_CNF0 | GPIO_CRL_MODE0) << (POSITION_VAL(Pin) * 4U)), (Mode << (POSITION_VAL(Pin) * 4U)));
        0x08000578:    fa91fca1    ....    RBIT     r12,r1
        0x0800057c:    fabcfc8c    ....    CLZ      r12,r12
        0x08000580:    ea4f088c    O...    LSL      r8,r12,#2
        0x08000584:    f04f0c0f    O...    MOV      r12,#0xf
        0x08000588:    fa0cfc08    ....    LSL      r12,r12,r8
        0x0800058c:    6837        7h      LDR      r7,[r6,#0]
        0x0800058e:    ea27070c    '...    BIC      r7,r7,r12
        0x08000592:    fa91fca1    ....    RBIT     r12,r1
        0x08000596:    fabcfc8c    ....    CLZ      r12,r12
        0x0800059a:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x0800059e:    fa00fc0c    ....    LSL      r12,r0,r12
        0x080005a2:    ea47070c    G...    ORR      r7,r7,r12
        0x080005a6:    6037        7`      STR      r7,[r6,#0]
;;;362    }
        0x080005a8:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;211          LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
        0x080005aa:    6918        .i      LDR      r0,[r3,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;583      MODIFY_REG(GPIOx->ODR, (Pin >> GPIO_PIN_MASK_POS), Pull << (POSITION_VAL(Pin >> GPIO_PIN_MASK_POS)));
        0x080005ac:    68d6        .h      LDR      r6,[r2,#0xc]
        0x080005ae:    ea262611    &..&    BIC      r6,r6,r1,LSR #8
        0x080005b2:    0a0f        ..      LSRS     r7,r1,#8
        0x080005b4:    fa97f7a7    ....    RBIT     r7,r7
        0x080005b8:    fab7f787    ....    CLZ      r7,r7
        0x080005bc:    fa00f707    ....    LSL      r7,r0,r7
        0x080005c0:    433e        >C      ORRS     r6,r6,r7
        0x080005c2:    60d6        .`      STR      r6,[r2,#0xc]
;;;584    }
        0x080005c4:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;213          if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
        0x080005c6:    6858        Xh      LDR      r0,[r3,#4]
        0x080005c8:    2801        .(      CMP      r0,#1
        0x080005ca:    d002        ..      BEQ      0x80005d2 ; LL_GPIO_Init + 158
        0x080005cc:    6858        Xh      LDR      r0,[r3,#4]
        0x080005ce:    2809        .(      CMP      r0,#9
        0x080005d0:    d138        8.      BNE      0x8000644 ; LL_GPIO_Init + 272
;;;214          {
;;;215            /* Check speed and Output mode parameters */
;;;216            assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));
;;;217            assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));
;;;218    
;;;219            /* Speed mode configuration */
;;;220            LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
        0x080005d2:    6898        .h      LDR      r0,[r3,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;438      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x080005d4:    eb026611    ...f    ADD      r6,r2,r1,LSR #24
;;;439      MODIFY_REG(*pReg, (GPIO_CRL_MODE0 << (POSITION_VAL(Pin) * 4U)),
        0x080005d8:    fa91fca1    ....    RBIT     r12,r1
        0x080005dc:    fabcfc8c    ....    CLZ      r12,r12
        0x080005e0:    ea4f088c    O...    LSL      r8,r12,#2
        0x080005e4:    f04f0c03    O...    MOV      r12,#3
        0x080005e8:    fa0cfc08    ....    LSL      r12,r12,r8
        0x080005ec:    6837        7h      LDR      r7,[r6,#0]
        0x080005ee:    ea27070c    '...    BIC      r7,r7,r12
        0x080005f2:    fa91fca1    ....    RBIT     r12,r1
        0x080005f6:    fabcfc8c    ....    CLZ      r12,r12
        0x080005fa:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x080005fe:    fa00fc0c    ....    LSL      r12,r0,r12
        0x08000602:    ea47070c    G...    ORR      r7,r7,r12
        0x08000606:    6037        7`      STR      r7,[r6,#0]
;;;440                 (Speed << (POSITION_VAL(Pin) * 4U)));
;;;441    }
        0x08000608:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;223            LL_GPIO_SetPinOutputType(GPIOx, currentpin, GPIO_InitStruct->OutputType);
        0x0800060a:    68d8        .h      LDR      r0,[r3,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;512      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x0800060c:    eb026611    ...f    ADD      r6,r2,r1,LSR #24
;;;513      MODIFY_REG(*pReg, (GPIO_CRL_CNF0_0 << (POSITION_VAL(Pin) * 4U)),
        0x08000610:    fa91fca1    ....    RBIT     r12,r1
        0x08000614:    fabcfc8c    ....    CLZ      r12,r12
        0x08000618:    ea4f088c    O...    LSL      r8,r12,#2
        0x0800061c:    f04f0c04    O...    MOV      r12,#4
        0x08000620:    fa0cfc08    ....    LSL      r12,r12,r8
        0x08000624:    6837        7h      LDR      r7,[r6,#0]
        0x08000626:    ea27070c    '...    BIC      r7,r7,r12
        0x0800062a:    fa91fca1    ....    RBIT     r12,r1
        0x0800062e:    fabcfc8c    ....    CLZ      r12,r12
        0x08000632:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x08000636:    fa00fc0c    ....    LSL      r12,r0,r12
        0x0800063a:    ea47070c    G...    ORR      r7,r7,r12
        0x0800063e:    6037        7`      STR      r7,[r6,#0]
;;;514                 (OutputType << (POSITION_VAL(Pin) * 4U)));
;;;515    }
        0x08000640:    bf00        ..      NOP      
        0x08000642:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;226        pinpos++;
        0x08000644:    1c64        d.      ADDS     r4,r4,#1
        0x08000646:    fa25f004    %...    LSR      r0,r5,r4
        0x0800064a:    2800        .(      CMP      r0,#0
        0x0800064c:    f47faf7e    ..~.    BNE      0x800054c ; LL_GPIO_Init + 24
;;;227      }
;;;228      return (SUCCESS);
        0x08000650:    2001        .       MOVS     r0,#1
;;;229    }
        0x08000652:    e8bd81f0    ....    POP      {r4-r8,pc}
    i.LL_GPIO_IsInputPinSet
    LL_GPIO_IsInputPinSet
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;740    {
        0x08000656:    4602        .F      MOV      r2,r0
;;;741      return (READ_BIT(GPIOx->IDR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x08000658:    6890        .h      LDR      r0,[r2,#8]
        0x0800065a:    f3c1230f    ...#    UBFX     r3,r1,#8,#16
        0x0800065e:    4018        .@      ANDS     r0,r0,r3
        0x08000660:    f3c1230f    ...#    UBFX     r3,r1,#8,#16
        0x08000664:    4298        .B      CMP      r0,r3
        0x08000666:    d101        ..      BNE      0x800066c ; LL_GPIO_IsInputPinSet + 22
        0x08000668:    2001        .       MOVS     r0,#1
        0x0800066a:    4770        pG      BX       lr
        0x0800066c:    2000        .       MOVS     r0,#0
        0x0800066e:    e7fc        ..      B        0x800066a ; LL_GPIO_IsInputPinSet + 20
    i.LL_GPIO_ResetOutputPin
    LL_GPIO_ResetOutputPin
;;;742    }
;;;743    
;;;744    /**
;;;745      * @brief  Write output data register for the port.
;;;746      * @rmtoll ODR          ODy           LL_GPIO_WriteOutputPort
;;;747      * @param  GPIOx GPIO Port
;;;748      * @param  PortValue Level value for each pin of the port
;;;749      * @retval None
;;;750      */
;;;751    __STATIC_INLINE void LL_GPIO_WriteOutputPort(GPIO_TypeDef *GPIOx, uint32_t PortValue)
;;;752    {
;;;753      WRITE_REG(GPIOx->ODR, PortValue);
;;;754    }
;;;755    
;;;756    /**
;;;757      * @brief  Return full output data register value for a dedicated port.
;;;758      * @rmtoll ODR          ODy           LL_GPIO_ReadOutputPort
;;;759      * @param  GPIOx GPIO Port
;;;760      * @retval Output data register value of port
;;;761      */
;;;762    __STATIC_INLINE uint32_t LL_GPIO_ReadOutputPort(GPIO_TypeDef *GPIOx)
;;;763    {
;;;764      return (uint32_t)(READ_REG(GPIOx->ODR));
;;;765    }
;;;766    
;;;767    /**
;;;768      * @brief  Return if input data level for several pins of dedicated port is high or low.
;;;769      * @rmtoll ODR          ODy           LL_GPIO_IsOutputPinSet
;;;770      * @param  GPIOx GPIO Port
;;;771      * @param  PinMask This parameter can be a combination of the following values:
;;;772      *         @arg @ref LL_GPIO_PIN_0
;;;773      *         @arg @ref LL_GPIO_PIN_1
;;;774      *         @arg @ref LL_GPIO_PIN_2
;;;775      *         @arg @ref LL_GPIO_PIN_3
;;;776      *         @arg @ref LL_GPIO_PIN_4
;;;777      *         @arg @ref LL_GPIO_PIN_5
;;;778      *         @arg @ref LL_GPIO_PIN_6
;;;779      *         @arg @ref LL_GPIO_PIN_7
;;;780      *         @arg @ref LL_GPIO_PIN_8
;;;781      *         @arg @ref LL_GPIO_PIN_9
;;;782      *         @arg @ref LL_GPIO_PIN_10
;;;783      *         @arg @ref LL_GPIO_PIN_11
;;;784      *         @arg @ref LL_GPIO_PIN_12
;;;785      *         @arg @ref LL_GPIO_PIN_13
;;;786      *         @arg @ref LL_GPIO_PIN_14
;;;787      *         @arg @ref LL_GPIO_PIN_15
;;;788      *         @arg @ref LL_GPIO_PIN_ALL
;;;789      * @retval State of bit (1 or 0).
;;;790      */
;;;791    __STATIC_INLINE uint32_t LL_GPIO_IsOutputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask)
;;;792    {
;;;793      return (READ_BIT(GPIOx->ODR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
;;;794    }
;;;795    
;;;796    /**
;;;797      * @brief  Set several pins to high level on dedicated gpio port.
;;;798      * @rmtoll BSRR         BSy           LL_GPIO_SetOutputPin
;;;799      * @param  GPIOx GPIO Port
;;;800      * @param  PinMask This parameter can be a combination of the following values:
;;;801      *         @arg @ref LL_GPIO_PIN_0
;;;802      *         @arg @ref LL_GPIO_PIN_1
;;;803      *         @arg @ref LL_GPIO_PIN_2
;;;804      *         @arg @ref LL_GPIO_PIN_3
;;;805      *         @arg @ref LL_GPIO_PIN_4
;;;806      *         @arg @ref LL_GPIO_PIN_5
;;;807      *         @arg @ref LL_GPIO_PIN_6
;;;808      *         @arg @ref LL_GPIO_PIN_7
;;;809      *         @arg @ref LL_GPIO_PIN_8
;;;810      *         @arg @ref LL_GPIO_PIN_9
;;;811      *         @arg @ref LL_GPIO_PIN_10
;;;812      *         @arg @ref LL_GPIO_PIN_11
;;;813      *         @arg @ref LL_GPIO_PIN_12
;;;814      *         @arg @ref LL_GPIO_PIN_13
;;;815      *         @arg @ref LL_GPIO_PIN_14
;;;816      *         @arg @ref LL_GPIO_PIN_15
;;;817      *         @arg @ref LL_GPIO_PIN_ALL
;;;818      * @retval None
;;;819      */
;;;820    __STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
;;;821    {
;;;822      WRITE_REG(GPIOx->BSRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
;;;823    }
;;;824    
;;;825    /**
;;;826      * @brief  Set several pins to low level on dedicated gpio port.
;;;827      * @rmtoll BRR          BRy           LL_GPIO_ResetOutputPin
;;;828      * @param  GPIOx GPIO Port
;;;829      * @param  PinMask This parameter can be a combination of the following values:
;;;830      *         @arg @ref LL_GPIO_PIN_0
;;;831      *         @arg @ref LL_GPIO_PIN_1
;;;832      *         @arg @ref LL_GPIO_PIN_2
;;;833      *         @arg @ref LL_GPIO_PIN_3
;;;834      *         @arg @ref LL_GPIO_PIN_4
;;;835      *         @arg @ref LL_GPIO_PIN_5
;;;836      *         @arg @ref LL_GPIO_PIN_6
;;;837      *         @arg @ref LL_GPIO_PIN_7
;;;838      *         @arg @ref LL_GPIO_PIN_8
;;;839      *         @arg @ref LL_GPIO_PIN_9
;;;840      *         @arg @ref LL_GPIO_PIN_10
;;;841      *         @arg @ref LL_GPIO_PIN_11
;;;842      *         @arg @ref LL_GPIO_PIN_12
;;;843      *         @arg @ref LL_GPIO_PIN_13
;;;844      *         @arg @ref LL_GPIO_PIN_14
;;;845      *         @arg @ref LL_GPIO_PIN_15
;;;846      *         @arg @ref LL_GPIO_PIN_ALL
;;;847      * @retval None
;;;848      */
;;;849    __STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
;;;850    {
;;;851      WRITE_REG(GPIOx->BRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
        0x08000670:    f3c1220f    ..."    UBFX     r2,r1,#8,#16
        0x08000674:    6142        Ba      STR      r2,[r0,#0x14]
;;;852    }
        0x08000676:    4770        pG      BX       lr
    i.LL_I2C_AcknowledgeNextData
    LL_I2C_AcknowledgeNextData
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1572     MODIFY_REG(I2Cx->CR1, I2C_CR1_ACK, TypeAcknowledge);
        0x08000678:    6802        .h      LDR      r2,[r0,#0]
        0x0800067a:    f4226280    "..b    BIC      r2,r2,#0x400
        0x0800067e:    430a        .C      ORRS     r2,r2,r1
        0x08000680:    6002        .`      STR      r2,[r0,#0]
        0x08000682:    4770        pG      BX       lr
    i.LL_I2C_ConfigSpeed
    LL_I2C_ConfigSpeed
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h (747)
        0x08000684:    b5f0        ..      PUSH     {r4-r7,lr}
;;;748      register uint32_t freqrange = 0x0U;
        0x08000686:    2400        .$      MOVS     r4,#0
;;;749      register uint32_t clockconfig = 0x0U;
        0x08000688:    2500        .%      MOVS     r5,#0
;;;750    
;;;751      /* Compute frequency range */
;;;752      freqrange = __LL_I2C_FREQ_HZ_TO_MHZ(PeriphClock);
        0x0800068a:    4e2b        +N      LDR      r6,[pc,#172] ; [0x8000738] = 0xf4240
        0x0800068c:    fbb1f4f6    ....    UDIV     r4,r1,r6
;;;753    
;;;754      /* Configure I2Cx: Frequency range register */
;;;755      MODIFY_REG(I2Cx->CR2, I2C_CR2_FREQ, freqrange);
        0x08000690:    6846        Fh      LDR      r6,[r0,#4]
        0x08000692:    f026063f    &.?.    BIC      r6,r6,#0x3f
        0x08000696:    4326        &C      ORRS     r6,r6,r4
        0x08000698:    6046        F`      STR      r6,[r0,#4]
;;;756    
;;;757      /* Configure I2Cx: Rise Time register */
;;;758      MODIFY_REG(I2Cx->TRISE, I2C_TRISE_TRISE, __LL_I2C_RISE_TIME(freqrange, ClockSpeed));
        0x0800069a:    4e28        (N      LDR      r6,[pc,#160] ; [0x800073c] = 0x186a0
        0x0800069c:    42b2        .B      CMP      r2,r6
        0x0800069e:    d801        ..      BHI      0x80006a4 ; LL_I2C_ConfigSpeed + 32
        0x080006a0:    1c66        f.      ADDS     r6,r4,#1
        0x080006a2:    e007        ..      B        0x80006b4 ; LL_I2C_ConfigSpeed + 48
        0x080006a4:    f44f7696    O..v    MOV      r6,#0x12c
        0x080006a8:    4366        fC      MULS     r6,r4,r6
        0x080006aa:    f44f777a    O.zw    MOV      r7,#0x3e8
        0x080006ae:    fbb6f6f7    ....    UDIV     r6,r6,r7
        0x080006b2:    1c76        v.      ADDS     r6,r6,#1
        0x080006b4:    6a07        .j      LDR      r7,[r0,#0x20]
        0x080006b6:    f027073f    '.?.    BIC      r7,r7,#0x3f
        0x080006ba:    433e        >C      ORRS     r6,r6,r7
        0x080006bc:    6206        .b      STR      r6,[r0,#0x20]
;;;759    
;;;760      /* Configure Speed mode, Duty Cycle and Clock control register value */
;;;761      if (ClockSpeed > LL_I2C_MAX_SPEED_STANDARD)
        0x080006be:    4e1f        .N      LDR      r6,[pc,#124] ; [0x800073c] = 0x186a0
        0x080006c0:    42b2        .B      CMP      r2,r6
        0x080006c2:    d924        $.      BLS      0x800070e ; LL_I2C_ConfigSpeed + 138
;;;762      {
;;;763        /* Set Speed mode at fast and duty cycle for Clock Speed request in fast clock range */
;;;764        clockconfig = LL_I2C_CLOCK_SPEED_FAST_MODE                                          | \
        0x080006c4:    b96b        k.      CBNZ     r3,0x80006e2 ; LL_I2C_ConfigSpeed + 94
;;;765                      __LL_I2C_SPEED_FAST_TO_CCR(PeriphClock, ClockSpeed, DutyCycle)        | \
        0x080006c6:    eb020642    ..B.    ADD      r6,r2,r2,LSL #1
        0x080006ca:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x080006ce:    f3c6060b    ....    UBFX     r6,r6,#0,#12
        0x080006d2:    b90e        ..      CBNZ     r6,0x80006d8 ; LL_I2C_ConfigSpeed + 84
        0x080006d4:    2601        .&      MOVS     r6,#1
        0x080006d6:    e015        ..      B        0x8000704 ; LL_I2C_ConfigSpeed + 128
        0x080006d8:    eb020642    ..B.    ADD      r6,r2,r2,LSL #1
        0x080006dc:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x080006e0:    e010        ..      B        0x8000704 ; LL_I2C_ConfigSpeed + 128
        0x080006e2:    eb0206c2    ....    ADD      r6,r2,r2,LSL #3
        0x080006e6:    eb061602    ....    ADD      r6,r6,r2,LSL #4
        0x080006ea:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x080006ee:    f3c6060b    ....    UBFX     r6,r6,#0,#12
        0x080006f2:    b90e        ..      CBNZ     r6,0x80006f8 ; LL_I2C_ConfigSpeed + 116
        0x080006f4:    2601        .&      MOVS     r6,#1
        0x080006f6:    e005        ..      B        0x8000704 ; LL_I2C_ConfigSpeed + 128
        0x080006f8:    eb0206c2    ....    ADD      r6,r2,r2,LSL #3
        0x080006fc:    eb061602    ....    ADD      r6,r6,r2,LSL #4
        0x08000700:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000704:    f4464600    F..F    ORR      r6,r6,#0x8000
        0x08000708:    ea460503    F...    ORR      r5,r6,r3
        0x0800070c:    e00c        ..      B        0x8000728 ; LL_I2C_ConfigSpeed + 164
;;;766                      DutyCycle;
;;;767      }
;;;768      else
;;;769      {
;;;770        /* Set Speed mode at standard for Clock Speed request in standard clock range */
;;;771        clockconfig = LL_I2C_CLOCK_SPEED_STANDARD_MODE                                      | \
        0x0800070e:    0056        V.      LSLS     r6,r2,#1
        0x08000710:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000714:    f3c6060b    ....    UBFX     r6,r6,#0,#12
        0x08000718:    2e04        ..      CMP      r6,#4
        0x0800071a:    d201        ..      BCS      0x8000720 ; LL_I2C_ConfigSpeed + 156
;;;772                      __LL_I2C_SPEED_STANDARD_TO_CCR(PeriphClock, ClockSpeed);
        0x0800071c:    2604        .&      MOVS     r6,#4
        0x0800071e:    e002        ..      B        0x8000726 ; LL_I2C_ConfigSpeed + 162
        0x08000720:    0056        V.      LSLS     r6,r2,#1
        0x08000722:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000726:    4635        5F      MOV      r5,r6
;;;773      }
;;;774    
;;;775      /* Configure I2Cx: Clock control register */
;;;776      MODIFY_REG(I2Cx->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), clockconfig);
        0x08000728:    69c6        .i      LDR      r6,[r0,#0x1c]
        0x0800072a:    f64c77ff    L..w    MOV      r7,#0xcfff
        0x0800072e:    43be        .C      BICS     r6,r6,r7
        0x08000730:    432e        .C      ORRS     r6,r6,r5
        0x08000732:    61c6        .a      STR      r6,[r0,#0x1c]
;;;777    }
        0x08000734:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000736:    0000        ..      DCW    0
        0x08000738:    000f4240    @B..    DCD    1000000
        0x0800073c:    000186a0    ....    DCD    100000
    $t
    i.LL_I2C_GenerateStartCondition
    LL_I2C_GenerateStartCondition
;;;778    
;;;779    /**
;;;780      * @brief  Configure peripheral mode.
;;;781      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;782      *         SMBus feature is supported by the I2Cx Instance.
;;;783      * @rmtoll CR1          SMBUS         LL_I2C_SetMode\n
;;;784      *         CR1          SMBTYPE       LL_I2C_SetMode\n
;;;785      *         CR1          ENARP         LL_I2C_SetMode
;;;786      * @param  I2Cx I2C Instance.
;;;787      * @param  PeripheralMode This parameter can be one of the following values:
;;;788      *         @arg @ref LL_I2C_MODE_I2C
;;;789      *         @arg @ref LL_I2C_MODE_SMBUS_HOST
;;;790      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE
;;;791      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE_ARP
;;;792      * @retval None
;;;793      */
;;;794    __STATIC_INLINE void LL_I2C_SetMode(I2C_TypeDef *I2Cx, uint32_t PeripheralMode)
;;;795    {
;;;796      MODIFY_REG(I2Cx->CR1, I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_ENARP, PeripheralMode);
;;;797    }
;;;798    
;;;799    /**
;;;800      * @brief  Get peripheral mode.
;;;801      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;802      *         SMBus feature is supported by the I2Cx Instance.
;;;803      * @rmtoll CR1          SMBUS         LL_I2C_GetMode\n
;;;804      *         CR1          SMBTYPE       LL_I2C_GetMode\n
;;;805      *         CR1          ENARP         LL_I2C_GetMode
;;;806      * @param  I2Cx I2C Instance.
;;;807      * @retval Returned value can be one of the following values:
;;;808      *         @arg @ref LL_I2C_MODE_I2C
;;;809      *         @arg @ref LL_I2C_MODE_SMBUS_HOST
;;;810      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE
;;;811      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE_ARP
;;;812      */
;;;813    __STATIC_INLINE uint32_t LL_I2C_GetMode(I2C_TypeDef *I2Cx)
;;;814    {
;;;815      return (uint32_t)(READ_BIT(I2Cx->CR1, I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_ENARP));
;;;816    }
;;;817    
;;;818    /**
;;;819      * @brief  Enable SMBus alert (Host or Device mode)
;;;820      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;821      *         SMBus feature is supported by the I2Cx Instance.
;;;822      * @note   SMBus Device mode:
;;;823      *         - SMBus Alert pin is drived low and
;;;824      *           Alert Response Address Header acknowledge is enabled.
;;;825      *         SMBus Host mode:
;;;826      *         - SMBus Alert pin management is supported.
;;;827      * @rmtoll CR1          ALERT         LL_I2C_EnableSMBusAlert
;;;828      * @param  I2Cx I2C Instance.
;;;829      * @retval None
;;;830      */
;;;831    __STATIC_INLINE void LL_I2C_EnableSMBusAlert(I2C_TypeDef *I2Cx)
;;;832    {
;;;833      SET_BIT(I2Cx->CR1, I2C_CR1_ALERT);
;;;834    }
;;;835    
;;;836    /**
;;;837      * @brief  Disable SMBus alert (Host or Device mode)
;;;838      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;839      *         SMBus feature is supported by the I2Cx Instance.
;;;840      * @note   SMBus Device mode:
;;;841      *         - SMBus Alert pin is not drived (can be used as a standard GPIO) and
;;;842      *           Alert Response Address Header acknowledge is disabled.
;;;843      *         SMBus Host mode:
;;;844      *         - SMBus Alert pin management is not supported.
;;;845      * @rmtoll CR1          ALERT         LL_I2C_DisableSMBusAlert
;;;846      * @param  I2Cx I2C Instance.
;;;847      * @retval None
;;;848      */
;;;849    __STATIC_INLINE void LL_I2C_DisableSMBusAlert(I2C_TypeDef *I2Cx)
;;;850    {
;;;851      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ALERT);
;;;852    }
;;;853    
;;;854    /**
;;;855      * @brief  Check if SMBus alert (Host or Device mode) is enabled or disabled.
;;;856      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;857      *         SMBus feature is supported by the I2Cx Instance.
;;;858      * @rmtoll CR1          ALERT         LL_I2C_IsEnabledSMBusAlert
;;;859      * @param  I2Cx I2C Instance.
;;;860      * @retval State of bit (1 or 0).
;;;861      */
;;;862    __STATIC_INLINE uint32_t LL_I2C_IsEnabledSMBusAlert(I2C_TypeDef *I2Cx)
;;;863    {
;;;864      return (READ_BIT(I2Cx->CR1, I2C_CR1_ALERT) == (I2C_CR1_ALERT));
;;;865    }
;;;866    
;;;867    /**
;;;868      * @brief  Enable SMBus Packet Error Calculation (PEC).
;;;869      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;870      *         SMBus feature is supported by the I2Cx Instance.
;;;871      * @rmtoll CR1          ENPEC         LL_I2C_EnableSMBusPEC
;;;872      * @param  I2Cx I2C Instance.
;;;873      * @retval None
;;;874      */
;;;875    __STATIC_INLINE void LL_I2C_EnableSMBusPEC(I2C_TypeDef *I2Cx)
;;;876    {
;;;877      SET_BIT(I2Cx->CR1, I2C_CR1_ENPEC);
;;;878    }
;;;879    
;;;880    /**
;;;881      * @brief  Disable SMBus Packet Error Calculation (PEC).
;;;882      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;883      *         SMBus feature is supported by the I2Cx Instance.
;;;884      * @rmtoll CR1          ENPEC         LL_I2C_DisableSMBusPEC
;;;885      * @param  I2Cx I2C Instance.
;;;886      * @retval None
;;;887      */
;;;888    __STATIC_INLINE void LL_I2C_DisableSMBusPEC(I2C_TypeDef *I2Cx)
;;;889    {
;;;890      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ENPEC);
;;;891    }
;;;892    
;;;893    /**
;;;894      * @brief  Check if SMBus Packet Error Calculation (PEC) is enabled or disabled.
;;;895      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;896      *         SMBus feature is supported by the I2Cx Instance.
;;;897      * @rmtoll CR1          ENPEC         LL_I2C_IsEnabledSMBusPEC
;;;898      * @param  I2Cx I2C Instance.
;;;899      * @retval State of bit (1 or 0).
;;;900      */
;;;901    __STATIC_INLINE uint32_t LL_I2C_IsEnabledSMBusPEC(I2C_TypeDef *I2Cx)
;;;902    {
;;;903      return (READ_BIT(I2Cx->CR1, I2C_CR1_ENPEC) == (I2C_CR1_ENPEC));
;;;904    }
;;;905    
;;;906    /**
;;;907      * @}
;;;908      */
;;;909    
;;;910    /** @defgroup I2C_LL_EF_IT_Management IT_Management
;;;911      * @{
;;;912      */
;;;913    
;;;914    /**
;;;915      * @brief  Enable TXE interrupt.
;;;916      * @rmtoll CR2          ITEVTEN       LL_I2C_EnableIT_TX\n
;;;917      *         CR2          ITBUFEN       LL_I2C_EnableIT_TX
;;;918      * @param  I2Cx I2C Instance.
;;;919      * @retval None
;;;920      */
;;;921    __STATIC_INLINE void LL_I2C_EnableIT_TX(I2C_TypeDef *I2Cx)
;;;922    {
;;;923      SET_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;924    }
;;;925    
;;;926    /**
;;;927      * @brief  Disable TXE interrupt.
;;;928      * @rmtoll CR2          ITEVTEN       LL_I2C_DisableIT_TX\n
;;;929      *         CR2          ITBUFEN       LL_I2C_DisableIT_TX
;;;930      * @param  I2Cx I2C Instance.
;;;931      * @retval None
;;;932      */
;;;933    __STATIC_INLINE void LL_I2C_DisableIT_TX(I2C_TypeDef *I2Cx)
;;;934    {
;;;935      CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;936    }
;;;937    
;;;938    /**
;;;939      * @brief  Check if the TXE Interrupt is enabled or disabled.
;;;940      * @rmtoll CR2          ITEVTEN       LL_I2C_IsEnabledIT_TX\n
;;;941      *         CR2          ITBUFEN       LL_I2C_IsEnabledIT_TX
;;;942      * @param  I2Cx I2C Instance.
;;;943      * @retval State of bit (1 or 0).
;;;944      */
;;;945    __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_TX(I2C_TypeDef *I2Cx)
;;;946    {
;;;947      return (READ_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN) == (I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN));
;;;948    }
;;;949    
;;;950    /**
;;;951      * @brief  Enable RXNE interrupt.
;;;952      * @rmtoll CR2          ITEVTEN       LL_I2C_EnableIT_RX\n
;;;953      *         CR2          ITBUFEN       LL_I2C_EnableIT_RX
;;;954      * @param  I2Cx I2C Instance.
;;;955      * @retval None
;;;956      */
;;;957    __STATIC_INLINE void LL_I2C_EnableIT_RX(I2C_TypeDef *I2Cx)
;;;958    {
;;;959      SET_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;960    }
;;;961    
;;;962    /**
;;;963      * @brief  Disable RXNE interrupt.
;;;964      * @rmtoll CR2          ITEVTEN       LL_I2C_DisableIT_RX\n
;;;965      *         CR2          ITBUFEN       LL_I2C_DisableIT_RX
;;;966      * @param  I2Cx I2C Instance.
;;;967      * @retval None
;;;968      */
;;;969    __STATIC_INLINE void LL_I2C_DisableIT_RX(I2C_TypeDef *I2Cx)
;;;970    {
;;;971      CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;972    }
;;;973    
;;;974    /**
;;;975      * @brief  Check if the RXNE Interrupt is enabled or disabled.
;;;976      * @rmtoll CR2          ITEVTEN       LL_I2C_IsEnabledIT_RX\n
;;;977      *         CR2          ITBUFEN       LL_I2C_IsEnabledIT_RX
;;;978      * @param  I2Cx I2C Instance.
;;;979      * @retval State of bit (1 or 0).
;;;980      */
;;;981    __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_RX(I2C_TypeDef *I2Cx)
;;;982    {
;;;983      return (READ_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN) == (I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN));
;;;984    }
;;;985    
;;;986    /**
;;;987      * @brief  Enable Events interrupts.
;;;988      * @note   Any of these events will generate interrupt :
;;;989      *         Start Bit (SB)
;;;990      *         Address sent, Address matched (ADDR)
;;;991      *         10-bit header sent (ADD10)
;;;992      *         Stop detection  (STOPF)
;;;993      *         Byte transfer finished (BTF)
;;;994      *
;;;995      * @note   Any of these events will generate interrupt if Buffer interrupts are enabled too(using unitary function @ref LL_I2C_EnableIT_BUF()) :
;;;996      *         Receive buffer not empty (RXNE)
;;;997      *         Transmit buffer empty (TXE)
;;;998      * @rmtoll CR2          ITEVTEN       LL_I2C_EnableIT_EVT
;;;999      * @param  I2Cx I2C Instance.
;;;1000     * @retval None
;;;1001     */
;;;1002   __STATIC_INLINE void LL_I2C_EnableIT_EVT(I2C_TypeDef *I2Cx)
;;;1003   {
;;;1004     SET_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN);
;;;1005   }
;;;1006   
;;;1007   /**
;;;1008     * @brief  Disable Events interrupts.
;;;1009     * @note   Any of these events will generate interrupt :
;;;1010     *         Start Bit (SB)
;;;1011     *         Address sent, Address matched (ADDR)
;;;1012     *         10-bit header sent (ADD10)
;;;1013     *         Stop detection  (STOPF)
;;;1014     *         Byte transfer finished (BTF)
;;;1015     *         Receive buffer not empty (RXNE)
;;;1016     *         Transmit buffer empty (TXE)
;;;1017     * @rmtoll CR2          ITEVTEN       LL_I2C_DisableIT_EVT
;;;1018     * @param  I2Cx I2C Instance.
;;;1019     * @retval None
;;;1020     */
;;;1021   __STATIC_INLINE void LL_I2C_DisableIT_EVT(I2C_TypeDef *I2Cx)
;;;1022   {
;;;1023     CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN);
;;;1024   }
;;;1025   
;;;1026   /**
;;;1027     * @brief  Check if Events interrupts are enabled or disabled.
;;;1028     * @rmtoll CR2          ITEVTEN       LL_I2C_IsEnabledIT_EVT
;;;1029     * @param  I2Cx I2C Instance.
;;;1030     * @retval State of bit (1 or 0).
;;;1031     */
;;;1032   __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_EVT(I2C_TypeDef *I2Cx)
;;;1033   {
;;;1034     return (READ_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN) == (I2C_CR2_ITEVTEN));
;;;1035   }
;;;1036   
;;;1037   /**
;;;1038     * @brief  Enable Buffer interrupts.
;;;1039     * @note   Any of these Buffer events will generate interrupt if Events interrupts are enabled too(using unitary function @ref LL_I2C_EnableIT_EVT()) :
;;;1040     *         Receive buffer not empty (RXNE)
;;;1041     *         Transmit buffer empty (TXE)
;;;1042     * @rmtoll CR2          ITBUFEN       LL_I2C_EnableIT_BUF
;;;1043     * @param  I2Cx I2C Instance.
;;;1044     * @retval None
;;;1045     */
;;;1046   __STATIC_INLINE void LL_I2C_EnableIT_BUF(I2C_TypeDef *I2Cx)
;;;1047   {
;;;1048     SET_BIT(I2Cx->CR2, I2C_CR2_ITBUFEN);
;;;1049   }
;;;1050   
;;;1051   /**
;;;1052     * @brief  Disable Buffer interrupts.
;;;1053     * @note   Any of these Buffer events will generate interrupt :
;;;1054     *         Receive buffer not empty (RXNE)
;;;1055     *         Transmit buffer empty (TXE)
;;;1056     * @rmtoll CR2          ITBUFEN       LL_I2C_DisableIT_BUF
;;;1057     * @param  I2Cx I2C Instance.
;;;1058     * @retval None
;;;1059     */
;;;1060   __STATIC_INLINE void LL_I2C_DisableIT_BUF(I2C_TypeDef *I2Cx)
;;;1061   {
;;;1062     CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITBUFEN);
;;;1063   }
;;;1064   
;;;1065   /**
;;;1066     * @brief  Check if Buffer interrupts are enabled or disabled.
;;;1067     * @rmtoll CR2          ITBUFEN       LL_I2C_IsEnabledIT_BUF
;;;1068     * @param  I2Cx I2C Instance.
;;;1069     * @retval State of bit (1 or 0).
;;;1070     */
;;;1071   __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_BUF(I2C_TypeDef *I2Cx)
;;;1072   {
;;;1073     return (READ_BIT(I2Cx->CR2, I2C_CR2_ITBUFEN) == (I2C_CR2_ITBUFEN));
;;;1074   }
;;;1075   
;;;1076   /**
;;;1077     * @brief  Enable Error interrupts.
;;;1078     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1079     *         SMBus feature is supported by the I2Cx Instance.
;;;1080     * @note   Any of these errors will generate interrupt :
;;;1081     *         Bus Error detection (BERR)
;;;1082     *         Arbitration Loss (ARLO)
;;;1083     *         Acknowledge Failure(AF)
;;;1084     *         Overrun/Underrun (OVR)
;;;1085     *         SMBus Timeout detection (TIMEOUT)
;;;1086     *         SMBus PEC error detection (PECERR)
;;;1087     *         SMBus Alert pin event detection (SMBALERT)
;;;1088     * @rmtoll CR2          ITERREN       LL_I2C_EnableIT_ERR
;;;1089     * @param  I2Cx I2C Instance.
;;;1090     * @retval None
;;;1091     */
;;;1092   __STATIC_INLINE void LL_I2C_EnableIT_ERR(I2C_TypeDef *I2Cx)
;;;1093   {
;;;1094     SET_BIT(I2Cx->CR2, I2C_CR2_ITERREN);
;;;1095   }
;;;1096   
;;;1097   /**
;;;1098     * @brief  Disable Error interrupts.
;;;1099     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1100     *         SMBus feature is supported by the I2Cx Instance.
;;;1101     * @note   Any of these errors will generate interrupt :
;;;1102     *         Bus Error detection (BERR)
;;;1103     *         Arbitration Loss (ARLO)
;;;1104     *         Acknowledge Failure(AF)
;;;1105     *         Overrun/Underrun (OVR)
;;;1106     *         SMBus Timeout detection (TIMEOUT)
;;;1107     *         SMBus PEC error detection (PECERR)
;;;1108     *         SMBus Alert pin event detection (SMBALERT)
;;;1109     * @rmtoll CR2          ITERREN       LL_I2C_DisableIT_ERR
;;;1110     * @param  I2Cx I2C Instance.
;;;1111     * @retval None
;;;1112     */
;;;1113   __STATIC_INLINE void LL_I2C_DisableIT_ERR(I2C_TypeDef *I2Cx)
;;;1114   {
;;;1115     CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITERREN);
;;;1116   }
;;;1117   
;;;1118   /**
;;;1119     * @brief  Check if Error interrupts are enabled or disabled.
;;;1120     * @rmtoll CR2          ITERREN       LL_I2C_IsEnabledIT_ERR
;;;1121     * @param  I2Cx I2C Instance.
;;;1122     * @retval State of bit (1 or 0).
;;;1123     */
;;;1124   __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_ERR(I2C_TypeDef *I2Cx)
;;;1125   {
;;;1126     return (READ_BIT(I2Cx->CR2, I2C_CR2_ITERREN) == (I2C_CR2_ITERREN));
;;;1127   }
;;;1128   
;;;1129   /**
;;;1130     * @}
;;;1131     */
;;;1132   
;;;1133   /** @defgroup I2C_LL_EF_FLAG_management FLAG_management
;;;1134     * @{
;;;1135     */
;;;1136   
;;;1137   /**
;;;1138     * @brief  Indicate the status of Transmit data register empty flag.
;;;1139     * @note   RESET: When next data is written in Transmit data register.
;;;1140     *         SET: When Transmit data register is empty.
;;;1141     * @rmtoll SR1          TXE           LL_I2C_IsActiveFlag_TXE
;;;1142     * @param  I2Cx I2C Instance.
;;;1143     * @retval State of bit (1 or 0).
;;;1144     */
;;;1145   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_TXE(I2C_TypeDef *I2Cx)
;;;1146   {
;;;1147     return (READ_BIT(I2Cx->SR1, I2C_SR1_TXE) == (I2C_SR1_TXE));
;;;1148   }
;;;1149   
;;;1150   /**
;;;1151     * @brief  Indicate the status of Byte Transfer Finished flag.
;;;1152     *         RESET: When Data byte transfer not done.
;;;1153     *         SET: When Data byte transfer succeeded.
;;;1154     * @rmtoll SR1          BTF           LL_I2C_IsActiveFlag_BTF
;;;1155     * @param  I2Cx I2C Instance.
;;;1156     * @retval State of bit (1 or 0).
;;;1157     */
;;;1158   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BTF(I2C_TypeDef *I2Cx)
;;;1159   {
;;;1160     return (READ_BIT(I2Cx->SR1, I2C_SR1_BTF) == (I2C_SR1_BTF));
;;;1161   }
;;;1162   
;;;1163   /**
;;;1164     * @brief  Indicate the status of Receive data register not empty flag.
;;;1165     * @note   RESET: When Receive data register is read.
;;;1166     *         SET: When the received data is copied in Receive data register.
;;;1167     * @rmtoll SR1          RXNE          LL_I2C_IsActiveFlag_RXNE
;;;1168     * @param  I2Cx I2C Instance.
;;;1169     * @retval State of bit (1 or 0).
;;;1170     */
;;;1171   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_RXNE(I2C_TypeDef *I2Cx)
;;;1172   {
;;;1173     return (READ_BIT(I2Cx->SR1, I2C_SR1_RXNE) == (I2C_SR1_RXNE));
;;;1174   }
;;;1175   
;;;1176   /**
;;;1177     * @brief  Indicate the status of Start Bit (master mode).
;;;1178     * @note   RESET: When No Start condition.
;;;1179     *         SET: When Start condition is generated.
;;;1180     * @rmtoll SR1          SB            LL_I2C_IsActiveFlag_SB
;;;1181     * @param  I2Cx I2C Instance.
;;;1182     * @retval State of bit (1 or 0).
;;;1183     */
;;;1184   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_SB(I2C_TypeDef *I2Cx)
;;;1185   {
;;;1186     return (READ_BIT(I2Cx->SR1, I2C_SR1_SB) == (I2C_SR1_SB));
;;;1187   }
;;;1188   
;;;1189   /**
;;;1190     * @brief  Indicate the status of Address sent (master mode) or Address matched flag (slave mode).
;;;1191     * @note   RESET: Clear default value.
;;;1192     *         SET: When the address is fully sent (master mode) or when the received slave address matched with one of the enabled slave address (slave mode).
;;;1193     * @rmtoll SR1          ADDR          LL_I2C_IsActiveFlag_ADDR
;;;1194     * @param  I2Cx I2C Instance.
;;;1195     * @retval State of bit (1 or 0).
;;;1196     */
;;;1197   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ADDR(I2C_TypeDef *I2Cx)
;;;1198   {
;;;1199     return (READ_BIT(I2Cx->SR1, I2C_SR1_ADDR) == (I2C_SR1_ADDR));
;;;1200   }
;;;1201   
;;;1202   /**
;;;1203     * @brief  Indicate the status of 10-bit header sent (master mode).
;;;1204     * @note   RESET: When no ADD10 event occured.
;;;1205     *         SET: When the master has sent the first address byte (header).
;;;1206     * @rmtoll SR1          ADD10         LL_I2C_IsActiveFlag_ADD10
;;;1207     * @param  I2Cx I2C Instance.
;;;1208     * @retval State of bit (1 or 0).
;;;1209     */
;;;1210   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ADD10(I2C_TypeDef *I2Cx)
;;;1211   {
;;;1212     return (READ_BIT(I2Cx->SR1, I2C_SR1_ADD10) == (I2C_SR1_ADD10));
;;;1213   }
;;;1214   
;;;1215   /**
;;;1216     * @brief  Indicate the status of Acknowledge failure flag.
;;;1217     * @note   RESET: No acknowledge failure.
;;;1218     *         SET: When an acknowledge failure is received after a byte transmission.
;;;1219     * @rmtoll SR1          AF            LL_I2C_IsActiveFlag_AF
;;;1220     * @param  I2Cx I2C Instance.
;;;1221     * @retval State of bit (1 or 0).
;;;1222     */
;;;1223   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_AF(I2C_TypeDef *I2Cx)
;;;1224   {
;;;1225     return (READ_BIT(I2Cx->SR1, I2C_SR1_AF) == (I2C_SR1_AF));
;;;1226   }
;;;1227   
;;;1228   /**
;;;1229     * @brief  Indicate the status of Stop detection flag (slave mode).
;;;1230     * @note   RESET: Clear default value.
;;;1231     *         SET: When a Stop condition is detected.
;;;1232     * @rmtoll SR1          STOPF         LL_I2C_IsActiveFlag_STOP
;;;1233     * @param  I2Cx I2C Instance.
;;;1234     * @retval State of bit (1 or 0).
;;;1235     */
;;;1236   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_STOP(I2C_TypeDef *I2Cx)
;;;1237   {
;;;1238     return (READ_BIT(I2Cx->SR1, I2C_SR1_STOPF) == (I2C_SR1_STOPF));
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Indicate the status of Bus error flag.
;;;1243     * @note   RESET: Clear default value.
;;;1244     *         SET: When a misplaced Start or Stop condition is detected.
;;;1245     * @rmtoll SR1          BERR          LL_I2C_IsActiveFlag_BERR
;;;1246     * @param  I2Cx I2C Instance.
;;;1247     * @retval State of bit (1 or 0).
;;;1248     */
;;;1249   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BERR(I2C_TypeDef *I2Cx)
;;;1250   {
;;;1251     return (READ_BIT(I2Cx->SR1, I2C_SR1_BERR) == (I2C_SR1_BERR));
;;;1252   }
;;;1253   
;;;1254   /**
;;;1255     * @brief  Indicate the status of Arbitration lost flag.
;;;1256     * @note   RESET: Clear default value.
;;;1257     *         SET: When arbitration lost.
;;;1258     * @rmtoll SR1          ARLO          LL_I2C_IsActiveFlag_ARLO
;;;1259     * @param  I2Cx I2C Instance.
;;;1260     * @retval State of bit (1 or 0).
;;;1261     */
;;;1262   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ARLO(I2C_TypeDef *I2Cx)
;;;1263   {
;;;1264     return (READ_BIT(I2Cx->SR1, I2C_SR1_ARLO) == (I2C_SR1_ARLO));
;;;1265   }
;;;1266   
;;;1267   /**
;;;1268     * @brief  Indicate the status of Overrun/Underrun flag.
;;;1269     * @note   RESET: Clear default value.
;;;1270     *         SET: When an overrun/underrun error occurs (Clock Stretching Disabled).
;;;1271     * @rmtoll SR1          OVR           LL_I2C_IsActiveFlag_OVR
;;;1272     * @param  I2Cx I2C Instance.
;;;1273     * @retval State of bit (1 or 0).
;;;1274     */
;;;1275   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_OVR(I2C_TypeDef *I2Cx)
;;;1276   {
;;;1277     return (READ_BIT(I2Cx->SR1, I2C_SR1_OVR) == (I2C_SR1_OVR));
;;;1278   }
;;;1279   
;;;1280   /**
;;;1281     * @brief  Indicate the status of SMBus PEC error flag in reception.
;;;1282     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1283     *         SMBus feature is supported by the I2Cx Instance.
;;;1284     * @rmtoll SR1          PECERR        LL_I2C_IsActiveSMBusFlag_PECERR
;;;1285     * @param  I2Cx I2C Instance.
;;;1286     * @retval State of bit (1 or 0).
;;;1287     */
;;;1288   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_PECERR(I2C_TypeDef *I2Cx)
;;;1289   {
;;;1290     return (READ_BIT(I2Cx->SR1, I2C_SR1_PECERR) == (I2C_SR1_PECERR));
;;;1291   }
;;;1292   
;;;1293   /**
;;;1294     * @brief  Indicate the status of SMBus Timeout detection flag.
;;;1295     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1296     *         SMBus feature is supported by the I2Cx Instance.
;;;1297     * @rmtoll SR1          TIMEOUT       LL_I2C_IsActiveSMBusFlag_TIMEOUT
;;;1298     * @param  I2Cx I2C Instance.
;;;1299     * @retval State of bit (1 or 0).
;;;1300     */
;;;1301   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx)
;;;1302   {
;;;1303     return (READ_BIT(I2Cx->SR1, I2C_SR1_TIMEOUT) == (I2C_SR1_TIMEOUT));
;;;1304   }
;;;1305   
;;;1306   /**
;;;1307     * @brief  Indicate the status of SMBus alert flag.
;;;1308     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1309     *         SMBus feature is supported by the I2Cx Instance.
;;;1310     * @rmtoll SR1          SMBALERT      LL_I2C_IsActiveSMBusFlag_ALERT
;;;1311     * @param  I2Cx I2C Instance.
;;;1312     * @retval State of bit (1 or 0).
;;;1313     */
;;;1314   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_ALERT(I2C_TypeDef *I2Cx)
;;;1315   {
;;;1316     return (READ_BIT(I2Cx->SR1, I2C_SR1_SMBALERT) == (I2C_SR1_SMBALERT));
;;;1317   }
;;;1318   
;;;1319   /**
;;;1320     * @brief  Indicate the status of Bus Busy flag.
;;;1321     * @note   RESET: Clear default value.
;;;1322     *         SET: When a Start condition is detected.
;;;1323     * @rmtoll SR2          BUSY          LL_I2C_IsActiveFlag_BUSY
;;;1324     * @param  I2Cx I2C Instance.
;;;1325     * @retval State of bit (1 or 0).
;;;1326     */
;;;1327   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BUSY(I2C_TypeDef *I2Cx)
;;;1328   {
;;;1329     return (READ_BIT(I2Cx->SR2, I2C_SR2_BUSY) == (I2C_SR2_BUSY));
;;;1330   }
;;;1331   
;;;1332   /**
;;;1333     * @brief  Indicate the status of Dual flag.
;;;1334     * @note   RESET: Received address matched with OAR1.
;;;1335     *         SET: Received address matched with OAR2.
;;;1336     * @rmtoll SR2          DUALF         LL_I2C_IsActiveFlag_DUAL
;;;1337     * @param  I2Cx I2C Instance.
;;;1338     * @retval State of bit (1 or 0).
;;;1339     */
;;;1340   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_DUAL(I2C_TypeDef *I2Cx)
;;;1341   {
;;;1342     return (READ_BIT(I2Cx->SR2, I2C_SR2_DUALF) == (I2C_SR2_DUALF));
;;;1343   }
;;;1344   
;;;1345   /**
;;;1346     * @brief  Indicate the status of SMBus Host address reception (Slave mode).
;;;1347     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1348     *         SMBus feature is supported by the I2Cx Instance.
;;;1349     * @note   RESET: No SMBus Host address
;;;1350     *         SET: SMBus Host address received.
;;;1351     * @note   This status is cleared by hardware after a STOP condition or repeated START condition.
;;;1352     * @rmtoll SR2          SMBHOST       LL_I2C_IsActiveSMBusFlag_SMBHOST
;;;1353     * @param  I2Cx I2C Instance.
;;;1354     * @retval State of bit (1 or 0).
;;;1355     */
;;;1356   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_SMBHOST(I2C_TypeDef *I2Cx)
;;;1357   {
;;;1358     return (READ_BIT(I2Cx->SR2, I2C_SR2_SMBHOST) == (I2C_SR2_SMBHOST));
;;;1359   }
;;;1360   
;;;1361   /**
;;;1362     * @brief  Indicate the status of SMBus Device default address reception (Slave mode).
;;;1363     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1364     *         SMBus feature is supported by the I2Cx Instance.
;;;1365     * @note   RESET: No SMBus Device default address
;;;1366     *         SET: SMBus Device default address received.
;;;1367     * @note   This status is cleared by hardware after a STOP condition or repeated START condition.
;;;1368     * @rmtoll SR2          SMBDEFAULT    LL_I2C_IsActiveSMBusFlag_SMBDEFAULT
;;;1369     * @param  I2Cx I2C Instance.
;;;1370     * @retval State of bit (1 or 0).
;;;1371     */
;;;1372   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_SMBDEFAULT(I2C_TypeDef *I2Cx)
;;;1373   {
;;;1374     return (READ_BIT(I2Cx->SR2, I2C_SR2_SMBDEFAULT) == (I2C_SR2_SMBDEFAULT));
;;;1375   }
;;;1376   
;;;1377   /**
;;;1378     * @brief  Indicate the status of General call address reception (Slave mode).
;;;1379     * @note   RESET: No Generall call address
;;;1380     *         SET: General call address received.
;;;1381     * @note   This status is cleared by hardware after a STOP condition or repeated START condition.
;;;1382     * @rmtoll SR2          GENCALL       LL_I2C_IsActiveFlag_GENCALL
;;;1383     * @param  I2Cx I2C Instance.
;;;1384     * @retval State of bit (1 or 0).
;;;1385     */
;;;1386   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_GENCALL(I2C_TypeDef *I2Cx)
;;;1387   {
;;;1388     return (READ_BIT(I2Cx->SR2, I2C_SR2_GENCALL) == (I2C_SR2_GENCALL));
;;;1389   }
;;;1390   
;;;1391   /**
;;;1392     * @brief  Indicate the status of Master/Slave flag.
;;;1393     * @note   RESET: Slave Mode.
;;;1394     *         SET: Master Mode.
;;;1395     * @rmtoll SR2          MSL           LL_I2C_IsActiveFlag_MSL
;;;1396     * @param  I2Cx I2C Instance.
;;;1397     * @retval State of bit (1 or 0).
;;;1398     */
;;;1399   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_MSL(I2C_TypeDef *I2Cx)
;;;1400   {
;;;1401     return (READ_BIT(I2Cx->SR2, I2C_SR2_MSL) == (I2C_SR2_MSL));
;;;1402   }
;;;1403   
;;;1404   /**
;;;1405     * @brief  Clear Address Matched flag.
;;;1406     * @note   Clearing this flag is done by a read access to the I2Cx_SR1
;;;1407     *         register followed by a read access to the I2Cx_SR2 register.
;;;1408     * @rmtoll SR1          ADDR          LL_I2C_ClearFlag_ADDR
;;;1409     * @param  I2Cx I2C Instance.
;;;1410     * @retval None
;;;1411     */
;;;1412   __STATIC_INLINE void LL_I2C_ClearFlag_ADDR(I2C_TypeDef *I2Cx)
;;;1413   {
;;;1414     __IO uint32_t tmpreg;
;;;1415     tmpreg = I2Cx->SR1;
;;;1416     (void) tmpreg;
;;;1417     tmpreg = I2Cx->SR2;
;;;1418     (void) tmpreg;
;;;1419   }
;;;1420   
;;;1421   /**
;;;1422     * @brief  Clear Acknowledge failure flag.
;;;1423     * @rmtoll SR1          AF            LL_I2C_ClearFlag_AF
;;;1424     * @param  I2Cx I2C Instance.
;;;1425     * @retval None
;;;1426     */
;;;1427   __STATIC_INLINE void LL_I2C_ClearFlag_AF(I2C_TypeDef *I2Cx)
;;;1428   {
;;;1429     CLEAR_BIT(I2Cx->SR1, I2C_SR1_AF);
;;;1430   }
;;;1431   
;;;1432   /**
;;;1433     * @brief  Clear Stop detection flag.
;;;1434     * @note   Clearing this flag is done by a read access to the I2Cx_SR1
;;;1435     *         register followed by a write access to I2Cx_CR1 register.
;;;1436     * @rmtoll SR1          STOPF         LL_I2C_ClearFlag_STOP\n
;;;1437     *         CR1          PE            LL_I2C_ClearFlag_STOP
;;;1438     * @param  I2Cx I2C Instance.
;;;1439     * @retval None
;;;1440     */
;;;1441   __STATIC_INLINE void LL_I2C_ClearFlag_STOP(I2C_TypeDef *I2Cx)
;;;1442   {
;;;1443     __IO uint32_t tmpreg;
;;;1444     tmpreg = I2Cx->SR1;
;;;1445     (void) tmpreg;
;;;1446     SET_BIT(I2Cx->CR1, I2C_CR1_PE);
;;;1447   }
;;;1448   
;;;1449   /**
;;;1450     * @brief  Clear Bus error flag.
;;;1451     * @rmtoll SR1          BERR          LL_I2C_ClearFlag_BERR
;;;1452     * @param  I2Cx I2C Instance.
;;;1453     * @retval None
;;;1454     */
;;;1455   __STATIC_INLINE void LL_I2C_ClearFlag_BERR(I2C_TypeDef *I2Cx)
;;;1456   {
;;;1457     CLEAR_BIT(I2Cx->SR1, I2C_SR1_BERR);
;;;1458   }
;;;1459   
;;;1460   /**
;;;1461     * @brief  Clear Arbitration lost flag.
;;;1462     * @rmtoll SR1          ARLO          LL_I2C_ClearFlag_ARLO
;;;1463     * @param  I2Cx I2C Instance.
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_I2C_ClearFlag_ARLO(I2C_TypeDef *I2Cx)
;;;1467   {
;;;1468     CLEAR_BIT(I2Cx->SR1, I2C_SR1_ARLO);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Clear Overrun/Underrun flag.
;;;1473     * @rmtoll SR1          OVR           LL_I2C_ClearFlag_OVR
;;;1474     * @param  I2Cx I2C Instance.
;;;1475     * @retval None
;;;1476     */
;;;1477   __STATIC_INLINE void LL_I2C_ClearFlag_OVR(I2C_TypeDef *I2Cx)
;;;1478   {
;;;1479     CLEAR_BIT(I2Cx->SR1, I2C_SR1_OVR);
;;;1480   }
;;;1481   
;;;1482   /**
;;;1483     * @brief  Clear SMBus PEC error flag.
;;;1484     * @rmtoll SR1          PECERR        LL_I2C_ClearSMBusFlag_PECERR
;;;1485     * @param  I2Cx I2C Instance.
;;;1486     * @retval None
;;;1487     */
;;;1488   __STATIC_INLINE void LL_I2C_ClearSMBusFlag_PECERR(I2C_TypeDef *I2Cx)
;;;1489   {
;;;1490     CLEAR_BIT(I2Cx->SR1, I2C_SR1_PECERR);
;;;1491   }
;;;1492   
;;;1493   /**
;;;1494     * @brief  Clear SMBus Timeout detection flag.
;;;1495     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1496     *         SMBus feature is supported by the I2Cx Instance.
;;;1497     * @rmtoll SR1          TIMEOUT       LL_I2C_ClearSMBusFlag_TIMEOUT
;;;1498     * @param  I2Cx I2C Instance.
;;;1499     * @retval None
;;;1500     */
;;;1501   __STATIC_INLINE void LL_I2C_ClearSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx)
;;;1502   {
;;;1503     CLEAR_BIT(I2Cx->SR1, I2C_SR1_TIMEOUT);
;;;1504   }
;;;1505   
;;;1506   /**
;;;1507     * @brief  Clear SMBus Alert flag.
;;;1508     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1509     *         SMBus feature is supported by the I2Cx Instance.
;;;1510     * @rmtoll SR1          SMBALERT      LL_I2C_ClearSMBusFlag_ALERT
;;;1511     * @param  I2Cx I2C Instance.
;;;1512     * @retval None
;;;1513     */
;;;1514   __STATIC_INLINE void LL_I2C_ClearSMBusFlag_ALERT(I2C_TypeDef *I2Cx)
;;;1515   {
;;;1516     CLEAR_BIT(I2Cx->SR1, I2C_SR1_SMBALERT);
;;;1517   }
;;;1518   
;;;1519   /**
;;;1520     * @}
;;;1521     */
;;;1522   
;;;1523   /** @defgroup I2C_LL_EF_Data_Management Data_Management
;;;1524     * @{
;;;1525     */
;;;1526   
;;;1527   /**
;;;1528     * @brief  Enable Reset of I2C peripheral.
;;;1529     * @rmtoll CR1          SWRST         LL_I2C_EnableReset
;;;1530     * @param  I2Cx I2C Instance.
;;;1531     * @retval None
;;;1532     */
;;;1533   __STATIC_INLINE void LL_I2C_EnableReset(I2C_TypeDef *I2Cx)
;;;1534   {
;;;1535     SET_BIT(I2Cx->CR1, I2C_CR1_SWRST);
;;;1536   }
;;;1537   
;;;1538   /**
;;;1539     * @brief  Disable Reset of I2C peripheral.
;;;1540     * @rmtoll CR1          SWRST         LL_I2C_DisableReset
;;;1541     * @param  I2Cx I2C Instance.
;;;1542     * @retval None
;;;1543     */
;;;1544   __STATIC_INLINE void LL_I2C_DisableReset(I2C_TypeDef *I2Cx)
;;;1545   {
;;;1546     CLEAR_BIT(I2Cx->CR1, I2C_CR1_SWRST);
;;;1547   }
;;;1548   
;;;1549   /**
;;;1550     * @brief  Check if the I2C peripheral is under reset state or not.
;;;1551     * @rmtoll CR1          SWRST         LL_I2C_IsResetEnabled
;;;1552     * @param  I2Cx I2C Instance.
;;;1553     * @retval State of bit (1 or 0).
;;;1554     */
;;;1555   __STATIC_INLINE uint32_t LL_I2C_IsResetEnabled(I2C_TypeDef *I2Cx)
;;;1556   {
;;;1557     return (READ_BIT(I2Cx->CR1, I2C_CR1_SWRST) == (I2C_CR1_SWRST));
;;;1558   }
;;;1559   
;;;1560   /**
;;;1561     * @brief  Prepare the generation of a ACKnowledge or Non ACKnowledge condition after the address receive match code or next received byte.
;;;1562     * @note   Usage in Slave or Master mode.
;;;1563     * @rmtoll CR1          ACK           LL_I2C_AcknowledgeNextData
;;;1564     * @param  I2Cx I2C Instance.
;;;1565     * @param  TypeAcknowledge This parameter can be one of the following values:
;;;1566     *         @arg @ref LL_I2C_ACK
;;;1567     *         @arg @ref LL_I2C_NACK
;;;1568     * @retval None
;;;1569     */
;;;1570   __STATIC_INLINE void LL_I2C_AcknowledgeNextData(I2C_TypeDef *I2Cx, uint32_t TypeAcknowledge)
;;;1571   {
;;;1572     MODIFY_REG(I2Cx->CR1, I2C_CR1_ACK, TypeAcknowledge);
;;;1573   }
;;;1574   
;;;1575   /**
;;;1576     * @brief  Generate a START or RESTART condition
;;;1577     * @note   The START bit can be set even if bus is BUSY or I2C is in slave mode.
;;;1578     *         This action has no effect when RELOAD is set.
;;;1579     * @rmtoll CR1          START         LL_I2C_GenerateStartCondition
;;;1580     * @param  I2Cx I2C Instance.
;;;1581     * @retval None
;;;1582     */
;;;1583   __STATIC_INLINE void LL_I2C_GenerateStartCondition(I2C_TypeDef *I2Cx)
;;;1584   {
;;;1585     SET_BIT(I2Cx->CR1, I2C_CR1_START);
        0x08000740:    6801        .h      LDR      r1,[r0,#0]
        0x08000742:    f4417180    A..q    ORR      r1,r1,#0x100
        0x08000746:    6001        .`      STR      r1,[r0,#0]
;;;1586   }
        0x08000748:    4770        pG      BX       lr
    i.LL_I2C_Init
    LL_I2C_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;147    {
        0x0800074a:    b57f        ..      PUSH     {r0-r6,lr}
        0x0800074c:    4604        .F      MOV      r4,r0
        0x0800074e:    460d        .F      MOV      r5,r1
;;;148      LL_RCC_ClocksTypeDef rcc_clocks;
;;;149    
;;;150      /* Check the I2C Instance I2Cx */
;;;151      assert_param(IS_I2C_ALL_INSTANCE(I2Cx));
;;;152    
;;;153      /* Check the I2C parameters from I2C_InitStruct */
;;;154      assert_param(IS_LL_I2C_PERIPHERAL_MODE(I2C_InitStruct->PeripheralMode));
;;;155      assert_param(IS_LL_I2C_CLOCK_SPEED(I2C_InitStruct->ClockSpeed));
;;;156      assert_param(IS_LL_I2C_DUTY_CYCLE(I2C_InitStruct->DutyCycle));
;;;157      assert_param(IS_LL_I2C_OWN_ADDRESS1(I2C_InitStruct->OwnAddress1));
;;;158      assert_param(IS_LL_I2C_TYPE_ACKNOWLEDGE(I2C_InitStruct->TypeAcknowledge));
;;;159      assert_param(IS_LL_I2C_OWN_ADDRSIZE(I2C_InitStruct->OwnAddrSize));
;;;160    
;;;161      /* Disable the selected I2Cx Peripheral */
;;;162      LL_I2C_Disable(I2Cx);
        0x08000750:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;378      CLEAR_BIT(I2Cx->CR1, I2C_CR1_PE);
        0x08000752:    6820         h      LDR      r0,[r4,#0]
        0x08000754:    f0200001     ...    BIC      r0,r0,#1
        0x08000758:    6020         `      STR      r0,[r4,#0]
;;;379    }
        0x0800075a:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;165      LL_RCC_GetSystemClocksFreq(&rcc_clocks);
        0x0800075c:    4668        hF      MOV      r0,sp
        0x0800075e:    f000f8bd    ....    BL       LL_RCC_GetSystemClocksFreq ; 0x80008dc
;;;166    
;;;167      /*---------------------------- I2Cx SCL Clock Speed Configuration ------------
;;;168       * Configure the SCL speed :
;;;169       * - ClockSpeed: I2C_CR2_FREQ[5:0], I2C_TRISE_TRISE[5:0], I2C_CCR_FS,
;;;170       *           and I2C_CCR_CCR[11:0] bits
;;;171       * - DutyCycle: I2C_CCR_DUTY[7:0] bits
;;;172       */
;;;173      LL_I2C_ConfigSpeed(I2Cx, rcc_clocks.PCLK1_Frequency, I2C_InitStruct->ClockSpeed, I2C_InitStruct->DutyCycle);
        0x08000762:    e9d52301    ...#    LDRD     r2,r3,[r5,#4]
        0x08000766:    4620         F      MOV      r0,r4
        0x08000768:    9902        ..      LDR      r1,[sp,#8]
        0x0800076a:    f7ffff8b    ....    BL       LL_I2C_ConfigSpeed ; 0x8000684
;;;174    
;;;175      /*---------------------------- I2Cx OAR1 Configuration -----------------------
;;;176       * Disable, Configure and Enable I2Cx device own address 1 with parameters :
;;;177       * - OwnAddress1:  I2C_OAR1_ADD[9:8], I2C_OAR1_ADD[7:1] and I2C_OAR1_ADD0 bits
;;;178       * - OwnAddrSize:  I2C_OAR1_ADDMODE bit
;;;179       */
;;;180      LL_I2C_SetOwnAddress1(I2Cx, I2C_InitStruct->OwnAddress1, I2C_InitStruct->OwnAddrSize);
        0x0800076e:    6969        ii      LDR      r1,[r5,#0x14]
        0x08000770:    68e8        .h      LDR      r0,[r5,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;555      MODIFY_REG(I2Cx->OAR1, I2C_OAR1_ADD0 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD8_9 | I2C_OAR1_ADDMODE, OwnAddress1 | OwnAddrSize);
        0x08000772:    68a2        .h      LDR      r2,[r4,#8]
        0x08000774:    f24833ff    H..3    MOV      r3,#0x83ff
        0x08000778:    439a        .C      BICS     r2,r2,r3
        0x0800077a:    ea400301    @...    ORR      r3,r0,r1
        0x0800077e:    431a        .C      ORRS     r2,r2,r3
        0x08000780:    60a2        .`      STR      r2,[r4,#8]
;;;556    }
        0x08000782:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;186      LL_I2C_SetMode(I2Cx, I2C_InitStruct->PeripheralMode);
        0x08000784:    6828        (h      LDR      r0,[r5,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;796      MODIFY_REG(I2Cx->CR1, I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_ENARP, PeripheralMode);
        0x08000786:    6821        !h      LDR      r1,[r4,#0]
        0x08000788:    f021011a    !...    BIC      r1,r1,#0x1a
        0x0800078c:    4301        .C      ORRS     r1,r1,r0
        0x0800078e:    6021        !`      STR      r1,[r4,#0]
;;;797    }
        0x08000790:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;189      LL_I2C_Enable(I2Cx);
        0x08000792:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;367      SET_BIT(I2Cx->CR1, I2C_CR1_PE);
        0x08000794:    6820         h      LDR      r0,[r4,#0]
        0x08000796:    f0400001    @...    ORR      r0,r0,#1
        0x0800079a:    6020         `      STR      r0,[r4,#0]
;;;368    }
        0x0800079c:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;196      LL_I2C_AcknowledgeNextData(I2Cx, I2C_InitStruct->TypeAcknowledge);
        0x0800079e:    6928        (i      LDR      r0,[r5,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1572     MODIFY_REG(I2Cx->CR1, I2C_CR1_ACK, TypeAcknowledge);
        0x080007a0:    6821        !h      LDR      r1,[r4,#0]
        0x080007a2:    f4216180    !..a    BIC      r1,r1,#0x400
        0x080007a6:    4301        .C      ORRS     r1,r1,r0
        0x080007a8:    6021        !`      STR      r1,[r4,#0]
;;;1573   }
        0x080007aa:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;198      return SUCCESS;
        0x080007ac:    2001        .       MOVS     r0,#1
;;;199    }
        0x080007ae:    b004        ..      ADD      sp,sp,#0x10
        0x080007b0:    bd70        p.      POP      {r4-r6,pc}
        0x080007b2:    0000        ..      MOVS     r0,r0
    i.LL_Init
    LL_Init
;;; .\../Src/main.c
;;;462    {
        0x080007b4:    b570        p.      PUSH     {r4-r6,lr}
;;;463      
;;;464    
;;;465      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_AFIO);
        0x080007b6:    2001        .       MOVS     r0,#1
        0x080007b8:    f7fffe58    ..X.    BL       LL_APB2_GRP1_EnableClock ; 0x800046c
;;;466      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
        0x080007bc:    f04f5080    O..P    MOV      r0,#0x10000000
        0x080007c0:    f7fffe46    ..F.    BL       LL_APB1_GRP1_EnableClock ; 0x8000450
;;;467    
;;;468      NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
        0x080007c4:    2003        .       MOVS     r0,#3
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1425     uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
        0x080007c6:    4602        .F      MOV      r2,r0
;;;1426   
;;;1427     reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
        0x080007c8:    4b3a        :K      LDR      r3,[pc,#232] ; [0x80008b4] = 0xe000ed0c
        0x080007ca:    6819        .h      LDR      r1,[r3,#0]
;;;1428     reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
        0x080007cc:    f64f03ff    O...    MOV      r3,#0xf8ff
        0x080007d0:    4019        .@      ANDS     r1,r1,r3
;;;1429     reg_value  =  (reg_value                                   |
        0x080007d2:    4b39        9K      LDR      r3,[pc,#228] ; [0x80008b8] = 0x5fa0000
        0x080007d4:    430b        .C      ORRS     r3,r3,r1
        0x080007d6:    ea432102    C..!    ORR      r1,r3,r2,LSL #8
;;;1430                   ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
;;;1431                   (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
;;;1432     SCB->AIRCR =  reg_value;
        0x080007da:    4b36        6K      LDR      r3,[pc,#216] ; [0x80008b4] = 0xe000ed0c
        0x080007dc:    6019        .`      STR      r1,[r3,#0]
;;;1433   }
        0x080007de:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;472      NVIC_SetPriority(MemoryManagement_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x080007e0:    f000fdc0    ....    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x080007e4:    4605        .F      MOV      r5,r0
        0x080007e6:    2200        ."      MOVS     r2,#0
        0x080007e8:    4611        .F      MOV      r1,r2
        0x080007ea:    f000fd9a    ....    BL       NVIC_EncodePriority ; 0x8001322
        0x080007ee:    4604        .F      MOV      r4,r0
        0x080007f0:    4621        !F      MOV      r1,r4
        0x080007f2:    f06f000b    o...    MVN      r0,#0xb
        0x080007f6:    f000fdbd    ....    BL       NVIC_SetPriority ; 0x8001374
;;;473      /* BusFault_IRQn interrupt configuration */
;;;474      NVIC_SetPriority(BusFault_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x080007fa:    f000fdb3    ....    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x080007fe:    4605        .F      MOV      r5,r0
        0x08000800:    2200        ."      MOVS     r2,#0
        0x08000802:    4611        .F      MOV      r1,r2
        0x08000804:    f000fd8d    ....    BL       NVIC_EncodePriority ; 0x8001322
        0x08000808:    4604        .F      MOV      r4,r0
        0x0800080a:    4621        !F      MOV      r1,r4
        0x0800080c:    f06f000a    o...    MVN      r0,#0xa
        0x08000810:    f000fdb0    ....    BL       NVIC_SetPriority ; 0x8001374
;;;475      /* UsageFault_IRQn interrupt configuration */
;;;476      NVIC_SetPriority(UsageFault_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x08000814:    f000fda6    ....    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x08000818:    4605        .F      MOV      r5,r0
        0x0800081a:    2200        ."      MOVS     r2,#0
        0x0800081c:    4611        .F      MOV      r1,r2
        0x0800081e:    f000fd80    ....    BL       NVIC_EncodePriority ; 0x8001322
        0x08000822:    4604        .F      MOV      r4,r0
        0x08000824:    4621        !F      MOV      r1,r4
        0x08000826:    f06f0009    o...    MVN      r0,#9
        0x0800082a:    f000fda3    ....    BL       NVIC_SetPriority ; 0x8001374
;;;477      /* SVCall_IRQn interrupt configuration */
;;;478      NVIC_SetPriority(SVCall_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x0800082e:    f000fd99    ....    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x08000832:    4605        .F      MOV      r5,r0
        0x08000834:    2200        ."      MOVS     r2,#0
        0x08000836:    4611        .F      MOV      r1,r2
        0x08000838:    f000fd73    ..s.    BL       NVIC_EncodePriority ; 0x8001322
        0x0800083c:    4604        .F      MOV      r4,r0
        0x0800083e:    4621        !F      MOV      r1,r4
        0x08000840:    f06f0004    o...    MVN      r0,#4
        0x08000844:    f000fd96    ....    BL       NVIC_SetPriority ; 0x8001374
;;;479      /* DebugMonitor_IRQn interrupt configuration */
;;;480      NVIC_SetPriority(DebugMonitor_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x08000848:    f000fd8c    ....    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x0800084c:    4605        .F      MOV      r5,r0
        0x0800084e:    2200        ."      MOVS     r2,#0
        0x08000850:    4611        .F      MOV      r1,r2
        0x08000852:    f000fd66    ..f.    BL       NVIC_EncodePriority ; 0x8001322
        0x08000856:    4604        .F      MOV      r4,r0
        0x08000858:    4621        !F      MOV      r1,r4
        0x0800085a:    f06f0003    o...    MVN      r0,#3
        0x0800085e:    f000fd89    ....    BL       NVIC_SetPriority ; 0x8001374
;;;481      /* PendSV_IRQn interrupt configuration */
;;;482      NVIC_SetPriority(PendSV_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x08000862:    f000fd7f    ....    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x08000866:    4605        .F      MOV      r5,r0
        0x08000868:    2200        ."      MOVS     r2,#0
        0x0800086a:    4611        .F      MOV      r1,r2
        0x0800086c:    f000fd59    ..Y.    BL       NVIC_EncodePriority ; 0x8001322
        0x08000870:    4604        .F      MOV      r4,r0
        0x08000872:    4621        !F      MOV      r1,r4
        0x08000874:    f06f0001    o...    MVN      r0,#1
        0x08000878:    f000fd7c    ..|.    BL       NVIC_SetPriority ; 0x8001374
;;;483      /* SysTick_IRQn interrupt configuration */
;;;484      NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x0800087c:    f000fd72    ..r.    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x08000880:    4605        .F      MOV      r5,r0
        0x08000882:    2200        ."      MOVS     r2,#0
        0x08000884:    4611        .F      MOV      r1,r2
        0x08000886:    f000fd4c    ..L.    BL       NVIC_EncodePriority ; 0x8001322
        0x0800088a:    4604        .F      MOV      r4,r0
        0x0800088c:    4621        !F      MOV      r1,r4
        0x0800088e:    f04f30ff    O..0    MOV      r0,#0xffffffff
        0x08000892:    f000fd6f    ..o.    BL       NVIC_SetPriority ; 0x8001374
;;;485    
;;;486        /**NOJTAG: JTAG-DP Disabled and SW-DP Enabled 
;;;487        */
;;;488      LL_GPIO_AF_Remap_SWJ_NOJTAG();
        0x08000896:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;1597     CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);
        0x08000898:    4808        .H      LDR      r0,[pc,#32] ; [0x80008bc] = 0x40010000
        0x0800089a:    6840        @h      LDR      r0,[r0,#4]
        0x0800089c:    f02060e0     ..`    BIC      r0,r0,#0x7000000
        0x080008a0:    4906        .I      LDR      r1,[pc,#24] ; [0x80008bc] = 0x40010000
        0x080008a2:    6048        H`      STR      r0,[r1,#4]
;;;1598     SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_JTAGDISABLE);
        0x080008a4:    4608        .F      MOV      r0,r1
        0x080008a6:    6840        @h      LDR      r0,[r0,#4]
        0x080008a8:    f0407000    @..p    ORR      r0,r0,#0x2000000
        0x080008ac:    6048        H`      STR      r0,[r1,#4]
;;;1599   }
        0x080008ae:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;490    }
        0x080008b0:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x080008b2:    0000        ..      DCW    0
        0x080008b4:    e000ed0c    ....    DCD    3758157068
        0x080008b8:    05fa0000    ....    DCD    100270080
        0x080008bc:    40010000    ...@    DCD    1073807360
    $t
    i.LL_Init1msTick
    LL_Init1msTick
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;187      LL_InitTick(HCLKFrequency, 1000U);
        0x080008c0:    f44f717a    O.zq    MOV      r1,#0x3e8
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_utils.h
;;;237      SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
        0x080008c4:    fbb0f2f1    ....    UDIV     r2,r0,r1
        0x080008c8:    1e52        R.      SUBS     r2,r2,#1
        0x080008ca:    f04f23e0    O..#    MOV      r3,#0xe000e000
        0x080008ce:    615a        Za      STR      r2,[r3,#0x14]
;;;238      SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
        0x080008d0:    2200        ."      MOVS     r2,#0
        0x080008d2:    619a        .a      STR      r2,[r3,#0x18]
;;;239      SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
        0x080008d4:    2205        ."      MOVS     r2,#5
        0x080008d6:    611a        .a      STR      r2,[r3,#0x10]
;;;240                       SysTick_CTRL_ENABLE_Msk;                   /* Enable the Systick Timer */
;;;241    }
        0x080008d8:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;188    }
        0x080008da:    4770        pG      BX       lr
    i.LL_RCC_GetSystemClocksFreq
    LL_RCC_GetSystemClocksFreq
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;206    {
        0x080008dc:    b510        ..      PUSH     {r4,lr}
        0x080008de:    4604        .F      MOV      r4,r0
;;;207      /* Get SYSCLK frequency */
;;;208      RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
        0x080008e0:    f000fe82    ....    BL       RCC_GetSystemClockFreq ; 0x80015e8
        0x080008e4:    6020         `      STR      r0,[r4,#0]
;;;209    
;;;210      /* HCLK clock frequency */
;;;211      RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
        0x080008e6:    6820         h      LDR      r0,[r4,#0]
        0x080008e8:    f000fe4a    ..J.    BL       RCC_GetHCLKClockFreq ; 0x8001580
        0x080008ec:    6060        ``      STR      r0,[r4,#4]
;;;212    
;;;213      /* PCLK1 clock frequency */
;;;214      RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
        0x080008ee:    6860        `h      LDR      r0,[r4,#4]
        0x080008f0:    f000fe56    ..V.    BL       RCC_GetPCLK1ClockFreq ; 0x80015a0
        0x080008f4:    60a0        .`      STR      r0,[r4,#8]
;;;215    
;;;216      /* PCLK2 clock frequency */
;;;217      RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
        0x080008f6:    6860        `h      LDR      r0,[r4,#4]
        0x080008f8:    f000fe64    ..d.    BL       RCC_GetPCLK2ClockFreq ; 0x80015c4
        0x080008fc:    60e0        .`      STR      r0,[r4,#0xc]
;;;218    }
        0x080008fe:    bd10        ..      POP      {r4,pc}
    i.LL_SetSystemCoreClock
    LL_SetSystemCoreClock
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;261      SystemCoreClock = HCLKFrequency;
        0x08000900:    4901        .I      LDR      r1,[pc,#4] ; [0x8000908] = 0x20000000
        0x08000902:    6008        .`      STR      r0,[r1,#0]
;;;262    }
        0x08000904:    4770        pG      BX       lr
    $d
        0x08000906:    0000        ..      DCW    0
        0x08000908:    20000000    ...     DCD    536870912
    $t
    i.LL_TIM_BDTR_Init
    LL_TIM_BDTR_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;715    {
        0x0800090c:    b510        ..      PUSH     {r4,lr}
        0x0800090e:    4603        .F      MOV      r3,r0
        0x08000910:    460a        .F      MOV      r2,r1
;;;716      uint32_t tmpbdtr = 0;
        0x08000912:    2100        .!      MOVS     r1,#0
;;;717    
;;;718      /* Check the parameters */
;;;719      assert_param(IS_TIM_BREAK_INSTANCE(TIMx));
;;;720      assert_param(IS_LL_TIM_OSSR_STATE(TIM_BDTRInitStruct->OSSRState));
;;;721      assert_param(IS_LL_TIM_OSSI_STATE(TIM_BDTRInitStruct->OSSIState));
;;;722      assert_param(IS_LL_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->LockLevel));
;;;723      assert_param(IS_LL_TIM_BREAK_STATE(TIM_BDTRInitStruct->BreakState));
;;;724      assert_param(IS_LL_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->BreakPolarity));
;;;725      assert_param(IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->AutomaticOutput));
;;;726    
;;;727      /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;728      the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;729    
;;;730      /* Set the BDTR bits */
;;;731      MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);
        0x08000914:    7b14        .{      LDRB     r4,[r2,#0xc]
        0x08000916:    4621        !F      MOV      r1,r4
;;;732      MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
        0x08000918:    6890        .h      LDR      r0,[r2,#8]
        0x0800091a:    4301        .C      ORRS     r1,r1,r0
;;;733      MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);
        0x0800091c:    f4216080    !..`    BIC      r0,r1,#0x400
        0x08000920:    6854        Th      LDR      r4,[r2,#4]
        0x08000922:    ea400104    @...    ORR      r1,r0,r4
;;;734      MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);
        0x08000926:    f4216000    !..`    BIC      r0,r1,#0x800
        0x0800092a:    6814        .h      LDR      r4,[r2,#0]
        0x0800092c:    ea400104    @...    ORR      r1,r0,r4
;;;735      MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);
        0x08000930:    f4215080    !..P    BIC      r0,r1,#0x1000
        0x08000934:    89d4        ..      LDRH     r4,[r2,#0xe]
        0x08000936:    ea400104    @...    ORR      r1,r0,r4
;;;736      MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);
        0x0800093a:    f4215000    !..P    BIC      r0,r1,#0x2000
        0x0800093e:    6914        .i      LDR      r4,[r2,#0x10]
        0x08000940:    ea400104    @...    ORR      r1,r0,r4
;;;737      MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);
        0x08000944:    f4214080    !..@    BIC      r0,r1,#0x4000
        0x08000948:    6954        Ti      LDR      r4,[r2,#0x14]
        0x0800094a:    ea400104    @...    ORR      r1,r0,r4
;;;738      MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);
        0x0800094e:    f4214000    !..@    BIC      r0,r1,#0x8000
        0x08000952:    6954        Ti      LDR      r4,[r2,#0x14]
        0x08000954:    ea400104    @...    ORR      r1,r0,r4
;;;739    
;;;740      /* Set TIMx_BDTR */
;;;741      LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);
        0x08000958:    6459        Yd      STR      r1,[r3,#0x44]
;;;742    
;;;743      return SUCCESS;
        0x0800095a:    2001        .       MOVS     r0,#1
;;;744    }
        0x0800095c:    bd10        ..      POP      {r4,pc}
    i.LL_TIM_DisableARRPreload
    LL_TIM_DisableARRPreload
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1206     CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
        0x0800095e:    6801        .h      LDR      r1,[r0,#0]
        0x08000960:    f0210180    !...    BIC      r1,r1,#0x80
        0x08000964:    6001        .`      STR      r1,[r0,#0]
;;;1207   }
        0x08000966:    4770        pG      BX       lr
    i.LL_TIM_DisableMasterSlaveMode
    LL_TIM_DisableMasterSlaveMode
;;;1208   
;;;1209   /**
;;;1210     * @brief  Indicates whether auto-reload (ARR) preload is enabled.
;;;1211     * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
;;;1212     * @param  TIMx Timer instance
;;;1213     * @retval State of bit (1 or 0).
;;;1214     */
;;;1215   __STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
;;;1216   {
;;;1217     return (READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE));
;;;1218   }
;;;1219   
;;;1220   /**
;;;1221     * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1222     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1223     *       whether or not the clock division feature is supported by the timer
;;;1224     *       instance.
;;;1225     * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
;;;1226     * @param  TIMx Timer instance
;;;1227     * @param  ClockDivision This parameter can be one of the following values:
;;;1228     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1229     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1230     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1231     * @retval None
;;;1232     */
;;;1233   __STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
;;;1234   {
;;;1235     MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
;;;1236   }
;;;1237   
;;;1238   /**
;;;1239     * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1240     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1241     *       whether or not the clock division feature is supported by the timer
;;;1242     *       instance.
;;;1243     * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
;;;1244     * @param  TIMx Timer instance
;;;1245     * @retval Returned value can be one of the following values:
;;;1246     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1247     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1248     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1249     */
;;;1250   __STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
;;;1251   {
;;;1252     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
;;;1253   }
;;;1254   
;;;1255   /**
;;;1256     * @brief  Set the counter value.
;;;1257     * @rmtoll CNT          CNT           LL_TIM_SetCounter
;;;1258     * @param  TIMx Timer instance
;;;1259     * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1260     * @retval None
;;;1261     */
;;;1262   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
;;;1263   {
;;;1264     WRITE_REG(TIMx->CNT, Counter);
;;;1265   }
;;;1266   
;;;1267   /**
;;;1268     * @brief  Get the counter value.
;;;1269     * @rmtoll CNT          CNT           LL_TIM_GetCounter
;;;1270     * @param  TIMx Timer instance
;;;1271     * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1272     */
;;;1273   __STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
;;;1274   {
;;;1275     return (uint32_t)(READ_REG(TIMx->CNT));
;;;1276   }
;;;1277   
;;;1278   /**
;;;1279     * @brief  Get the current direction of the counter
;;;1280     * @rmtoll CR1          DIR           LL_TIM_GetDirection
;;;1281     * @param  TIMx Timer instance
;;;1282     * @retval Returned value can be one of the following values:
;;;1283     *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
;;;1284     *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
;;;1285     */
;;;1286   __STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
;;;1287   {
;;;1288     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
;;;1289   }
;;;1290   
;;;1291   /**
;;;1292     * @brief  Set the prescaler value.
;;;1293     * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
;;;1294     * @note The prescaler can be changed on the fly as this control register is buffered. The new
;;;1295     *       prescaler ratio is taken into account at the next update event.
;;;1296     * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
;;;1297     * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
;;;1298     * @param  TIMx Timer instance
;;;1299     * @param  Prescaler between Min_Data=0 and Max_Data=65535
;;;1300     * @retval None
;;;1301     */
;;;1302   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
;;;1303   {
;;;1304     WRITE_REG(TIMx->PSC, Prescaler);
;;;1305   }
;;;1306   
;;;1307   /**
;;;1308     * @brief  Get the prescaler value.
;;;1309     * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
;;;1310     * @param  TIMx Timer instance
;;;1311     * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
;;;1312     */
;;;1313   __STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
;;;1314   {
;;;1315     return (uint32_t)(READ_REG(TIMx->PSC));
;;;1316   }
;;;1317   
;;;1318   /**
;;;1319     * @brief  Set the auto-reload value.
;;;1320     * @note The counter is blocked while the auto-reload value is null.
;;;1321     * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
;;;1322     * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
;;;1323     * @param  TIMx Timer instance
;;;1324     * @param  AutoReload between Min_Data=0 and Max_Data=65535
;;;1325     * @retval None
;;;1326     */
;;;1327   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
;;;1328   {
;;;1329     WRITE_REG(TIMx->ARR, AutoReload);
;;;1330   }
;;;1331   
;;;1332   /**
;;;1333     * @brief  Get the auto-reload value.
;;;1334     * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
;;;1335     * @param  TIMx Timer instance
;;;1336     * @retval Auto-reload value
;;;1337     */
;;;1338   __STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
;;;1339   {
;;;1340     return (uint32_t)(READ_REG(TIMx->ARR));
;;;1341   }
;;;1342   
;;;1343   /**
;;;1344     * @brief  Set the repetition counter value.
;;;1345     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1346     *       whether or not a timer instance supports a repetition counter.
;;;1347     * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
;;;1348     * @param  TIMx Timer instance
;;;1349     * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
;;;1350     * @retval None
;;;1351     */
;;;1352   __STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
;;;1353   {
;;;1354     WRITE_REG(TIMx->RCR, RepetitionCounter);
;;;1355   }
;;;1356   
;;;1357   /**
;;;1358     * @brief  Get the repetition counter value.
;;;1359     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1360     *       whether or not a timer instance supports a repetition counter.
;;;1361     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1362     * @param  TIMx Timer instance
;;;1363     * @retval Repetition counter value
;;;1364     */
;;;1365   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1366   {
;;;1367     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1368   }
;;;1369   
;;;1370   /**
;;;1371     * @}
;;;1372     */
;;;1373   
;;;1374   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1375     * @{
;;;1376     */
;;;1377   /**
;;;1378     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1379     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1380     *       they are updated only when a commutation event (COM) occurs.
;;;1381     * @note Only on channels that have a complementary output.
;;;1382     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1383     *       whether or not a timer instance is able to generate a commutation event.
;;;1384     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1385     * @param  TIMx Timer instance
;;;1386     * @retval None
;;;1387     */
;;;1388   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1389   {
;;;1390     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1391   }
;;;1392   
;;;1393   /**
;;;1394     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1395     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1396     *       whether or not a timer instance is able to generate a commutation event.
;;;1397     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1398     * @param  TIMx Timer instance
;;;1399     * @retval None
;;;1400     */
;;;1401   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1402   {
;;;1403     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1404   }
;;;1405   
;;;1406   /**
;;;1407     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1408     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1409     *       whether or not a timer instance is able to generate a commutation event.
;;;1410     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1411     * @param  TIMx Timer instance
;;;1412     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1413     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1414     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1415     * @retval None
;;;1416     */
;;;1417   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1418   {
;;;1419     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1420   }
;;;1421   
;;;1422   /**
;;;1423     * @brief  Set the trigger of the capture/compare DMA request.
;;;1424     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1425     * @param  TIMx Timer instance
;;;1426     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1427     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1428     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1429     * @retval None
;;;1430     */
;;;1431   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1432   {
;;;1433     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1434   }
;;;1435   
;;;1436   /**
;;;1437     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1438     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1439     * @param  TIMx Timer instance
;;;1440     * @retval Returned value can be one of the following values:
;;;1441     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1442     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1443     */
;;;1444   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1445   {
;;;1446     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1447   }
;;;1448   
;;;1449   /**
;;;1450     * @brief  Set the lock level to freeze the
;;;1451     *         configuration of several capture/compare parameters.
;;;1452     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1453     *       the lock mechanism is supported by a timer instance.
;;;1454     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1455     * @param  TIMx Timer instance
;;;1456     * @param  LockLevel This parameter can be one of the following values:
;;;1457     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1458     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1459     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1461     * @retval None
;;;1462     */
;;;1463   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1464   {
;;;1465     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1466   }
;;;1467   
;;;1468   /**
;;;1469     * @brief  Enable capture/compare channels.
;;;1470     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1471     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1472     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1473     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1477     * @param  TIMx Timer instance
;;;1478     * @param  Channels This parameter can be a combination of the following values:
;;;1479     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1480     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1481     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1486     * @retval None
;;;1487     */
;;;1488   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1489   {
;;;1490     SET_BIT(TIMx->CCER, Channels);
;;;1491   }
;;;1492   
;;;1493   /**
;;;1494     * @brief  Disable capture/compare channels.
;;;1495     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1496     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1497     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1498     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1502     * @param  TIMx Timer instance
;;;1503     * @param  Channels This parameter can be a combination of the following values:
;;;1504     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1505     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1506     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1511     * @retval None
;;;1512     */
;;;1513   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1514   {
;;;1515     CLEAR_BIT(TIMx->CCER, Channels);
;;;1516   }
;;;1517   
;;;1518   /**
;;;1519     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1520     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1521     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1522     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1523     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1527     * @param  TIMx Timer instance
;;;1528     * @param  Channels This parameter can be a combination of the following values:
;;;1529     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1530     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1531     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1536     * @retval State of bit (1 or 0).
;;;1537     */
;;;1538   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1539   {
;;;1540     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1541   }
;;;1542   
;;;1543   /**
;;;1544     * @}
;;;1545     */
;;;1546   
;;;1547   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1548     * @{
;;;1549     */
;;;1550   /**
;;;1551     * @brief  Configure an output channel.
;;;1552     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1553     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1554     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1555     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1564     * @param  TIMx Timer instance
;;;1565     * @param  Channel This parameter can be one of the following values:
;;;1566     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1567     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1568     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1570     * @param  Configuration This parameter must be a combination of all the following values:
;;;1571     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1572     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1573     * @retval None
;;;1574     */
;;;1575   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1576   {
;;;1577     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1578     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1579     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1580     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1581                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1582     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1583                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1584   }
;;;1585   
;;;1586   /**
;;;1587     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1588     *         OCx and OCxN (when relevant) are derived.
;;;1589     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1590     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1591     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1592     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1593     * @param  TIMx Timer instance
;;;1594     * @param  Channel This parameter can be one of the following values:
;;;1595     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1596     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1597     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1599     * @param  Mode This parameter can be one of the following values:
;;;1600     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1601     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1602     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1603     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1604     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1607     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1608     * @retval None
;;;1609     */
;;;1610   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1611   {
;;;1612     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1613     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1614     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1615   }
;;;1616   
;;;1617   /**
;;;1618     * @brief  Get the output compare mode of an output channel.
;;;1619     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1620     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1621     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1622     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1623     * @param  TIMx Timer instance
;;;1624     * @param  Channel This parameter can be one of the following values:
;;;1625     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1626     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1627     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1629     * @retval Returned value can be one of the following values:
;;;1630     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1631     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1632     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1633     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1634     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1637     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1638     */
;;;1639   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1640   {
;;;1641     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1642     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1643     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1644   }
;;;1645   
;;;1646   /**
;;;1647     * @brief  Set the polarity of an output channel.
;;;1648     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1649     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1650     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1651     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1655     * @param  TIMx Timer instance
;;;1656     * @param  Channel This parameter can be one of the following values:
;;;1657     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1658     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1659     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1664     * @param  Polarity This parameter can be one of the following values:
;;;1665     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1666     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1667     * @retval None
;;;1668     */
;;;1669   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1670   {
;;;1671     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1672     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1673   }
;;;1674   
;;;1675   /**
;;;1676     * @brief  Get the polarity of an output channel.
;;;1677     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1678     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1679     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1680     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1684     * @param  TIMx Timer instance
;;;1685     * @param  Channel This parameter can be one of the following values:
;;;1686     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1687     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1688     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1693     * @retval Returned value can be one of the following values:
;;;1694     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1695     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1696     */
;;;1697   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1698   {
;;;1699     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1700     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1701   }
;;;1702   
;;;1703   /**
;;;1704     * @brief  Set the IDLE state of an output channel
;;;1705     * @note This function is significant only for the timer instances
;;;1706     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1707     *       can be used to check whether or not a timer instance provides
;;;1708     *       a break input.
;;;1709     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1710     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1711     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1712     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1716     * @param  TIMx Timer instance
;;;1717     * @param  Channel This parameter can be one of the following values:
;;;1718     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1719     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1720     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1725     * @param  IdleState This parameter can be one of the following values:
;;;1726     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1727     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1728     * @retval None
;;;1729     */
;;;1730   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1731   {
;;;1732     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1733     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1734   }
;;;1735   
;;;1736   /**
;;;1737     * @brief  Get the IDLE state of an output channel
;;;1738     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1739     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1740     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1741     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1745     * @param  TIMx Timer instance
;;;1746     * @param  Channel This parameter can be one of the following values:
;;;1747     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1748     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1749     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1754     * @retval Returned value can be one of the following values:
;;;1755     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1756     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1757     */
;;;1758   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1759   {
;;;1760     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1761     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1762   }
;;;1763   
;;;1764   /**
;;;1765     * @brief  Enable fast mode for the output channel.
;;;1766     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1767     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1768     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1769     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1770     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1771     * @param  TIMx Timer instance
;;;1772     * @param  Channel This parameter can be one of the following values:
;;;1773     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1774     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1775     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1777     * @retval None
;;;1778     */
;;;1779   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1780   {
;;;1781     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1782     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1783     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1784   
;;;1785   }
;;;1786   
;;;1787   /**
;;;1788     * @brief  Disable fast mode for the output channel.
;;;1789     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1790     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1791     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1792     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1793     * @param  TIMx Timer instance
;;;1794     * @param  Channel This parameter can be one of the following values:
;;;1795     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1796     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1797     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1799     * @retval None
;;;1800     */
;;;1801   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1802   {
;;;1803     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1804     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1805     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1806   
;;;1807   }
;;;1808   
;;;1809   /**
;;;1810     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1811     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1812     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1813     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1814     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     * @param  TIMx Timer instance
;;;1816     * @param  Channel This parameter can be one of the following values:
;;;1817     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1818     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1819     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1821     * @retval State of bit (1 or 0).
;;;1822     */
;;;1823   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1824   {
;;;1825     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1826     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1827     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1828     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1829   }
;;;1830   
;;;1831   /**
;;;1832     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1833     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1834     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1835     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1836     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1837     * @param  TIMx Timer instance
;;;1838     * @param  Channel This parameter can be one of the following values:
;;;1839     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1840     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1841     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1843     * @retval None
;;;1844     */
;;;1845   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1846   {
;;;1847     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1848     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1849     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1850   }
;;;1851   
;;;1852   /**
;;;1853     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1854     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1855     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1856     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1857     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1858     * @param  TIMx Timer instance
;;;1859     * @param  Channel This parameter can be one of the following values:
;;;1860     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1861     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1862     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1864     * @retval None
;;;1865     */
;;;1866   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1867   {
;;;1868     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1869     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1870     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1871   }
;;;1872   
;;;1873   /**
;;;1874     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1875     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1876     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1877     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1878     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     * @param  TIMx Timer instance
;;;1880     * @param  Channel This parameter can be one of the following values:
;;;1881     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1882     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1883     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1885     * @retval State of bit (1 or 0).
;;;1886     */
;;;1887   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1888   {
;;;1889     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1890     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1891     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1892     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1893   }
;;;1894   
;;;1895   /**
;;;1896     * @brief  Enable clearing the output channel on an external event.
;;;1897     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1898     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1899     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1900     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1901     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1902     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1903     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1904     * @param  TIMx Timer instance
;;;1905     * @param  Channel This parameter can be one of the following values:
;;;1906     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1907     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1908     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1910     * @retval None
;;;1911     */
;;;1912   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1913   {
;;;1914     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1915     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1916     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1917   }
;;;1918   
;;;1919   /**
;;;1920     * @brief  Disable clearing the output channel on an external event.
;;;1921     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1922     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1923     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1924     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1925     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1926     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1927     * @param  TIMx Timer instance
;;;1928     * @param  Channel This parameter can be one of the following values:
;;;1929     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1930     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1931     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1933     * @retval None
;;;1934     */
;;;1935   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1936   {
;;;1937     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1938     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1939     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1940   }
;;;1941   
;;;1942   /**
;;;1943     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1944     * @note This function enables clearing the output channel on an external event.
;;;1945     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1946     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1947     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1948     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1949     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1950     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1951     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     * @param  TIMx Timer instance
;;;1953     * @param  Channel This parameter can be one of the following values:
;;;1954     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1955     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1956     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1958     * @retval State of bit (1 or 0).
;;;1959     */
;;;1960   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1961   {
;;;1962     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1963     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1964     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1965     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1966   }
;;;1967   
;;;1968   /**
;;;1969     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1970     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1971     *       dead-time insertion feature is supported by a timer instance.
;;;1972     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1973     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1974     * @param  TIMx Timer instance
;;;1975     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1976     * @retval None
;;;1977     */
;;;1978   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1979   {
;;;1980     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1981   }
;;;1982   
;;;1983   /**
;;;1984     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1985     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1986     *       output channel 1 is supported by a timer instance.
;;;1987     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1988     * @param  TIMx Timer instance
;;;1989     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1990     * @retval None
;;;1991     */
;;;1992   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1993   {
;;;1994     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1995   }
;;;1996   
;;;1997   /**
;;;1998     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;1999     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2000     *       output channel 2 is supported by a timer instance.
;;;2001     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2002     * @param  TIMx Timer instance
;;;2003     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2004     * @retval None
;;;2005     */
;;;2006   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2007   {
;;;2008     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2009   }
;;;2010   
;;;2011   /**
;;;2012     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2013     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2014     *       output channel is supported by a timer instance.
;;;2015     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2016     * @param  TIMx Timer instance
;;;2017     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2018     * @retval None
;;;2019     */
;;;2020   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2021   {
;;;2022     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2023   }
;;;2024   
;;;2025   /**
;;;2026     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2027     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2028     *       output channel 4 is supported by a timer instance.
;;;2029     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2030     * @param  TIMx Timer instance
;;;2031     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2032     * @retval None
;;;2033     */
;;;2034   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2035   {
;;;2036     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2037   }
;;;2038   
;;;2039   /**
;;;2040     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2041     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2042     *       output channel 1 is supported by a timer instance.
;;;2043     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2044     * @param  TIMx Timer instance
;;;2045     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2046     */
;;;2047   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2048   {
;;;2049     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2050   }
;;;2051   
;;;2052   /**
;;;2053     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2054     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2055     *       output channel 2 is supported by a timer instance.
;;;2056     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2057     * @param  TIMx Timer instance
;;;2058     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2059     */
;;;2060   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2061   {
;;;2062     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2063   }
;;;2064   
;;;2065   /**
;;;2066     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2067     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2068     *       output channel 3 is supported by a timer instance.
;;;2069     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2070     * @param  TIMx Timer instance
;;;2071     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2072     */
;;;2073   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2074   {
;;;2075     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2076   }
;;;2077   
;;;2078   /**
;;;2079     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2080     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2081     *       output channel 4 is supported by a timer instance.
;;;2082     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2083     * @param  TIMx Timer instance
;;;2084     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2085     */
;;;2086   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2087   {
;;;2088     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2089   }
;;;2090   
;;;2091   /**
;;;2092     * @}
;;;2093     */
;;;2094   
;;;2095   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2096     * @{
;;;2097     */
;;;2098   /**
;;;2099     * @brief  Configure input channel.
;;;2100     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2101     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2102     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2103     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2106     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2107     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2112     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2113     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2114     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2116     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2117     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2118     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2119     * @param  TIMx Timer instance
;;;2120     * @param  Channel This parameter can be one of the following values:
;;;2121     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2122     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2123     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2125     * @param  Configuration This parameter must be a combination of all the following values:
;;;2126     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2127     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2128     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2129     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2130     * @retval None
;;;2131     */
;;;2132   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2133   {
;;;2134     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2135     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2136     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2137                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2138     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2139                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2140   }
;;;2141   
;;;2142   /**
;;;2143     * @brief  Set the active input.
;;;2144     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2145     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2146     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2147     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2148     * @param  TIMx Timer instance
;;;2149     * @param  Channel This parameter can be one of the following values:
;;;2150     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2151     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2152     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2154     * @param  ICActiveInput This parameter can be one of the following values:
;;;2155     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2156     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2157     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2158     * @retval None
;;;2159     */
;;;2160   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2161   {
;;;2162     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2163     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2164     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2165   }
;;;2166   
;;;2167   /**
;;;2168     * @brief  Get the current active input.
;;;2169     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2170     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2171     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2172     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2173     * @param  TIMx Timer instance
;;;2174     * @param  Channel This parameter can be one of the following values:
;;;2175     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2176     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2177     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2179     * @retval Returned value can be one of the following values:
;;;2180     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2181     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2182     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2183     */
;;;2184   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2185   {
;;;2186     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2187     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2188     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2189   }
;;;2190   
;;;2191   /**
;;;2192     * @brief  Set the prescaler of input channel.
;;;2193     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2194     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2195     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2196     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2197     * @param  TIMx Timer instance
;;;2198     * @param  Channel This parameter can be one of the following values:
;;;2199     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2200     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2201     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2203     * @param  ICPrescaler This parameter can be one of the following values:
;;;2204     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2205     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2206     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2208     * @retval None
;;;2209     */
;;;2210   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2211   {
;;;2212     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2213     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2214     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2215   }
;;;2216   
;;;2217   /**
;;;2218     * @brief  Get the current prescaler value acting on an  input channel.
;;;2219     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2220     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2221     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2222     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2223     * @param  TIMx Timer instance
;;;2224     * @param  Channel This parameter can be one of the following values:
;;;2225     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2226     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2227     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2229     * @retval Returned value can be one of the following values:
;;;2230     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2231     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2232     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2234     */
;;;2235   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2236   {
;;;2237     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2238     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2239     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2240   }
;;;2241   
;;;2242   /**
;;;2243     * @brief  Set the input filter duration.
;;;2244     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2245     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2246     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2247     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2248     * @param  TIMx Timer instance
;;;2249     * @param  Channel This parameter can be one of the following values:
;;;2250     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2251     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2252     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2254     * @param  ICFilter This parameter can be one of the following values:
;;;2255     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2256     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2257     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2271     * @retval None
;;;2272     */
;;;2273   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2274   {
;;;2275     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2276     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2277     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2278   }
;;;2279   
;;;2280   /**
;;;2281     * @brief  Get the input filter duration.
;;;2282     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2283     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2284     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2285     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2286     * @param  TIMx Timer instance
;;;2287     * @param  Channel This parameter can be one of the following values:
;;;2288     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2289     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2290     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2292     * @retval Returned value can be one of the following values:
;;;2293     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2294     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2295     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2309     */
;;;2310   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2311   {
;;;2312     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2313     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2314     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2315   }
;;;2316   
;;;2317   /**
;;;2318     * @brief  Set the input channel polarity.
;;;2319     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2320     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2321     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2322     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2326     * @param  TIMx Timer instance
;;;2327     * @param  Channel This parameter can be one of the following values:
;;;2328     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2329     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2330     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2332     * @param  ICPolarity This parameter can be one of the following values:
;;;2333     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2334     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2335     * @retval None
;;;2336     */
;;;2337   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2338   {
;;;2339     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2340     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2341                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2342   }
;;;2343   
;;;2344   /**
;;;2345     * @brief  Get the current input channel polarity.
;;;2346     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2347     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2348     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2349     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2353     * @param  TIMx Timer instance
;;;2354     * @param  Channel This parameter can be one of the following values:
;;;2355     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2356     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2357     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2359     * @retval Returned value can be one of the following values:
;;;2360     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2361     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2362     */
;;;2363   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2364   {
;;;2365     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2366     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2367             SHIFT_TAB_CCxP[iChannel]);
;;;2368   }
;;;2369   
;;;2370   /**
;;;2371     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2372     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2373     *       a timer instance provides an XOR input.
;;;2374     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2375     * @param  TIMx Timer instance
;;;2376     * @retval None
;;;2377     */
;;;2378   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2379   {
;;;2380     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2381   }
;;;2382   
;;;2383   /**
;;;2384     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2385     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2386     *       a timer instance provides an XOR input.
;;;2387     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2388     * @param  TIMx Timer instance
;;;2389     * @retval None
;;;2390     */
;;;2391   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2392   {
;;;2393     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2394   }
;;;2395   
;;;2396   /**
;;;2397     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2398     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2399     * a timer instance provides an XOR input.
;;;2400     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2401     * @param  TIMx Timer instance
;;;2402     * @retval State of bit (1 or 0).
;;;2403     */
;;;2404   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2405   {
;;;2406     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2407   }
;;;2408   
;;;2409   /**
;;;2410     * @brief  Get captured value for input channel 1.
;;;2411     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2412     *       input channel 1 is supported by a timer instance.
;;;2413     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2414     * @param  TIMx Timer instance
;;;2415     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2416     */
;;;2417   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2418   {
;;;2419     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2420   }
;;;2421   
;;;2422   /**
;;;2423     * @brief  Get captured value for input channel 2.
;;;2424     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2425     *       input channel 2 is supported by a timer instance.
;;;2426     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2427     * @param  TIMx Timer instance
;;;2428     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2429     */
;;;2430   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2431   {
;;;2432     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2433   }
;;;2434   
;;;2435   /**
;;;2436     * @brief  Get captured value for input channel 3.
;;;2437     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2438     *       input channel 3 is supported by a timer instance.
;;;2439     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2440     * @param  TIMx Timer instance
;;;2441     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2442     */
;;;2443   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2444   {
;;;2445     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2446   }
;;;2447   
;;;2448   /**
;;;2449     * @brief  Get captured value for input channel 4.
;;;2450     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2451     *       input channel 4 is supported by a timer instance.
;;;2452     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2453     * @param  TIMx Timer instance
;;;2454     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2455     */
;;;2456   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2457   {
;;;2458     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2459   }
;;;2460   
;;;2461   /**
;;;2462     * @}
;;;2463     */
;;;2464   
;;;2465   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2466     * @{
;;;2467     */
;;;2468   /**
;;;2469     * @brief  Enable external clock mode 2.
;;;2470     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2471     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2472     *       whether or not a timer instance supports external clock mode2.
;;;2473     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2474     * @param  TIMx Timer instance
;;;2475     * @retval None
;;;2476     */
;;;2477   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2478   {
;;;2479     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2480   }
;;;2481   
;;;2482   /**
;;;2483     * @brief  Disable external clock mode 2.
;;;2484     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2485     *       whether or not a timer instance supports external clock mode2.
;;;2486     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2487     * @param  TIMx Timer instance
;;;2488     * @retval None
;;;2489     */
;;;2490   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2491   {
;;;2492     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2493   }
;;;2494   
;;;2495   /**
;;;2496     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2497     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2498     *       whether or not a timer instance supports external clock mode2.
;;;2499     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2500     * @param  TIMx Timer instance
;;;2501     * @retval State of bit (1 or 0).
;;;2502     */
;;;2503   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2504   {
;;;2505     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2506   }
;;;2507   
;;;2508   /**
;;;2509     * @brief  Set the clock source of the counter clock.
;;;2510     * @note when selected clock source is external clock mode 1, the timer input
;;;2511     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2512     *       function. This timer input must be configured by calling
;;;2513     *       the @ref LL_TIM_IC_Config() function.
;;;2514     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2515     *       whether or not a timer instance supports external clock mode1.
;;;2516     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2517     *       whether or not a timer instance supports external clock mode2.
;;;2518     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2519     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2520     * @param  TIMx Timer instance
;;;2521     * @param  ClockSource This parameter can be one of the following values:
;;;2522     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2523     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2524     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2525     * @retval None
;;;2526     */
;;;2527   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2528   {
;;;2529     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
;;;2530   }
;;;2531   
;;;2532   /**
;;;2533     * @brief  Set the encoder interface mode.
;;;2534     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2535     *       whether or not a timer instance supports the encoder mode.
;;;2536     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2537     * @param  TIMx Timer instance
;;;2538     * @param  EncoderMode This parameter can be one of the following values:
;;;2539     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2540     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2541     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2542     * @retval None
;;;2543     */
;;;2544   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2545   {
;;;2546     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
;;;2547   }
;;;2548   
;;;2549   /**
;;;2550     * @}
;;;2551     */
;;;2552   
;;;2553   /** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
;;;2554     * @{
;;;2555     */
;;;2556   /**
;;;2557     * @brief  Set the trigger output (TRGO) used for timer synchronization .
;;;2558     * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
;;;2559     *       whether or not a timer instance can operate as a master timer.
;;;2560     * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
;;;2561     * @param  TIMx Timer instance
;;;2562     * @param  TimerSynchronization This parameter can be one of the following values:
;;;2563     *         @arg @ref LL_TIM_TRGO_RESET
;;;2564     *         @arg @ref LL_TIM_TRGO_ENABLE
;;;2565     *         @arg @ref LL_TIM_TRGO_UPDATE
;;;2566     *         @arg @ref LL_TIM_TRGO_CC1IF
;;;2567     *         @arg @ref LL_TIM_TRGO_OC1REF
;;;2568     *         @arg @ref LL_TIM_TRGO_OC2REF
;;;2569     *         @arg @ref LL_TIM_TRGO_OC3REF
;;;2570     *         @arg @ref LL_TIM_TRGO_OC4REF
;;;2571     * @retval None
;;;2572     */
;;;2573   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
;;;2574   {
;;;2575     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
;;;2576   }
;;;2577   
;;;2578   /**
;;;2579     * @brief  Set the synchronization mode of a slave timer.
;;;2580     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2581     *       a timer instance can operate as a slave timer.
;;;2582     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2583     * @param  TIMx Timer instance
;;;2584     * @param  SlaveMode This parameter can be one of the following values:
;;;2585     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2586     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2587     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2589     * @retval None
;;;2590     */
;;;2591   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2592   {
;;;2593     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2594   }
;;;2595   
;;;2596   /**
;;;2597     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2598     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2599     *       a timer instance can operate as a slave timer.
;;;2600     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2601     * @param  TIMx Timer instance
;;;2602     * @param  TriggerInput This parameter can be one of the following values:
;;;2603     *         @arg @ref LL_TIM_TS_ITR0
;;;2604     *         @arg @ref LL_TIM_TS_ITR1
;;;2605     *         @arg @ref LL_TIM_TS_ITR2
;;;2606     *         @arg @ref LL_TIM_TS_ITR3
;;;2607     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2608     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2609     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2610     *         @arg @ref LL_TIM_TS_ETRF
;;;2611     * @retval None
;;;2612     */
;;;2613   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2614   {
;;;2615     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2616   }
;;;2617   
;;;2618   /**
;;;2619     * @brief  Enable the Master/Slave mode.
;;;2620     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2621     *       a timer instance can operate as a slave timer.
;;;2622     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2623     * @param  TIMx Timer instance
;;;2624     * @retval None
;;;2625     */
;;;2626   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2627   {
;;;2628     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2629   }
;;;2630   
;;;2631   /**
;;;2632     * @brief  Disable the Master/Slave mode.
;;;2633     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2634     *       a timer instance can operate as a slave timer.
;;;2635     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2636     * @param  TIMx Timer instance
;;;2637     * @retval None
;;;2638     */
;;;2639   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2640   {
;;;2641     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
        0x08000968:    6881        .h      LDR      r1,[r0,#8]
        0x0800096a:    f0210180    !...    BIC      r1,r1,#0x80
        0x0800096e:    6081        .`      STR      r1,[r0,#8]
;;;2642   }
        0x08000970:    4770        pG      BX       lr
    i.LL_TIM_EnableIT_UPDATE
    LL_TIM_EnableIT_UPDATE
;;;2643   
;;;2644   /**
;;;2645     * @brief Indicates whether the Master/Slave mode is enabled.
;;;2646     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2647     * a timer instance can operate as a slave timer.
;;;2648     * @rmtoll SMCR         MSM           LL_TIM_IsEnabledMasterSlaveMode
;;;2649     * @param  TIMx Timer instance
;;;2650     * @retval State of bit (1 or 0).
;;;2651     */
;;;2652   __STATIC_INLINE uint32_t LL_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2653   {
;;;2654     return (READ_BIT(TIMx->SMCR, TIM_SMCR_MSM) == (TIM_SMCR_MSM));
;;;2655   }
;;;2656   
;;;2657   /**
;;;2658     * @brief  Configure the external trigger (ETR) input.
;;;2659     * @note Macro @ref IS_TIM_ETR_INSTANCE(TIMx) can be used to check whether or not
;;;2660     *       a timer instance provides an external trigger input.
;;;2661     * @rmtoll SMCR         ETP           LL_TIM_ConfigETR\n
;;;2662     *         SMCR         ETPS          LL_TIM_ConfigETR\n
;;;2663     *         SMCR         ETF           LL_TIM_ConfigETR
;;;2664     * @param  TIMx Timer instance
;;;2665     * @param  ETRPolarity This parameter can be one of the following values:
;;;2666     *         @arg @ref LL_TIM_ETR_POLARITY_NONINVERTED
;;;2667     *         @arg @ref LL_TIM_ETR_POLARITY_INVERTED
;;;2668     * @param  ETRPrescaler This parameter can be one of the following values:
;;;2669     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV1
;;;2670     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV2
;;;2671     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV4
;;;2672     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV8
;;;2673     * @param  ETRFilter This parameter can be one of the following values:
;;;2674     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1
;;;2675     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N2
;;;2676     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N4
;;;2677     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N8
;;;2678     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N6
;;;2679     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N8
;;;2680     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N6
;;;2681     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N8
;;;2682     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N6
;;;2683     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N8
;;;2684     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N5
;;;2685     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N6
;;;2686     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N8
;;;2687     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N5
;;;2688     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N6
;;;2689     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N8
;;;2690     * @retval None
;;;2691     */
;;;2692   __STATIC_INLINE void LL_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
;;;2693                                         uint32_t ETRFilter)
;;;2694   {
;;;2695     MODIFY_REG(TIMx->SMCR, TIM_SMCR_ETP | TIM_SMCR_ETPS | TIM_SMCR_ETF, ETRPolarity | ETRPrescaler | ETRFilter);
;;;2696   }
;;;2697   
;;;2698   /**
;;;2699     * @}
;;;2700     */
;;;2701   
;;;2702   /** @defgroup TIM_LL_EF_Break_Function Break function configuration
;;;2703     * @{
;;;2704     */
;;;2705   /**
;;;2706     * @brief  Enable the break function.
;;;2707     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2708     *       a timer instance provides a break input.
;;;2709     * @rmtoll BDTR         BKE           LL_TIM_EnableBRK
;;;2710     * @param  TIMx Timer instance
;;;2711     * @retval None
;;;2712     */
;;;2713   __STATIC_INLINE void LL_TIM_EnableBRK(TIM_TypeDef *TIMx)
;;;2714   {
;;;2715     SET_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2716   }
;;;2717   
;;;2718   /**
;;;2719     * @brief  Disable the break function.
;;;2720     * @rmtoll BDTR         BKE           LL_TIM_DisableBRK
;;;2721     * @param  TIMx Timer instance
;;;2722     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2723     *       a timer instance provides a break input.
;;;2724     * @retval None
;;;2725     */
;;;2726   __STATIC_INLINE void LL_TIM_DisableBRK(TIM_TypeDef *TIMx)
;;;2727   {
;;;2728     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2729   }
;;;2730   
;;;2731   /**
;;;2732     * @brief  Configure the break input.
;;;2733     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2734     *       a timer instance provides a break input.
;;;2735     * @rmtoll BDTR         BKP           LL_TIM_ConfigBRK
;;;2736     * @param  TIMx Timer instance
;;;2737     * @param  BreakPolarity This parameter can be one of the following values:
;;;2738     *         @arg @ref LL_TIM_BREAK_POLARITY_LOW
;;;2739     *         @arg @ref LL_TIM_BREAK_POLARITY_HIGH
;;;2740     * @retval None
;;;2741     */
;;;2742   __STATIC_INLINE void LL_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity)
;;;2743   {
;;;2744     MODIFY_REG(TIMx->BDTR, TIM_BDTR_BKP, BreakPolarity);
;;;2745   }
;;;2746   
;;;2747   /**
;;;2748     * @brief  Select the outputs off state (enabled v.s. disabled) in Idle and Run modes.
;;;2749     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2750     *       a timer instance provides a break input.
;;;2751     * @rmtoll BDTR         OSSI          LL_TIM_SetOffStates\n
;;;2752     *         BDTR         OSSR          LL_TIM_SetOffStates
;;;2753     * @param  TIMx Timer instance
;;;2754     * @param  OffStateIdle This parameter can be one of the following values:
;;;2755     *         @arg @ref LL_TIM_OSSI_DISABLE
;;;2756     *         @arg @ref LL_TIM_OSSI_ENABLE
;;;2757     * @param  OffStateRun This parameter can be one of the following values:
;;;2758     *         @arg @ref LL_TIM_OSSR_DISABLE
;;;2759     *         @arg @ref LL_TIM_OSSR_ENABLE
;;;2760     * @retval None
;;;2761     */
;;;2762   __STATIC_INLINE void LL_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun)
;;;2763   {
;;;2764     MODIFY_REG(TIMx->BDTR, TIM_BDTR_OSSI | TIM_BDTR_OSSR, OffStateIdle | OffStateRun);
;;;2765   }
;;;2766   
;;;2767   /**
;;;2768     * @brief  Enable automatic output (MOE can be set by software or automatically when a break input is active).
;;;2769     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2770     *       a timer instance provides a break input.
;;;2771     * @rmtoll BDTR         AOE           LL_TIM_EnableAutomaticOutput
;;;2772     * @param  TIMx Timer instance
;;;2773     * @retval None
;;;2774     */
;;;2775   __STATIC_INLINE void LL_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2776   {
;;;2777     SET_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2778   }
;;;2779   
;;;2780   /**
;;;2781     * @brief  Disable automatic output (MOE can be set only by software).
;;;2782     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2783     *       a timer instance provides a break input.
;;;2784     * @rmtoll BDTR         AOE           LL_TIM_DisableAutomaticOutput
;;;2785     * @param  TIMx Timer instance
;;;2786     * @retval None
;;;2787     */
;;;2788   __STATIC_INLINE void LL_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2789   {
;;;2790     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2791   }
;;;2792   
;;;2793   /**
;;;2794     * @brief  Indicate whether automatic output is enabled.
;;;2795     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2796     *       a timer instance provides a break input.
;;;2797     * @rmtoll BDTR         AOE           LL_TIM_IsEnabledAutomaticOutput
;;;2798     * @param  TIMx Timer instance
;;;2799     * @retval State of bit (1 or 0).
;;;2800     */
;;;2801   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx)
;;;2802   {
;;;2803     return (READ_BIT(TIMx->BDTR, TIM_BDTR_AOE) == (TIM_BDTR_AOE));
;;;2804   }
;;;2805   
;;;2806   /**
;;;2807     * @brief  Enable the outputs (set the MOE bit in TIMx_BDTR register).
;;;2808     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2809     *       software and is reset in case of break or break2 event
;;;2810     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2811     *       a timer instance provides a break input.
;;;2812     * @rmtoll BDTR         MOE           LL_TIM_EnableAllOutputs
;;;2813     * @param  TIMx Timer instance
;;;2814     * @retval None
;;;2815     */
;;;2816   __STATIC_INLINE void LL_TIM_EnableAllOutputs(TIM_TypeDef *TIMx)
;;;2817   {
;;;2818     SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2819   }
;;;2820   
;;;2821   /**
;;;2822     * @brief  Disable the outputs (reset the MOE bit in TIMx_BDTR register).
;;;2823     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2824     *       software and is reset in case of break or break2 event.
;;;2825     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2826     *       a timer instance provides a break input.
;;;2827     * @rmtoll BDTR         MOE           LL_TIM_DisableAllOutputs
;;;2828     * @param  TIMx Timer instance
;;;2829     * @retval None
;;;2830     */
;;;2831   __STATIC_INLINE void LL_TIM_DisableAllOutputs(TIM_TypeDef *TIMx)
;;;2832   {
;;;2833     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2834   }
;;;2835   
;;;2836   /**
;;;2837     * @brief  Indicates whether outputs are enabled.
;;;2838     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2839     *       a timer instance provides a break input.
;;;2840     * @rmtoll BDTR         MOE           LL_TIM_IsEnabledAllOutputs
;;;2841     * @param  TIMx Timer instance
;;;2842     * @retval State of bit (1 or 0).
;;;2843     */
;;;2844   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx)
;;;2845   {
;;;2846     return (READ_BIT(TIMx->BDTR, TIM_BDTR_MOE) == (TIM_BDTR_MOE));
;;;2847   }
;;;2848   
;;;2849   /**
;;;2850     * @}
;;;2851     */
;;;2852   
;;;2853   /** @defgroup TIM_LL_EF_DMA_Burst_Mode DMA burst mode configuration
;;;2854     * @{
;;;2855     */
;;;2856   /**
;;;2857     * @brief  Configures the timer DMA burst feature.
;;;2858     * @note Macro @ref IS_TIM_DMABURST_INSTANCE(TIMx) can be used to check whether or
;;;2859     *       not a timer instance supports the DMA burst mode.
;;;2860     * @rmtoll DCR          DBL           LL_TIM_ConfigDMABurst\n
;;;2861     *         DCR          DBA           LL_TIM_ConfigDMABurst
;;;2862     * @param  TIMx Timer instance
;;;2863     * @param  DMABurstBaseAddress This parameter can be one of the following values:
;;;2864     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR1
;;;2865     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR2
;;;2866     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SMCR
;;;2867     *         @arg @ref LL_TIM_DMABURST_BASEADDR_DIER
;;;2868     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SR
;;;2869     *         @arg @ref LL_TIM_DMABURST_BASEADDR_EGR
;;;2870     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR1
;;;2871     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR2
;;;2872     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCER
;;;2873     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CNT
;;;2874     *         @arg @ref LL_TIM_DMABURST_BASEADDR_PSC
;;;2875     *         @arg @ref LL_TIM_DMABURST_BASEADDR_ARR
;;;2876     *         @arg @ref LL_TIM_DMABURST_BASEADDR_RCR
;;;2877     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR1
;;;2878     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR2
;;;2879     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR3
;;;2880     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR4
;;;2881     *         @arg @ref LL_TIM_DMABURST_BASEADDR_BDTR
;;;2882     * @param  DMABurstLength This parameter can be one of the following values:
;;;2883     *         @arg @ref LL_TIM_DMABURST_LENGTH_1TRANSFER
;;;2884     *         @arg @ref LL_TIM_DMABURST_LENGTH_2TRANSFERS
;;;2885     *         @arg @ref LL_TIM_DMABURST_LENGTH_3TRANSFERS
;;;2886     *         @arg @ref LL_TIM_DMABURST_LENGTH_4TRANSFERS
;;;2887     *         @arg @ref LL_TIM_DMABURST_LENGTH_5TRANSFERS
;;;2888     *         @arg @ref LL_TIM_DMABURST_LENGTH_6TRANSFERS
;;;2889     *         @arg @ref LL_TIM_DMABURST_LENGTH_7TRANSFERS
;;;2890     *         @arg @ref LL_TIM_DMABURST_LENGTH_8TRANSFERS
;;;2891     *         @arg @ref LL_TIM_DMABURST_LENGTH_9TRANSFERS
;;;2892     *         @arg @ref LL_TIM_DMABURST_LENGTH_10TRANSFERS
;;;2893     *         @arg @ref LL_TIM_DMABURST_LENGTH_11TRANSFERS
;;;2894     *         @arg @ref LL_TIM_DMABURST_LENGTH_12TRANSFERS
;;;2895     *         @arg @ref LL_TIM_DMABURST_LENGTH_13TRANSFERS
;;;2896     *         @arg @ref LL_TIM_DMABURST_LENGTH_14TRANSFERS
;;;2897     *         @arg @ref LL_TIM_DMABURST_LENGTH_15TRANSFERS
;;;2898     *         @arg @ref LL_TIM_DMABURST_LENGTH_16TRANSFERS
;;;2899     *         @arg @ref LL_TIM_DMABURST_LENGTH_17TRANSFERS
;;;2900     *         @arg @ref LL_TIM_DMABURST_LENGTH_18TRANSFERS
;;;2901     * @retval None
;;;2902     */
;;;2903   __STATIC_INLINE void LL_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength)
;;;2904   {
;;;2905     MODIFY_REG(TIMx->DCR, TIM_DCR_DBL | TIM_DCR_DBA, DMABurstBaseAddress | DMABurstLength);
;;;2906   }
;;;2907   
;;;2908   /**
;;;2909     * @}
;;;2910     */
;;;2911   
;;;2912   
;;;2913   /**
;;;2914     * @}
;;;2915     */
;;;2916   
;;;2917   
;;;2918   /** @defgroup TIM_LL_EF_FLAG_Management FLAG-Management
;;;2919     * @{
;;;2920     */
;;;2921   /**
;;;2922     * @brief  Clear the update interrupt flag (UIF).
;;;2923     * @rmtoll SR           UIF           LL_TIM_ClearFlag_UPDATE
;;;2924     * @param  TIMx Timer instance
;;;2925     * @retval None
;;;2926     */
;;;2927   __STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2928   {
;;;2929     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
;;;2930   }
;;;2931   
;;;2932   /**
;;;2933     * @brief  Indicate whether update interrupt flag (UIF) is set (update interrupt is pending).
;;;2934     * @rmtoll SR           UIF           LL_TIM_IsActiveFlag_UPDATE
;;;2935     * @param  TIMx Timer instance
;;;2936     * @retval State of bit (1 or 0).
;;;2937     */
;;;2938   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2939   {
;;;2940     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
;;;2941   }
;;;2942   
;;;2943   /**
;;;2944     * @brief  Clear the Capture/Compare 1 interrupt flag (CC1F).
;;;2945     * @rmtoll SR           CC1IF         LL_TIM_ClearFlag_CC1
;;;2946     * @param  TIMx Timer instance
;;;2947     * @retval None
;;;2948     */
;;;2949   __STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
;;;2950   {
;;;2951     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
;;;2952   }
;;;2953   
;;;2954   /**
;;;2955     * @brief  Indicate whether Capture/Compare 1 interrupt flag (CC1F) is set (Capture/Compare 1 interrupt is pending).
;;;2956     * @rmtoll SR           CC1IF         LL_TIM_IsActiveFlag_CC1
;;;2957     * @param  TIMx Timer instance
;;;2958     * @retval State of bit (1 or 0).
;;;2959     */
;;;2960   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx)
;;;2961   {
;;;2962     return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
;;;2963   }
;;;2964   
;;;2965   /**
;;;2966     * @brief  Clear the Capture/Compare 2 interrupt flag (CC2F).
;;;2967     * @rmtoll SR           CC2IF         LL_TIM_ClearFlag_CC2
;;;2968     * @param  TIMx Timer instance
;;;2969     * @retval None
;;;2970     */
;;;2971   __STATIC_INLINE void LL_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx)
;;;2972   {
;;;2973     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
;;;2974   }
;;;2975   
;;;2976   /**
;;;2977     * @brief  Indicate whether Capture/Compare 2 interrupt flag (CC2F) is set (Capture/Compare 2 interrupt is pending).
;;;2978     * @rmtoll SR           CC2IF         LL_TIM_IsActiveFlag_CC2
;;;2979     * @param  TIMx Timer instance
;;;2980     * @retval State of bit (1 or 0).
;;;2981     */
;;;2982   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx)
;;;2983   {
;;;2984     return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
;;;2985   }
;;;2986   
;;;2987   /**
;;;2988     * @brief  Clear the Capture/Compare 3 interrupt flag (CC3F).
;;;2989     * @rmtoll SR           CC3IF         LL_TIM_ClearFlag_CC3
;;;2990     * @param  TIMx Timer instance
;;;2991     * @retval None
;;;2992     */
;;;2993   __STATIC_INLINE void LL_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx)
;;;2994   {
;;;2995     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
;;;2996   }
;;;2997   
;;;2998   /**
;;;2999     * @brief  Indicate whether Capture/Compare 3 interrupt flag (CC3F) is set (Capture/Compare 3 interrupt is pending).
;;;3000     * @rmtoll SR           CC3IF         LL_TIM_IsActiveFlag_CC3
;;;3001     * @param  TIMx Timer instance
;;;3002     * @retval State of bit (1 or 0).
;;;3003     */
;;;3004   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx)
;;;3005   {
;;;3006     return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
;;;3007   }
;;;3008   
;;;3009   /**
;;;3010     * @brief  Clear the Capture/Compare 4 interrupt flag (CC4F).
;;;3011     * @rmtoll SR           CC4IF         LL_TIM_ClearFlag_CC4
;;;3012     * @param  TIMx Timer instance
;;;3013     * @retval None
;;;3014     */
;;;3015   __STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
;;;3016   {
;;;3017     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
;;;3018   }
;;;3019   
;;;3020   /**
;;;3021     * @brief  Indicate whether Capture/Compare 4 interrupt flag (CC4F) is set (Capture/Compare 4 interrupt is pending).
;;;3022     * @rmtoll SR           CC4IF         LL_TIM_IsActiveFlag_CC4
;;;3023     * @param  TIMx Timer instance
;;;3024     * @retval State of bit (1 or 0).
;;;3025     */
;;;3026   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
;;;3027   {
;;;3028     return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
;;;3029   }
;;;3030   
;;;3031   /**
;;;3032     * @brief  Clear the commutation interrupt flag (COMIF).
;;;3033     * @rmtoll SR           COMIF         LL_TIM_ClearFlag_COM
;;;3034     * @param  TIMx Timer instance
;;;3035     * @retval None
;;;3036     */
;;;3037   __STATIC_INLINE void LL_TIM_ClearFlag_COM(TIM_TypeDef *TIMx)
;;;3038   {
;;;3039     WRITE_REG(TIMx->SR, ~(TIM_SR_COMIF));
;;;3040   }
;;;3041   
;;;3042   /**
;;;3043     * @brief  Indicate whether commutation interrupt flag (COMIF) is set (commutation interrupt is pending).
;;;3044     * @rmtoll SR           COMIF         LL_TIM_IsActiveFlag_COM
;;;3045     * @param  TIMx Timer instance
;;;3046     * @retval State of bit (1 or 0).
;;;3047     */
;;;3048   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx)
;;;3049   {
;;;3050     return (READ_BIT(TIMx->SR, TIM_SR_COMIF) == (TIM_SR_COMIF));
;;;3051   }
;;;3052   
;;;3053   /**
;;;3054     * @brief  Clear the trigger interrupt flag (TIF).
;;;3055     * @rmtoll SR           TIF           LL_TIM_ClearFlag_TRIG
;;;3056     * @param  TIMx Timer instance
;;;3057     * @retval None
;;;3058     */
;;;3059   __STATIC_INLINE void LL_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx)
;;;3060   {
;;;3061     WRITE_REG(TIMx->SR, ~(TIM_SR_TIF));
;;;3062   }
;;;3063   
;;;3064   /**
;;;3065     * @brief  Indicate whether trigger interrupt flag (TIF) is set (trigger interrupt is pending).
;;;3066     * @rmtoll SR           TIF           LL_TIM_IsActiveFlag_TRIG
;;;3067     * @param  TIMx Timer instance
;;;3068     * @retval State of bit (1 or 0).
;;;3069     */
;;;3070   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx)
;;;3071   {
;;;3072     return (READ_BIT(TIMx->SR, TIM_SR_TIF) == (TIM_SR_TIF));
;;;3073   }
;;;3074   
;;;3075   /**
;;;3076     * @brief  Clear the break interrupt flag (BIF).
;;;3077     * @rmtoll SR           BIF           LL_TIM_ClearFlag_BRK
;;;3078     * @param  TIMx Timer instance
;;;3079     * @retval None
;;;3080     */
;;;3081   __STATIC_INLINE void LL_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx)
;;;3082   {
;;;3083     WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
;;;3084   }
;;;3085   
;;;3086   /**
;;;3087     * @brief  Indicate whether break interrupt flag (BIF) is set (break interrupt is pending).
;;;3088     * @rmtoll SR           BIF           LL_TIM_IsActiveFlag_BRK
;;;3089     * @param  TIMx Timer instance
;;;3090     * @retval State of bit (1 or 0).
;;;3091     */
;;;3092   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
;;;3093   {
;;;3094     return (READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF));
;;;3095   }
;;;3096   
;;;3097   /**
;;;3098     * @brief  Clear the Capture/Compare 1 over-capture interrupt flag (CC1OF).
;;;3099     * @rmtoll SR           CC1OF         LL_TIM_ClearFlag_CC1OVR
;;;3100     * @param  TIMx Timer instance
;;;3101     * @retval None
;;;3102     */
;;;3103   __STATIC_INLINE void LL_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3104   {
;;;3105     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1OF));
;;;3106   }
;;;3107   
;;;3108   /**
;;;3109     * @brief  Indicate whether Capture/Compare 1 over-capture interrupt flag (CC1OF) is set (Capture/Compare 1 interrupt is pending).
;;;3110     * @rmtoll SR           CC1OF         LL_TIM_IsActiveFlag_CC1OVR
;;;3111     * @param  TIMx Timer instance
;;;3112     * @retval State of bit (1 or 0).
;;;3113     */
;;;3114   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3115   {
;;;3116     return (READ_BIT(TIMx->SR, TIM_SR_CC1OF) == (TIM_SR_CC1OF));
;;;3117   }
;;;3118   
;;;3119   /**
;;;3120     * @brief  Clear the Capture/Compare 2 over-capture interrupt flag (CC2OF).
;;;3121     * @rmtoll SR           CC2OF         LL_TIM_ClearFlag_CC2OVR
;;;3122     * @param  TIMx Timer instance
;;;3123     * @retval None
;;;3124     */
;;;3125   __STATIC_INLINE void LL_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3126   {
;;;3127     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2OF));
;;;3128   }
;;;3129   
;;;3130   /**
;;;3131     * @brief  Indicate whether Capture/Compare 2 over-capture interrupt flag (CC2OF) is set (Capture/Compare 2 over-capture interrupt is pending).
;;;3132     * @rmtoll SR           CC2OF         LL_TIM_IsActiveFlag_CC2OVR
;;;3133     * @param  TIMx Timer instance
;;;3134     * @retval State of bit (1 or 0).
;;;3135     */
;;;3136   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3137   {
;;;3138     return (READ_BIT(TIMx->SR, TIM_SR_CC2OF) == (TIM_SR_CC2OF));
;;;3139   }
;;;3140   
;;;3141   /**
;;;3142     * @brief  Clear the Capture/Compare 3 over-capture interrupt flag (CC3OF).
;;;3143     * @rmtoll SR           CC3OF         LL_TIM_ClearFlag_CC3OVR
;;;3144     * @param  TIMx Timer instance
;;;3145     * @retval None
;;;3146     */
;;;3147   __STATIC_INLINE void LL_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3148   {
;;;3149     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3OF));
;;;3150   }
;;;3151   
;;;3152   /**
;;;3153     * @brief  Indicate whether Capture/Compare 3 over-capture interrupt flag (CC3OF) is set (Capture/Compare 3 over-capture interrupt is pending).
;;;3154     * @rmtoll SR           CC3OF         LL_TIM_IsActiveFlag_CC3OVR
;;;3155     * @param  TIMx Timer instance
;;;3156     * @retval State of bit (1 or 0).
;;;3157     */
;;;3158   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3159   {
;;;3160     return (READ_BIT(TIMx->SR, TIM_SR_CC3OF) == (TIM_SR_CC3OF));
;;;3161   }
;;;3162   
;;;3163   /**
;;;3164     * @brief  Clear the Capture/Compare 4 over-capture interrupt flag (CC4OF).
;;;3165     * @rmtoll SR           CC4OF         LL_TIM_ClearFlag_CC4OVR
;;;3166     * @param  TIMx Timer instance
;;;3167     * @retval None
;;;3168     */
;;;3169   __STATIC_INLINE void LL_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3170   {
;;;3171     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4OF));
;;;3172   }
;;;3173   
;;;3174   /**
;;;3175     * @brief  Indicate whether Capture/Compare 4 over-capture interrupt flag (CC4OF) is set (Capture/Compare 4 over-capture interrupt is pending).
;;;3176     * @rmtoll SR           CC4OF         LL_TIM_IsActiveFlag_CC4OVR
;;;3177     * @param  TIMx Timer instance
;;;3178     * @retval State of bit (1 or 0).
;;;3179     */
;;;3180   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3181   {
;;;3182     return (READ_BIT(TIMx->SR, TIM_SR_CC4OF) == (TIM_SR_CC4OF));
;;;3183   }
;;;3184   
;;;3185   /**
;;;3186     * @}
;;;3187     */
;;;3188   
;;;3189   /** @defgroup TIM_LL_EF_IT_Management IT-Management
;;;3190     * @{
;;;3191     */
;;;3192   /**
;;;3193     * @brief  Enable update interrupt (UIE).
;;;3194     * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
;;;3195     * @param  TIMx Timer instance
;;;3196     * @retval None
;;;3197     */
;;;3198   __STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3199   {
;;;3200     SET_BIT(TIMx->DIER, TIM_DIER_UIE);
        0x08000972:    68c1        .h      LDR      r1,[r0,#0xc]
        0x08000974:    f0410101    A...    ORR      r1,r1,#1
        0x08000978:    60c1        .`      STR      r1,[r0,#0xc]
;;;3201   }
        0x0800097a:    4770        pG      BX       lr
    i.LL_TIM_IC_SetActiveInput
    LL_TIM_IC_SetActiveInput
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2161)
        0x0800097c:    b5f0        ..      PUSH     {r4-r7,lr}
        0x0800097e:    4603        .F      MOV      r3,r0
        0x08000980:    4614        .F      MOV      r4,r2
;;;2162     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000982:    2901        .)      CMP      r1,#1
        0x08000984:    d101        ..      BNE      0x800098a ; LL_TIM_IC_SetActiveInput + 14
        0x08000986:    2500        .%      MOVS     r5,#0
        0x08000988:    e016        ..      B        0x80009b8 ; LL_TIM_IC_SetActiveInput + 60
        0x0800098a:    2904        .)      CMP      r1,#4
        0x0800098c:    d101        ..      BNE      0x8000992 ; LL_TIM_IC_SetActiveInput + 22
        0x0800098e:    2501        .%      MOVS     r5,#1
        0x08000990:    e012        ..      B        0x80009b8 ; LL_TIM_IC_SetActiveInput + 60
        0x08000992:    2910        .)      CMP      r1,#0x10
        0x08000994:    d101        ..      BNE      0x800099a ; LL_TIM_IC_SetActiveInput + 30
        0x08000996:    2502        .%      MOVS     r5,#2
        0x08000998:    e00e        ..      B        0x80009b8 ; LL_TIM_IC_SetActiveInput + 60
        0x0800099a:    2940        @)      CMP      r1,#0x40
        0x0800099c:    d101        ..      BNE      0x80009a2 ; LL_TIM_IC_SetActiveInput + 38
        0x0800099e:    2503        .%      MOVS     r5,#3
        0x080009a0:    e00a        ..      B        0x80009b8 ; LL_TIM_IC_SetActiveInput + 60
        0x080009a2:    f5b17f80    ....    CMP      r1,#0x100
        0x080009a6:    d101        ..      BNE      0x80009ac ; LL_TIM_IC_SetActiveInput + 48
        0x080009a8:    2504        .%      MOVS     r5,#4
        0x080009aa:    e005        ..      B        0x80009b8 ; LL_TIM_IC_SetActiveInput + 60
        0x080009ac:    f5b16f80    ...o    CMP      r1,#0x400
        0x080009b0:    d101        ..      BNE      0x80009b6 ; LL_TIM_IC_SetActiveInput + 58
        0x080009b2:    2505        .%      MOVS     r5,#5
        0x080009b4:    e000        ..      B        0x80009b8 ; LL_TIM_IC_SetActiveInput + 60
        0x080009b6:    2506        .%      MOVS     r5,#6
        0x080009b8:    4628        (F      MOV      r0,r5
;;;2163     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x080009ba:    4d09        .M      LDR      r5,[pc,#36] ; [0x80009e0] = 0x8003dd7
        0x080009bc:    5c2e        .\      LDRB     r6,[r5,r0]
        0x080009be:    f1030518    ....    ADD      r5,r3,#0x18
        0x080009c2:    1972        r.      ADDS     r2,r6,r5
;;;2164     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x080009c4:    4e07        .N      LDR      r6,[pc,#28] ; [0x80009e4] = 0x8003de5
        0x080009c6:    5c37        7\      LDRB     r7,[r6,r0]
        0x080009c8:    2603        .&      MOVS     r6,#3
        0x080009ca:    40be        .@      LSLS     r6,r6,r7
        0x080009cc:    6815        .h      LDR      r5,[r2,#0]
        0x080009ce:    43b5        .C      BICS     r5,r5,r6
        0x080009d0:    0c26        &.      LSRS     r6,r4,#16
        0x080009d2:    4f04        .O      LDR      r7,[pc,#16] ; [0x80009e4] = 0x8003de5
        0x080009d4:    5c3f        ?\      LDRB     r7,[r7,r0]
        0x080009d6:    40be        .@      LSLS     r6,r6,r7
        0x080009d8:    4335        5C      ORRS     r5,r5,r6
        0x080009da:    6015        .`      STR      r5,[r2,#0]
;;;2165   }
        0x080009dc:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x080009de:    0000        ..      DCW    0
        0x080009e0:    08003dd7    .=..    DCD    134233559
        0x080009e4:    08003de5    .=..    DCD    134233573
    $t
    i.LL_TIM_IC_SetFilter
    LL_TIM_IC_SetFilter
;;;2166   
;;;2167   /**
;;;2168     * @brief  Get the current active input.
;;;2169     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2170     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2171     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2172     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2173     * @param  TIMx Timer instance
;;;2174     * @param  Channel This parameter can be one of the following values:
;;;2175     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2176     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2177     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2179     * @retval Returned value can be one of the following values:
;;;2180     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2181     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2182     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2183     */
;;;2184   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2185   {
;;;2186     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2187     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2188     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2189   }
;;;2190   
;;;2191   /**
;;;2192     * @brief  Set the prescaler of input channel.
;;;2193     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2194     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2195     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2196     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2197     * @param  TIMx Timer instance
;;;2198     * @param  Channel This parameter can be one of the following values:
;;;2199     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2200     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2201     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2203     * @param  ICPrescaler This parameter can be one of the following values:
;;;2204     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2205     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2206     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2208     * @retval None
;;;2209     */
;;;2210   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2211   {
;;;2212     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2213     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2214     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2215   }
;;;2216   
;;;2217   /**
;;;2218     * @brief  Get the current prescaler value acting on an  input channel.
;;;2219     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2220     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2221     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2222     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2223     * @param  TIMx Timer instance
;;;2224     * @param  Channel This parameter can be one of the following values:
;;;2225     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2226     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2227     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2229     * @retval Returned value can be one of the following values:
;;;2230     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2231     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2232     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2234     */
;;;2235   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2236   {
;;;2237     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2238     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2239     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2240   }
;;;2241   
;;;2242   /**
;;;2243     * @brief  Set the input filter duration.
;;;2244     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2245     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2246     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2247     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2248     * @param  TIMx Timer instance
;;;2249     * @param  Channel This parameter can be one of the following values:
;;;2250     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2251     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2252     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2254     * @param  ICFilter This parameter can be one of the following values:
;;;2255     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2256     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2257     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2271     * @retval None
;;;2272     */
;;;2273   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2274   {
        0x080009e8:    b5f0        ..      PUSH     {r4-r7,lr}
        0x080009ea:    4603        .F      MOV      r3,r0
        0x080009ec:    4614        .F      MOV      r4,r2
;;;2275     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x080009ee:    2901        .)      CMP      r1,#1
        0x080009f0:    d101        ..      BNE      0x80009f6 ; LL_TIM_IC_SetFilter + 14
        0x080009f2:    2500        .%      MOVS     r5,#0
        0x080009f4:    e016        ..      B        0x8000a24 ; LL_TIM_IC_SetFilter + 60
        0x080009f6:    2904        .)      CMP      r1,#4
        0x080009f8:    d101        ..      BNE      0x80009fe ; LL_TIM_IC_SetFilter + 22
        0x080009fa:    2501        .%      MOVS     r5,#1
        0x080009fc:    e012        ..      B        0x8000a24 ; LL_TIM_IC_SetFilter + 60
        0x080009fe:    2910        .)      CMP      r1,#0x10
        0x08000a00:    d101        ..      BNE      0x8000a06 ; LL_TIM_IC_SetFilter + 30
        0x08000a02:    2502        .%      MOVS     r5,#2
        0x08000a04:    e00e        ..      B        0x8000a24 ; LL_TIM_IC_SetFilter + 60
        0x08000a06:    2940        @)      CMP      r1,#0x40
        0x08000a08:    d101        ..      BNE      0x8000a0e ; LL_TIM_IC_SetFilter + 38
        0x08000a0a:    2503        .%      MOVS     r5,#3
        0x08000a0c:    e00a        ..      B        0x8000a24 ; LL_TIM_IC_SetFilter + 60
        0x08000a0e:    f5b17f80    ....    CMP      r1,#0x100
        0x08000a12:    d101        ..      BNE      0x8000a18 ; LL_TIM_IC_SetFilter + 48
        0x08000a14:    2504        .%      MOVS     r5,#4
        0x08000a16:    e005        ..      B        0x8000a24 ; LL_TIM_IC_SetFilter + 60
        0x08000a18:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000a1c:    d101        ..      BNE      0x8000a22 ; LL_TIM_IC_SetFilter + 58
        0x08000a1e:    2505        .%      MOVS     r5,#5
        0x08000a20:    e000        ..      B        0x8000a24 ; LL_TIM_IC_SetFilter + 60
        0x08000a22:    2506        .%      MOVS     r5,#6
        0x08000a24:    4628        (F      MOV      r0,r5
;;;2276     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000a26:    4d09        .M      LDR      r5,[pc,#36] ; [0x8000a4c] = 0x8003dd7
        0x08000a28:    5c2e        .\      LDRB     r6,[r5,r0]
        0x08000a2a:    f1030518    ....    ADD      r5,r3,#0x18
        0x08000a2e:    1972        r.      ADDS     r2,r6,r5
;;;2277     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x08000a30:    4e07        .N      LDR      r6,[pc,#28] ; [0x8000a50] = 0x8003de5
        0x08000a32:    5c37        7\      LDRB     r7,[r6,r0]
        0x08000a34:    26f0        .&      MOVS     r6,#0xf0
        0x08000a36:    40be        .@      LSLS     r6,r6,r7
        0x08000a38:    6815        .h      LDR      r5,[r2,#0]
        0x08000a3a:    43b5        .C      BICS     r5,r5,r6
        0x08000a3c:    0c26        &.      LSRS     r6,r4,#16
        0x08000a3e:    4f04        .O      LDR      r7,[pc,#16] ; [0x8000a50] = 0x8003de5
        0x08000a40:    5c3f        ?\      LDRB     r7,[r7,r0]
        0x08000a42:    40be        .@      LSLS     r6,r6,r7
        0x08000a44:    4335        5C      ORRS     r5,r5,r6
        0x08000a46:    6015        .`      STR      r5,[r2,#0]
;;;2278   }
        0x08000a48:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000a4a:    0000        ..      DCW    0
        0x08000a4c:    08003dd7    .=..    DCD    134233559
        0x08000a50:    08003de5    .=..    DCD    134233573
    $t
    i.LL_TIM_IC_SetPolarity
    LL_TIM_IC_SetPolarity
;;;2279   
;;;2280   /**
;;;2281     * @brief  Get the input filter duration.
;;;2282     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2283     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2284     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2285     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2286     * @param  TIMx Timer instance
;;;2287     * @param  Channel This parameter can be one of the following values:
;;;2288     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2289     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2290     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2292     * @retval Returned value can be one of the following values:
;;;2293     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2294     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2295     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2309     */
;;;2310   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2311   {
;;;2312     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2313     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2314     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2315   }
;;;2316   
;;;2317   /**
;;;2318     * @brief  Set the input channel polarity.
;;;2319     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2320     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2321     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2322     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2326     * @param  TIMx Timer instance
;;;2327     * @param  Channel This parameter can be one of the following values:
;;;2328     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2329     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2330     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2332     * @param  ICPolarity This parameter can be one of the following values:
;;;2333     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2334     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2335     * @retval None
;;;2336     */
;;;2337   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2338   {
        0x08000a54:    b570        p.      PUSH     {r4-r6,lr}
;;;2339     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000a56:    2901        .)      CMP      r1,#1
        0x08000a58:    d101        ..      BNE      0x8000a5e ; LL_TIM_IC_SetPolarity + 10
        0x08000a5a:    2400        .$      MOVS     r4,#0
        0x08000a5c:    e016        ..      B        0x8000a8c ; LL_TIM_IC_SetPolarity + 56
        0x08000a5e:    2904        .)      CMP      r1,#4
        0x08000a60:    d101        ..      BNE      0x8000a66 ; LL_TIM_IC_SetPolarity + 18
        0x08000a62:    2401        .$      MOVS     r4,#1
        0x08000a64:    e012        ..      B        0x8000a8c ; LL_TIM_IC_SetPolarity + 56
        0x08000a66:    2910        .)      CMP      r1,#0x10
        0x08000a68:    d101        ..      BNE      0x8000a6e ; LL_TIM_IC_SetPolarity + 26
        0x08000a6a:    2402        .$      MOVS     r4,#2
        0x08000a6c:    e00e        ..      B        0x8000a8c ; LL_TIM_IC_SetPolarity + 56
        0x08000a6e:    2940        @)      CMP      r1,#0x40
        0x08000a70:    d101        ..      BNE      0x8000a76 ; LL_TIM_IC_SetPolarity + 34
        0x08000a72:    2403        .$      MOVS     r4,#3
        0x08000a74:    e00a        ..      B        0x8000a8c ; LL_TIM_IC_SetPolarity + 56
        0x08000a76:    f5b17f80    ....    CMP      r1,#0x100
        0x08000a7a:    d101        ..      BNE      0x8000a80 ; LL_TIM_IC_SetPolarity + 44
        0x08000a7c:    2404        .$      MOVS     r4,#4
        0x08000a7e:    e005        ..      B        0x8000a8c ; LL_TIM_IC_SetPolarity + 56
        0x08000a80:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000a84:    d101        ..      BNE      0x8000a8a ; LL_TIM_IC_SetPolarity + 54
        0x08000a86:    2405        .$      MOVS     r4,#5
        0x08000a88:    e000        ..      B        0x8000a8c ; LL_TIM_IC_SetPolarity + 56
        0x08000a8a:    2406        .$      MOVS     r4,#6
        0x08000a8c:    4623        #F      MOV      r3,r4
;;;2340     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
        0x08000a8e:    6a04        .j      LDR      r4,[r0,#0x20]
        0x08000a90:    4d05        .M      LDR      r5,[pc,#20] ; [0x8000aa8] = 0x8003dec
        0x08000a92:    5cee        .\      LDRB     r6,[r5,r3]
        0x08000a94:    250a        .%      MOVS     r5,#0xa
        0x08000a96:    40b5        .@      LSLS     r5,r5,r6
        0x08000a98:    43ac        .C      BICS     r4,r4,r5
        0x08000a9a:    4d03        .M      LDR      r5,[pc,#12] ; [0x8000aa8] = 0x8003dec
        0x08000a9c:    5ced        .\      LDRB     r5,[r5,r3]
        0x08000a9e:    fa02f505    ....    LSL      r5,r2,r5
        0x08000aa2:    432c        ,C      ORRS     r4,r4,r5
        0x08000aa4:    6204        .b      STR      r4,[r0,#0x20]
;;;2341                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2342   }
        0x08000aa6:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000aa8:    08003dec    .=..    DCD    134233580
    $t
    i.LL_TIM_IC_SetPrescaler
    LL_TIM_IC_SetPrescaler
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2211)
        0x08000aac:    b5f0        ..      PUSH     {r4-r7,lr}
        0x08000aae:    4603        .F      MOV      r3,r0
        0x08000ab0:    4614        .F      MOV      r4,r2
;;;2212     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000ab2:    2901        .)      CMP      r1,#1
        0x08000ab4:    d101        ..      BNE      0x8000aba ; LL_TIM_IC_SetPrescaler + 14
        0x08000ab6:    2500        .%      MOVS     r5,#0
        0x08000ab8:    e016        ..      B        0x8000ae8 ; LL_TIM_IC_SetPrescaler + 60
        0x08000aba:    2904        .)      CMP      r1,#4
        0x08000abc:    d101        ..      BNE      0x8000ac2 ; LL_TIM_IC_SetPrescaler + 22
        0x08000abe:    2501        .%      MOVS     r5,#1
        0x08000ac0:    e012        ..      B        0x8000ae8 ; LL_TIM_IC_SetPrescaler + 60
        0x08000ac2:    2910        .)      CMP      r1,#0x10
        0x08000ac4:    d101        ..      BNE      0x8000aca ; LL_TIM_IC_SetPrescaler + 30
        0x08000ac6:    2502        .%      MOVS     r5,#2
        0x08000ac8:    e00e        ..      B        0x8000ae8 ; LL_TIM_IC_SetPrescaler + 60
        0x08000aca:    2940        @)      CMP      r1,#0x40
        0x08000acc:    d101        ..      BNE      0x8000ad2 ; LL_TIM_IC_SetPrescaler + 38
        0x08000ace:    2503        .%      MOVS     r5,#3
        0x08000ad0:    e00a        ..      B        0x8000ae8 ; LL_TIM_IC_SetPrescaler + 60
        0x08000ad2:    f5b17f80    ....    CMP      r1,#0x100
        0x08000ad6:    d101        ..      BNE      0x8000adc ; LL_TIM_IC_SetPrescaler + 48
        0x08000ad8:    2504        .%      MOVS     r5,#4
        0x08000ada:    e005        ..      B        0x8000ae8 ; LL_TIM_IC_SetPrescaler + 60
        0x08000adc:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000ae0:    d101        ..      BNE      0x8000ae6 ; LL_TIM_IC_SetPrescaler + 58
        0x08000ae2:    2505        .%      MOVS     r5,#5
        0x08000ae4:    e000        ..      B        0x8000ae8 ; LL_TIM_IC_SetPrescaler + 60
        0x08000ae6:    2506        .%      MOVS     r5,#6
        0x08000ae8:    4628        (F      MOV      r0,r5
;;;2213     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000aea:    4d09        .M      LDR      r5,[pc,#36] ; [0x8000b10] = 0x8003dd7
        0x08000aec:    5c2e        .\      LDRB     r6,[r5,r0]
        0x08000aee:    f1030518    ....    ADD      r5,r3,#0x18
        0x08000af2:    1972        r.      ADDS     r2,r6,r5
;;;2214     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x08000af4:    4e07        .N      LDR      r6,[pc,#28] ; [0x8000b14] = 0x8003de5
        0x08000af6:    5c37        7\      LDRB     r7,[r6,r0]
        0x08000af8:    260c        .&      MOVS     r6,#0xc
        0x08000afa:    40be        .@      LSLS     r6,r6,r7
        0x08000afc:    6815        .h      LDR      r5,[r2,#0]
        0x08000afe:    43b5        .C      BICS     r5,r5,r6
        0x08000b00:    0c26        &.      LSRS     r6,r4,#16
        0x08000b02:    4f04        .O      LDR      r7,[pc,#16] ; [0x8000b14] = 0x8003de5
        0x08000b04:    5c3f        ?\      LDRB     r7,[r7,r0]
        0x08000b06:    40be        .@      LSLS     r6,r6,r7
        0x08000b08:    4335        5C      ORRS     r5,r5,r6
        0x08000b0a:    6015        .`      STR      r5,[r2,#0]
;;;2215   }
        0x08000b0c:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000b0e:    0000        ..      DCW    0
        0x08000b10:    08003dd7    .=..    DCD    134233559
        0x08000b14:    08003de5    .=..    DCD    134233573
    $t
    i.LL_TIM_Init
    LL_TIM_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;341    {
        0x08000b18:    b510        ..      PUSH     {r4,lr}
        0x08000b1a:    4602        .F      MOV      r2,r0
;;;342      uint32_t tmpcr1 = 0U;
        0x08000b1c:    2300        .#      MOVS     r3,#0
;;;343    
;;;344      /* Check the parameters */
;;;345      assert_param(IS_TIM_INSTANCE(TIMx));
;;;346      assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
;;;347      assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));
;;;348    
;;;349      tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
        0x08000b1e:    6813        .h      LDR      r3,[r2,#0]
;;;350    
;;;351      if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
        0x08000b20:    481b        .H      LDR      r0,[pc,#108] ; [0x8000b90] = 0x40012c00
        0x08000b22:    4282        .B      CMP      r2,r0
        0x08000b24:    d008        ..      BEQ      0x8000b38 ; LL_TIM_Init + 32
        0x08000b26:    f1b24f80    ...O    CMP      r2,#0x40000000
        0x08000b2a:    d005        ..      BEQ      0x8000b38 ; LL_TIM_Init + 32
        0x08000b2c:    4819        .H      LDR      r0,[pc,#100] ; [0x8000b94] = 0x40000400
        0x08000b2e:    4282        .B      CMP      r2,r0
        0x08000b30:    d002        ..      BEQ      0x8000b38 ; LL_TIM_Init + 32
        0x08000b32:    4819        .H      LDR      r0,[pc,#100] ; [0x8000b98] = 0x40000800
        0x08000b34:    4282        .B      CMP      r2,r0
        0x08000b36:    d104        ..      BNE      0x8000b42 ; LL_TIM_Init + 42
;;;352      {
;;;353        /* Select the Counter Mode */
;;;354        MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
        0x08000b38:    f0230070    #.p.    BIC      r0,r3,#0x70
        0x08000b3c:    684c        Lh      LDR      r4,[r1,#4]
        0x08000b3e:    ea400304    @...    ORR      r3,r0,r4
;;;355      }
;;;356    
;;;357      if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
        0x08000b42:    4813        .H      LDR      r0,[pc,#76] ; [0x8000b90] = 0x40012c00
        0x08000b44:    4282        .B      CMP      r2,r0
        0x08000b46:    d008        ..      BEQ      0x8000b5a ; LL_TIM_Init + 66
        0x08000b48:    f1b24f80    ...O    CMP      r2,#0x40000000
        0x08000b4c:    d005        ..      BEQ      0x8000b5a ; LL_TIM_Init + 66
        0x08000b4e:    4811        .H      LDR      r0,[pc,#68] ; [0x8000b94] = 0x40000400
        0x08000b50:    4282        .B      CMP      r2,r0
        0x08000b52:    d002        ..      BEQ      0x8000b5a ; LL_TIM_Init + 66
        0x08000b54:    4810        .H      LDR      r0,[pc,#64] ; [0x8000b98] = 0x40000800
        0x08000b56:    4282        .B      CMP      r2,r0
        0x08000b58:    d104        ..      BNE      0x8000b64 ; LL_TIM_Init + 76
;;;358      {
;;;359        /* Set the clock division */
;;;360        MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
        0x08000b5a:    f4237040    #.@p    BIC      r0,r3,#0x300
        0x08000b5e:    68cc        .h      LDR      r4,[r1,#0xc]
        0x08000b60:    ea400304    @...    ORR      r3,r0,r4
;;;361      }
;;;362    
;;;363      /* Write to TIMx CR1 */
;;;364      LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
        0x08000b64:    6013        .`      STR      r3,[r2,#0]
;;;365    
;;;366      /* Set the Autoreload value */
;;;367      LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
        0x08000b66:    6888        .h      LDR      r0,[r1,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1329     WRITE_REG(TIMx->ARR, AutoReload);
        0x08000b68:    62d0        .b      STR      r0,[r2,#0x2c]
;;;1330   }
        0x08000b6a:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;370      LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
        0x08000b6c:    8808        ..      LDRH     r0,[r1,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1304     WRITE_REG(TIMx->PSC, Prescaler);
        0x08000b6e:    6290        .b      STR      r0,[r2,#0x28]
;;;1305   }
        0x08000b70:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;372      if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
        0x08000b72:    4807        .H      LDR      r0,[pc,#28] ; [0x8000b90] = 0x40012c00
        0x08000b74:    4282        .B      CMP      r2,r0
        0x08000b76:    d103        ..      BNE      0x8000b80 ; LL_TIM_Init + 104
;;;373      {
;;;374        /* Set the Repetition Counter value */
;;;375        LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
        0x08000b78:    7c08        .|      LDRB     r0,[r1,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1354     WRITE_REG(TIMx->RCR, RepetitionCounter);
        0x08000b7a:    6310        .c      STR      r0,[r2,#0x30]
;;;1355   }
        0x08000b7c:    bf00        ..      NOP      
        0x08000b7e:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;380      LL_TIM_GenerateEvent_UPDATE(TIMx);
        0x08000b80:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3709     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x08000b82:    6950        Pi      LDR      r0,[r2,#0x14]
        0x08000b84:    f0400001    @...    ORR      r0,r0,#1
        0x08000b88:    6150        Pa      STR      r0,[r2,#0x14]
;;;3710   }
        0x08000b8a:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;382      return SUCCESS;
        0x08000b8c:    2001        .       MOVS     r0,#1
;;;383    }
        0x08000b8e:    bd10        ..      POP      {r4,pc}
    $d
        0x08000b90:    40012c00    .,.@    DCD    1073818624
        0x08000b94:    40000400    ...@    DCD    1073742848
        0x08000b98:    40000800    ...@    DCD    1073743872
    $t
    i.LL_TIM_IsActiveFlag_UPDATE
    LL_TIM_IsActiveFlag_UPDATE
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2939   {
        0x08000b9c:    4601        .F      MOV      r1,r0
;;;2940     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
        0x08000b9e:    6908        .i      LDR      r0,[r1,#0x10]
        0x08000ba0:    f0000001    ....    AND      r0,r0,#1
;;;2941   }
        0x08000ba4:    4770        pG      BX       lr
        0x08000ba6:    0000        ..      MOVS     r0,r0
    i.LL_TIM_OC_DisableFast
    LL_TIM_OC_DisableFast
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1802)
        0x08000ba8:    b570        p.      PUSH     {r4-r6,lr}
        0x08000baa:    4602        .F      MOV      r2,r0
;;;1803     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000bac:    2901        .)      CMP      r1,#1
        0x08000bae:    d101        ..      BNE      0x8000bb4 ; LL_TIM_OC_DisableFast + 12
        0x08000bb0:    2400        .$      MOVS     r4,#0
        0x08000bb2:    e016        ..      B        0x8000be2 ; LL_TIM_OC_DisableFast + 58
        0x08000bb4:    2904        .)      CMP      r1,#4
        0x08000bb6:    d101        ..      BNE      0x8000bbc ; LL_TIM_OC_DisableFast + 20
        0x08000bb8:    2401        .$      MOVS     r4,#1
        0x08000bba:    e012        ..      B        0x8000be2 ; LL_TIM_OC_DisableFast + 58
        0x08000bbc:    2910        .)      CMP      r1,#0x10
        0x08000bbe:    d101        ..      BNE      0x8000bc4 ; LL_TIM_OC_DisableFast + 28
        0x08000bc0:    2402        .$      MOVS     r4,#2
        0x08000bc2:    e00e        ..      B        0x8000be2 ; LL_TIM_OC_DisableFast + 58
        0x08000bc4:    2940        @)      CMP      r1,#0x40
        0x08000bc6:    d101        ..      BNE      0x8000bcc ; LL_TIM_OC_DisableFast + 36
        0x08000bc8:    2403        .$      MOVS     r4,#3
        0x08000bca:    e00a        ..      B        0x8000be2 ; LL_TIM_OC_DisableFast + 58
        0x08000bcc:    f5b17f80    ....    CMP      r1,#0x100
        0x08000bd0:    d101        ..      BNE      0x8000bd6 ; LL_TIM_OC_DisableFast + 46
        0x08000bd2:    2404        .$      MOVS     r4,#4
        0x08000bd4:    e005        ..      B        0x8000be2 ; LL_TIM_OC_DisableFast + 58
        0x08000bd6:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000bda:    d101        ..      BNE      0x8000be0 ; LL_TIM_OC_DisableFast + 56
        0x08000bdc:    2405        .$      MOVS     r4,#5
        0x08000bde:    e000        ..      B        0x8000be2 ; LL_TIM_OC_DisableFast + 58
        0x08000be0:    2406        .$      MOVS     r4,#6
        0x08000be2:    4623        #F      MOV      r3,r4
;;;1804     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000be4:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000c00] = 0x8003dd7
        0x08000be6:    5ce5        .\      LDRB     r5,[r4,r3]
        0x08000be8:    f1020418    ....    ADD      r4,r2,#0x18
        0x08000bec:    1928        (.      ADDS     r0,r5,r4
;;;1805     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
        0x08000bee:    4d05        .M      LDR      r5,[pc,#20] ; [0x8000c04] = 0x8003dde
        0x08000bf0:    5cee        .\      LDRB     r6,[r5,r3]
        0x08000bf2:    2504        .%      MOVS     r5,#4
        0x08000bf4:    40b5        .@      LSLS     r5,r5,r6
        0x08000bf6:    6804        .h      LDR      r4,[r0,#0]
        0x08000bf8:    43ac        .C      BICS     r4,r4,r5
        0x08000bfa:    6004        .`      STR      r4,[r0,#0]
;;;1806   
;;;1807   }
        0x08000bfc:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000bfe:    0000        ..      DCW    0
        0x08000c00:    08003dd7    .=..    DCD    134233559
        0x08000c04:    08003dde    .=..    DCD    134233566
    $t
    i.LL_TIM_OC_EnablePreload
    LL_TIM_OC_EnablePreload
;;;1808   
;;;1809   /**
;;;1810     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1811     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1812     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1813     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1814     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     * @param  TIMx Timer instance
;;;1816     * @param  Channel This parameter can be one of the following values:
;;;1817     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1818     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1819     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1821     * @retval State of bit (1 or 0).
;;;1822     */
;;;1823   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1824   {
;;;1825     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1826     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1827     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1828     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1829   }
;;;1830   
;;;1831   /**
;;;1832     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1833     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1834     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1835     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1836     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1837     * @param  TIMx Timer instance
;;;1838     * @param  Channel This parameter can be one of the following values:
;;;1839     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1840     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1841     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1843     * @retval None
;;;1844     */
;;;1845   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1846   {
        0x08000c08:    b570        p.      PUSH     {r4-r6,lr}
        0x08000c0a:    4602        .F      MOV      r2,r0
;;;1847     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000c0c:    2901        .)      CMP      r1,#1
        0x08000c0e:    d101        ..      BNE      0x8000c14 ; LL_TIM_OC_EnablePreload + 12
        0x08000c10:    2400        .$      MOVS     r4,#0
        0x08000c12:    e016        ..      B        0x8000c42 ; LL_TIM_OC_EnablePreload + 58
        0x08000c14:    2904        .)      CMP      r1,#4
        0x08000c16:    d101        ..      BNE      0x8000c1c ; LL_TIM_OC_EnablePreload + 20
        0x08000c18:    2401        .$      MOVS     r4,#1
        0x08000c1a:    e012        ..      B        0x8000c42 ; LL_TIM_OC_EnablePreload + 58
        0x08000c1c:    2910        .)      CMP      r1,#0x10
        0x08000c1e:    d101        ..      BNE      0x8000c24 ; LL_TIM_OC_EnablePreload + 28
        0x08000c20:    2402        .$      MOVS     r4,#2
        0x08000c22:    e00e        ..      B        0x8000c42 ; LL_TIM_OC_EnablePreload + 58
        0x08000c24:    2940        @)      CMP      r1,#0x40
        0x08000c26:    d101        ..      BNE      0x8000c2c ; LL_TIM_OC_EnablePreload + 36
        0x08000c28:    2403        .$      MOVS     r4,#3
        0x08000c2a:    e00a        ..      B        0x8000c42 ; LL_TIM_OC_EnablePreload + 58
        0x08000c2c:    f5b17f80    ....    CMP      r1,#0x100
        0x08000c30:    d101        ..      BNE      0x8000c36 ; LL_TIM_OC_EnablePreload + 46
        0x08000c32:    2404        .$      MOVS     r4,#4
        0x08000c34:    e005        ..      B        0x8000c42 ; LL_TIM_OC_EnablePreload + 58
        0x08000c36:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000c3a:    d101        ..      BNE      0x8000c40 ; LL_TIM_OC_EnablePreload + 56
        0x08000c3c:    2405        .$      MOVS     r4,#5
        0x08000c3e:    e000        ..      B        0x8000c42 ; LL_TIM_OC_EnablePreload + 58
        0x08000c40:    2406        .$      MOVS     r4,#6
        0x08000c42:    4623        #F      MOV      r3,r4
;;;1848     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000c44:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000c60] = 0x8003dd7
        0x08000c46:    5ce5        .\      LDRB     r5,[r4,r3]
        0x08000c48:    f1020418    ....    ADD      r4,r2,#0x18
        0x08000c4c:    1928        (.      ADDS     r0,r5,r4
;;;1849     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
        0x08000c4e:    4d05        .M      LDR      r5,[pc,#20] ; [0x8000c64] = 0x8003dde
        0x08000c50:    5cee        .\      LDRB     r6,[r5,r3]
        0x08000c52:    2508        .%      MOVS     r5,#8
        0x08000c54:    40b5        .@      LSLS     r5,r5,r6
        0x08000c56:    6804        .h      LDR      r4,[r0,#0]
        0x08000c58:    432c        ,C      ORRS     r4,r4,r5
        0x08000c5a:    6004        .`      STR      r4,[r0,#0]
;;;1850   }
        0x08000c5c:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000c5e:    0000        ..      DCW    0
        0x08000c60:    08003dd7    .=..    DCD    134233559
        0x08000c64:    08003dde    .=..    DCD    134233566
    $t
    i.LL_TIM_OC_Init
    LL_TIM_OC_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;418    {
        0x08000c68:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08000c6c:    4606        .F      MOV      r6,r0
        0x08000c6e:    460c        .F      MOV      r4,r1
        0x08000c70:    4615        .F      MOV      r5,r2
;;;419      ErrorStatus result = ERROR;
        0x08000c72:    2700        .'      MOVS     r7,#0
;;;420    
;;;421      switch (Channel)
        0x08000c74:    2c01        .,      CMP      r4,#1
        0x08000c76:    d008        ..      BEQ      0x8000c8a ; LL_TIM_OC_Init + 34
        0x08000c78:    2c10        .,      CMP      r4,#0x10
        0x08000c7a:    d00c        ..      BEQ      0x8000c96 ; LL_TIM_OC_Init + 46
        0x08000c7c:    f5b47f80    ....    CMP      r4,#0x100
        0x08000c80:    d00f        ..      BEQ      0x8000ca2 ; LL_TIM_OC_Init + 58
        0x08000c82:    f5b45f80    ..._    CMP      r4,#0x1000
        0x08000c86:    d118        ..      BNE      0x8000cba ; LL_TIM_OC_Init + 82
        0x08000c88:    e011        ..      B        0x8000cae ; LL_TIM_OC_Init + 70
;;;422      {
;;;423        case LL_TIM_CHANNEL_CH1:
;;;424          result = OC1Config(TIMx, TIM_OC_InitStruct);
        0x08000c8a:    4629        )F      MOV      r1,r5
        0x08000c8c:    4630        0F      MOV      r0,r6
        0x08000c8e:    f000fb85    ....    BL       OC1Config ; 0x800139c
        0x08000c92:    4607        .F      MOV      r7,r0
;;;425          break;
        0x08000c94:    e012        ..      B        0x8000cbc ; LL_TIM_OC_Init + 84
;;;426        case LL_TIM_CHANNEL_CH2:
;;;427          result = OC2Config(TIMx, TIM_OC_InitStruct);
        0x08000c96:    4629        )F      MOV      r1,r5
        0x08000c98:    4630        0F      MOV      r0,r6
        0x08000c9a:    f000fbbd    ....    BL       OC2Config ; 0x8001418
        0x08000c9e:    4607        .F      MOV      r7,r0
;;;428          break;
        0x08000ca0:    e00c        ..      B        0x8000cbc ; LL_TIM_OC_Init + 84
;;;429        case LL_TIM_CHANNEL_CH3:
;;;430          result = OC3Config(TIMx, TIM_OC_InitStruct);
        0x08000ca2:    4629        )F      MOV      r1,r5
        0x08000ca4:    4630        0F      MOV      r0,r6
        0x08000ca6:    f000fbfb    ....    BL       OC3Config ; 0x80014a0
        0x08000caa:    4607        .F      MOV      r7,r0
;;;431          break;
        0x08000cac:    e006        ..      B        0x8000cbc ; LL_TIM_OC_Init + 84
;;;432        case LL_TIM_CHANNEL_CH4:
;;;433          result = OC4Config(TIMx, TIM_OC_InitStruct);
        0x08000cae:    4629        )F      MOV      r1,r5
        0x08000cb0:    4630        0F      MOV      r0,r6
        0x08000cb2:    f000fc33    ..3.    BL       OC4Config ; 0x800151c
        0x08000cb6:    4607        .F      MOV      r7,r0
;;;434          break;
        0x08000cb8:    e000        ..      B        0x8000cbc ; LL_TIM_OC_Init + 84
;;;435        default:
;;;436          break;
        0x08000cba:    bf00        ..      NOP      
        0x08000cbc:    bf00        ..      NOP      
;;;437      }
;;;438    
;;;439      return result;
        0x08000cbe:    4638        8F      MOV      r0,r7
;;;440    }
        0x08000cc0:    e8bd81f0    ....    POP      {r4-r8,pc}
    i.LL_TIM_OC_SetCompareCH2
    LL_TIM_OC_SetCompareCH2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2008     WRITE_REG(TIMx->CCR2, CompareValue);
        0x08000cc4:    6381        .c      STR      r1,[r0,#0x38]
;;;2009   }
        0x08000cc6:    4770        pG      BX       lr
    i.LL_TIM_SetClockSource
    LL_TIM_SetClockSource
;;;2010   
;;;2011   /**
;;;2012     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2013     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2014     *       output channel is supported by a timer instance.
;;;2015     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2016     * @param  TIMx Timer instance
;;;2017     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2018     * @retval None
;;;2019     */
;;;2020   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2021   {
;;;2022     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2023   }
;;;2024   
;;;2025   /**
;;;2026     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2027     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2028     *       output channel 4 is supported by a timer instance.
;;;2029     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2030     * @param  TIMx Timer instance
;;;2031     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2032     * @retval None
;;;2033     */
;;;2034   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2035   {
;;;2036     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2037   }
;;;2038   
;;;2039   /**
;;;2040     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2041     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2042     *       output channel 1 is supported by a timer instance.
;;;2043     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2044     * @param  TIMx Timer instance
;;;2045     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2046     */
;;;2047   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2048   {
;;;2049     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2050   }
;;;2051   
;;;2052   /**
;;;2053     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2054     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2055     *       output channel 2 is supported by a timer instance.
;;;2056     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2057     * @param  TIMx Timer instance
;;;2058     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2059     */
;;;2060   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2061   {
;;;2062     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2063   }
;;;2064   
;;;2065   /**
;;;2066     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2067     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2068     *       output channel 3 is supported by a timer instance.
;;;2069     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2070     * @param  TIMx Timer instance
;;;2071     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2072     */
;;;2073   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2074   {
;;;2075     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2076   }
;;;2077   
;;;2078   /**
;;;2079     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2080     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2081     *       output channel 4 is supported by a timer instance.
;;;2082     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2083     * @param  TIMx Timer instance
;;;2084     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2085     */
;;;2086   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2087   {
;;;2088     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2089   }
;;;2090   
;;;2091   /**
;;;2092     * @}
;;;2093     */
;;;2094   
;;;2095   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2096     * @{
;;;2097     */
;;;2098   /**
;;;2099     * @brief  Configure input channel.
;;;2100     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2101     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2102     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2103     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2106     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2107     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2112     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2113     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2114     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2116     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2117     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2118     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2119     * @param  TIMx Timer instance
;;;2120     * @param  Channel This parameter can be one of the following values:
;;;2121     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2122     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2123     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2125     * @param  Configuration This parameter must be a combination of all the following values:
;;;2126     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2127     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2128     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2129     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2130     * @retval None
;;;2131     */
;;;2132   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2133   {
;;;2134     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2135     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2136     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2137                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2138     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2139                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2140   }
;;;2141   
;;;2142   /**
;;;2143     * @brief  Set the active input.
;;;2144     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2145     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2146     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2147     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2148     * @param  TIMx Timer instance
;;;2149     * @param  Channel This parameter can be one of the following values:
;;;2150     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2151     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2152     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2154     * @param  ICActiveInput This parameter can be one of the following values:
;;;2155     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2156     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2157     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2158     * @retval None
;;;2159     */
;;;2160   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2161   {
;;;2162     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2163     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2164     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2165   }
;;;2166   
;;;2167   /**
;;;2168     * @brief  Get the current active input.
;;;2169     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2170     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2171     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2172     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2173     * @param  TIMx Timer instance
;;;2174     * @param  Channel This parameter can be one of the following values:
;;;2175     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2176     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2177     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2179     * @retval Returned value can be one of the following values:
;;;2180     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2181     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2182     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2183     */
;;;2184   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2185   {
;;;2186     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2187     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2188     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2189   }
;;;2190   
;;;2191   /**
;;;2192     * @brief  Set the prescaler of input channel.
;;;2193     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2194     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2195     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2196     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2197     * @param  TIMx Timer instance
;;;2198     * @param  Channel This parameter can be one of the following values:
;;;2199     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2200     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2201     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2203     * @param  ICPrescaler This parameter can be one of the following values:
;;;2204     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2205     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2206     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2208     * @retval None
;;;2209     */
;;;2210   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2211   {
;;;2212     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2213     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2214     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2215   }
;;;2216   
;;;2217   /**
;;;2218     * @brief  Get the current prescaler value acting on an  input channel.
;;;2219     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2220     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2221     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2222     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2223     * @param  TIMx Timer instance
;;;2224     * @param  Channel This parameter can be one of the following values:
;;;2225     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2226     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2227     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2229     * @retval Returned value can be one of the following values:
;;;2230     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2231     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2232     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2234     */
;;;2235   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2236   {
;;;2237     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2238     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2239     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2240   }
;;;2241   
;;;2242   /**
;;;2243     * @brief  Set the input filter duration.
;;;2244     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2245     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2246     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2247     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2248     * @param  TIMx Timer instance
;;;2249     * @param  Channel This parameter can be one of the following values:
;;;2250     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2251     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2252     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2254     * @param  ICFilter This parameter can be one of the following values:
;;;2255     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2256     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2257     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2271     * @retval None
;;;2272     */
;;;2273   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2274   {
;;;2275     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2276     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2277     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2278   }
;;;2279   
;;;2280   /**
;;;2281     * @brief  Get the input filter duration.
;;;2282     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2283     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2284     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2285     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2286     * @param  TIMx Timer instance
;;;2287     * @param  Channel This parameter can be one of the following values:
;;;2288     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2289     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2290     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2292     * @retval Returned value can be one of the following values:
;;;2293     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2294     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2295     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2309     */
;;;2310   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2311   {
;;;2312     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2313     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2314     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2315   }
;;;2316   
;;;2317   /**
;;;2318     * @brief  Set the input channel polarity.
;;;2319     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2320     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2321     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2322     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2326     * @param  TIMx Timer instance
;;;2327     * @param  Channel This parameter can be one of the following values:
;;;2328     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2329     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2330     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2332     * @param  ICPolarity This parameter can be one of the following values:
;;;2333     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2334     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2335     * @retval None
;;;2336     */
;;;2337   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2338   {
;;;2339     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2340     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2341                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2342   }
;;;2343   
;;;2344   /**
;;;2345     * @brief  Get the current input channel polarity.
;;;2346     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2347     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2348     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2349     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2353     * @param  TIMx Timer instance
;;;2354     * @param  Channel This parameter can be one of the following values:
;;;2355     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2356     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2357     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2359     * @retval Returned value can be one of the following values:
;;;2360     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2361     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2362     */
;;;2363   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2364   {
;;;2365     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2366     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2367             SHIFT_TAB_CCxP[iChannel]);
;;;2368   }
;;;2369   
;;;2370   /**
;;;2371     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2372     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2373     *       a timer instance provides an XOR input.
;;;2374     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2375     * @param  TIMx Timer instance
;;;2376     * @retval None
;;;2377     */
;;;2378   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2379   {
;;;2380     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2381   }
;;;2382   
;;;2383   /**
;;;2384     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2385     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2386     *       a timer instance provides an XOR input.
;;;2387     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2388     * @param  TIMx Timer instance
;;;2389     * @retval None
;;;2390     */
;;;2391   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2392   {
;;;2393     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2394   }
;;;2395   
;;;2396   /**
;;;2397     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2398     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2399     * a timer instance provides an XOR input.
;;;2400     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2401     * @param  TIMx Timer instance
;;;2402     * @retval State of bit (1 or 0).
;;;2403     */
;;;2404   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2405   {
;;;2406     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2407   }
;;;2408   
;;;2409   /**
;;;2410     * @brief  Get captured value for input channel 1.
;;;2411     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2412     *       input channel 1 is supported by a timer instance.
;;;2413     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2414     * @param  TIMx Timer instance
;;;2415     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2416     */
;;;2417   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2418   {
;;;2419     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2420   }
;;;2421   
;;;2422   /**
;;;2423     * @brief  Get captured value for input channel 2.
;;;2424     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2425     *       input channel 2 is supported by a timer instance.
;;;2426     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2427     * @param  TIMx Timer instance
;;;2428     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2429     */
;;;2430   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2431   {
;;;2432     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2433   }
;;;2434   
;;;2435   /**
;;;2436     * @brief  Get captured value for input channel 3.
;;;2437     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2438     *       input channel 3 is supported by a timer instance.
;;;2439     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2440     * @param  TIMx Timer instance
;;;2441     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2442     */
;;;2443   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2444   {
;;;2445     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2446   }
;;;2447   
;;;2448   /**
;;;2449     * @brief  Get captured value for input channel 4.
;;;2450     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2451     *       input channel 4 is supported by a timer instance.
;;;2452     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2453     * @param  TIMx Timer instance
;;;2454     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2455     */
;;;2456   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2457   {
;;;2458     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2459   }
;;;2460   
;;;2461   /**
;;;2462     * @}
;;;2463     */
;;;2464   
;;;2465   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2466     * @{
;;;2467     */
;;;2468   /**
;;;2469     * @brief  Enable external clock mode 2.
;;;2470     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2471     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2472     *       whether or not a timer instance supports external clock mode2.
;;;2473     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2474     * @param  TIMx Timer instance
;;;2475     * @retval None
;;;2476     */
;;;2477   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2478   {
;;;2479     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2480   }
;;;2481   
;;;2482   /**
;;;2483     * @brief  Disable external clock mode 2.
;;;2484     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2485     *       whether or not a timer instance supports external clock mode2.
;;;2486     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2487     * @param  TIMx Timer instance
;;;2488     * @retval None
;;;2489     */
;;;2490   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2491   {
;;;2492     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2493   }
;;;2494   
;;;2495   /**
;;;2496     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2497     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2498     *       whether or not a timer instance supports external clock mode2.
;;;2499     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2500     * @param  TIMx Timer instance
;;;2501     * @retval State of bit (1 or 0).
;;;2502     */
;;;2503   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2504   {
;;;2505     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2506   }
;;;2507   
;;;2508   /**
;;;2509     * @brief  Set the clock source of the counter clock.
;;;2510     * @note when selected clock source is external clock mode 1, the timer input
;;;2511     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2512     *       function. This timer input must be configured by calling
;;;2513     *       the @ref LL_TIM_IC_Config() function.
;;;2514     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2515     *       whether or not a timer instance supports external clock mode1.
;;;2516     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2517     *       whether or not a timer instance supports external clock mode2.
;;;2518     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2519     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2520     * @param  TIMx Timer instance
;;;2521     * @param  ClockSource This parameter can be one of the following values:
;;;2522     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2523     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2524     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2525     * @retval None
;;;2526     */
;;;2527   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2528   {
;;;2529     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
        0x08000cc8:    6882        .h      LDR      r2,[r0,#8]
        0x08000cca:    f2440307    D...    MOV      r3,#0x4007
        0x08000cce:    439a        .C      BICS     r2,r2,r3
        0x08000cd0:    430a        .C      ORRS     r2,r2,r1
        0x08000cd2:    6082        .`      STR      r2,[r0,#8]
;;;2530   }
        0x08000cd4:    4770        pG      BX       lr
    i.LL_TIM_SetTriggerOutput
    LL_TIM_SetTriggerOutput
;;;2531   
;;;2532   /**
;;;2533     * @brief  Set the encoder interface mode.
;;;2534     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2535     *       whether or not a timer instance supports the encoder mode.
;;;2536     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2537     * @param  TIMx Timer instance
;;;2538     * @param  EncoderMode This parameter can be one of the following values:
;;;2539     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2540     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2541     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2542     * @retval None
;;;2543     */
;;;2544   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2545   {
;;;2546     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
;;;2547   }
;;;2548   
;;;2549   /**
;;;2550     * @}
;;;2551     */
;;;2552   
;;;2553   /** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
;;;2554     * @{
;;;2555     */
;;;2556   /**
;;;2557     * @brief  Set the trigger output (TRGO) used for timer synchronization .
;;;2558     * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
;;;2559     *       whether or not a timer instance can operate as a master timer.
;;;2560     * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
;;;2561     * @param  TIMx Timer instance
;;;2562     * @param  TimerSynchronization This parameter can be one of the following values:
;;;2563     *         @arg @ref LL_TIM_TRGO_RESET
;;;2564     *         @arg @ref LL_TIM_TRGO_ENABLE
;;;2565     *         @arg @ref LL_TIM_TRGO_UPDATE
;;;2566     *         @arg @ref LL_TIM_TRGO_CC1IF
;;;2567     *         @arg @ref LL_TIM_TRGO_OC1REF
;;;2568     *         @arg @ref LL_TIM_TRGO_OC2REF
;;;2569     *         @arg @ref LL_TIM_TRGO_OC3REF
;;;2570     *         @arg @ref LL_TIM_TRGO_OC4REF
;;;2571     * @retval None
;;;2572     */
;;;2573   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
;;;2574   {
;;;2575     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
        0x08000cd6:    6842        Bh      LDR      r2,[r0,#4]
        0x08000cd8:    f0220270    ".p.    BIC      r2,r2,#0x70
        0x08000cdc:    430a        .C      ORRS     r2,r2,r1
        0x08000cde:    6042        B`      STR      r2,[r0,#4]
;;;2576   }
        0x08000ce0:    4770        pG      BX       lr
    i.LL_mDelay
    LL_mDelay
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;201    {
        0x08000ce2:    b508        ..      PUSH     {r3,lr}
;;;202      __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */
        0x08000ce4:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08000ce8:    6909        .i      LDR      r1,[r1,#0x10]
        0x08000cea:    9100        ..      STR      r1,[sp,#0]
;;;203      /* Add this code to indicate that local variable is not used */
;;;204      ((void)tmp);
        0x08000cec:    bf00        ..      NOP      
;;;205    
;;;206      /* Add a period to guaranty minimum wait */
;;;207      if (Delay < LL_MAX_DELAY)
        0x08000cee:    1c41        A.      ADDS     r1,r0,#1
        0x08000cf0:    b101        ..      CBZ      r1,0x8000cf4 ; LL_mDelay + 18
;;;208      {
;;;209        Delay++;
        0x08000cf2:    1c40        @.      ADDS     r0,r0,#1
;;;210      }
;;;211    
;;;212      while (Delay)
        0x08000cf4:    e006        ..      B        0x8000d04 ; LL_mDelay + 34
        0x08000cf6:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08000cfa:    6909        .i      LDR      r1,[r1,#0x10]
        0x08000cfc:    f4013180    ...1    AND      r1,r1,#0x10000
        0x08000d00:    b101        ..      CBZ      r1,0x8000d04 ; LL_mDelay + 34
        0x08000d02:    1e40        @.      SUBS     r0,r0,#1
        0x08000d04:    2800        .(      CMP      r0,#0
        0x08000d06:    d1f6        ..      BNE      0x8000cf6 ; LL_mDelay + 20
;;;213      {
;;;214        if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)
;;;215        {
;;;216          Delay--;
;;;217        }
;;;218      }
;;;219    }
        0x08000d08:    bd08        ..      POP      {r3,pc}
        0x08000d0a:    0000        ..      MOVS     r0,r0
    i.MX_DMA_Init
    MX_DMA_Init
;;; .\../Src/main.c
;;;836    {
        0x08000d0c:    b538        8.      PUSH     {r3-r5,lr}
;;;837      /* Init with LL driver */
;;;838      /* DMA controller clock enable */
;;;839      LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);
        0x08000d0e:    2001        .       MOVS     r0,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_bus.h
;;;288      SET_BIT(RCC->AHBENR, Periphs);
        0x08000d10:    490d        .I      LDR      r1,[pc,#52] ; [0x8000d48] = 0x40021000
        0x08000d12:    6949        Ii      LDR      r1,[r1,#0x14]
        0x08000d14:    4301        .C      ORRS     r1,r1,r0
        0x08000d16:    4a0c        .J      LDR      r2,[pc,#48] ; [0x8000d48] = 0x40021000
        0x08000d18:    6151        Qa      STR      r1,[r2,#0x14]
;;;289      /* Delay after an RCC peripheral clock enabling */
;;;290      tmpreg = READ_BIT(RCC->AHBENR, Periphs);
        0x08000d1a:    4611        .F      MOV      r1,r2
        0x08000d1c:    6949        Ii      LDR      r1,[r1,#0x14]
        0x08000d1e:    4001        .@      ANDS     r1,r1,r0
        0x08000d20:    9100        ..      STR      r1,[sp,#0]
;;;291      (void)tmpreg;
        0x08000d22:    bf00        ..      NOP      
;;;292    }
        0x08000d24:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;843      NVIC_SetPriority(DMA1_Channel4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x08000d26:    f000fb1d    ....    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x08000d2a:    4605        .F      MOV      r5,r0
        0x08000d2c:    2200        ."      MOVS     r2,#0
        0x08000d2e:    2102        .!      MOVS     r1,#2
        0x08000d30:    f000faf7    ....    BL       NVIC_EncodePriority ; 0x8001322
        0x08000d34:    4604        .F      MOV      r4,r0
        0x08000d36:    4621        !F      MOV      r1,r4
        0x08000d38:    200e        .       MOVS     r0,#0xe
        0x08000d3a:    f000fb1b    ....    BL       NVIC_SetPriority ; 0x8001374
;;;844      NVIC_EnableIRQ(DMA1_Channel4_IRQn);
        0x08000d3e:    200e        .       MOVS     r0,#0xe
        0x08000d40:    f000fae4    ....    BL       NVIC_EnableIRQ ; 0x800130c
;;;845    
;;;846    }
        0x08000d44:    bd38        8.      POP      {r3-r5,pc}
    $d
        0x08000d46:    0000        ..      DCW    0
        0x08000d48:    40021000    ...@    DCD    1073876992
    $t
    i.MX_GPIO_Init
    MX_GPIO_Init
;;;847    
;;;848    /** Configure pins as 
;;;849            * Analog 
;;;850            * Input 
;;;851            * Output
;;;852            * EVENT_OUT
;;;853            * EXTI
;;;854            * Free pins are configured automatically as Analog (this feature is enabled through 
;;;855            * the Code Generation settings)
;;;856    */
;;;857    static void MX_GPIO_Init(void)
;;;858    {
        0x08000d4c:    b500        ..      PUSH     {lr}
        0x08000d4e:    b085        ..      SUB      sp,sp,#0x14
;;;859    
;;;860      LL_GPIO_InitTypeDef GPIO_InitStruct;
;;;861    
;;;862      /* GPIO Ports Clock Enable */
;;;863      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOC);
        0x08000d50:    2010        .       MOVS     r0,#0x10
        0x08000d52:    f7fffb8b    ....    BL       LL_APB2_GRP1_EnableClock ; 0x800046c
;;;864      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOD);
        0x08000d56:    2020                MOVS     r0,#0x20
        0x08000d58:    f7fffb88    ....    BL       LL_APB2_GRP1_EnableClock ; 0x800046c
;;;865      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x08000d5c:    2004        .       MOVS     r0,#4
        0x08000d5e:    f7fffb85    ....    BL       LL_APB2_GRP1_EnableClock ; 0x800046c
;;;866      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x08000d62:    2008        .       MOVS     r0,#8
        0x08000d64:    f7fffb82    ....    BL       LL_APB2_GRP1_EnableClock ; 0x800046c
;;;867    
;;;868      /**/
;;;869      LL_GPIO_ResetOutputPin(GPIOC, LED_Pin|MOTOR_X_DIR_Pin);
        0x08000d68:    492b        +I      LDR      r1,[pc,#172] ; [0x8000e18] = 0x4a000a0
        0x08000d6a:    482c        ,H      LDR      r0,[pc,#176] ; [0x8000e1c] = 0x40011000
        0x08000d6c:    f7fffc80    ....    BL       LL_GPIO_ResetOutputPin ; 0x8000670
;;;870    
;;;871      /**/
;;;872      LL_GPIO_ResetOutputPin(GPIOA, MOTOR_X_ENABLE_Pin|MOTOR_Z_DIR_Pin);
        0x08000d70:    f2482182    H..!    MOV      r1,#0x8282
        0x08000d74:    482a        *H      LDR      r0,[pc,#168] ; [0x8000e20] = 0x40010800
        0x08000d76:    f7fffc7b    ..{.    BL       LL_GPIO_ResetOutputPin ; 0x8000670
;;;873    
;;;874      /**/
;;;875      LL_GPIO_ResetOutputPin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
        0x08000d7a:    f2402102    @..!    MOV      r1,#0x202
        0x08000d7e:    4829        )H      LDR      r0,[pc,#164] ; [0x8000e24] = 0x40010c00
        0x08000d80:    f7fffc76    ..v.    BL       LL_GPIO_ResetOutputPin ; 0x8000670
;;;876    
;;;877      /**/
;;;878      GPIO_InitStruct.Pin = LED_Pin|MOTOR_X_DIR_Pin;
        0x08000d84:    4824        $H      LDR      r0,[pc,#144] ; [0x8000e18] = 0x4a000a0
        0x08000d86:    9000        ..      STR      r0,[sp,#0]
;;;879      GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08000d88:    2001        .       MOVS     r0,#1
        0x08000d8a:    9001        ..      STR      r0,[sp,#4]
;;;880      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x08000d8c:    2002        .       MOVS     r0,#2
        0x08000d8e:    9002        ..      STR      r0,[sp,#8]
;;;881      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08000d90:    2000        .       MOVS     r0,#0
        0x08000d92:    9003        ..      STR      r0,[sp,#0xc]
;;;882      LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        0x08000d94:    4669        iF      MOV      r1,sp
        0x08000d96:    4821        !H      LDR      r0,[pc,#132] ; [0x8000e1c] = 0x40011000
        0x08000d98:    f7fffbcc    ....    BL       LL_GPIO_Init ; 0x8000534
;;;883    
;;;884      /**/
;;;885      GPIO_InitStruct.Pin = LL_GPIO_PIN_14;
        0x08000d9c:    4822        "H      LDR      r0,[pc,#136] ; [0x8000e28] = 0x4400040
        0x08000d9e:    9000        ..      STR      r0,[sp,#0]
;;;886      GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x08000da0:    2000        .       MOVS     r0,#0
        0x08000da2:    9001        ..      STR      r0,[sp,#4]
;;;887      LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        0x08000da4:    4669        iF      MOV      r1,sp
        0x08000da6:    481d        .H      LDR      r0,[pc,#116] ; [0x8000e1c] = 0x40011000
        0x08000da8:    f7fffbc4    ....    BL       LL_GPIO_Init ; 0x8000534
;;;888    
;;;889      /**/
;;;890      GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_2|LL_GPIO_PIN_3|LL_GPIO_PIN_4 
        0x08000dac:    481f        .H      LDR      r0,[pc,#124] ; [0x8000e2c] = 0x49c3dbd
        0x08000dae:    9000        ..      STR      r0,[sp,#0]
;;;891                              |LL_GPIO_PIN_5|LL_GPIO_PIN_10|LL_GPIO_PIN_11|LL_GPIO_PIN_12 
;;;892                              |LL_GPIO_PIN_15;
;;;893      GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x08000db0:    2000        .       MOVS     r0,#0
        0x08000db2:    9001        ..      STR      r0,[sp,#4]
;;;894      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08000db4:    4669        iF      MOV      r1,sp
        0x08000db6:    481a        .H      LDR      r0,[pc,#104] ; [0x8000e20] = 0x40010800
        0x08000db8:    f7fffbbc    ....    BL       LL_GPIO_Init ; 0x8000534
;;;895    
;;;896      /**/
;;;897      GPIO_InitStruct.Pin = MOTOR_X_ENABLE_Pin|MOTOR_Z_DIR_Pin;
        0x08000dbc:    f2482082    H..     MOV      r0,#0x8282
        0x08000dc0:    9000        ..      STR      r0,[sp,#0]
;;;898      GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08000dc2:    2001        .       MOVS     r0,#1
        0x08000dc4:    9001        ..      STR      r0,[sp,#4]
;;;899      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x08000dc6:    2002        .       MOVS     r0,#2
        0x08000dc8:    9002        ..      STR      r0,[sp,#8]
;;;900      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08000dca:    2000        .       MOVS     r0,#0
        0x08000dcc:    9003        ..      STR      r0,[sp,#0xc]
;;;901      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08000dce:    4669        iF      MOV      r1,sp
        0x08000dd0:    4813        .H      LDR      r0,[pc,#76] ; [0x8000e20] = 0x40010800
        0x08000dd2:    f7fffbaf    ....    BL       LL_GPIO_Init ; 0x8000534
;;;902    
;;;903      /**/
;;;904      GPIO_InitStruct.Pin = MOTOR_Z_ENABLE_Pin;
        0x08000dd6:    f2402002    @..     MOV      r0,#0x202
        0x08000dda:    9000        ..      STR      r0,[sp,#0]
;;;905      GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08000ddc:    2001        .       MOVS     r0,#1
        0x08000dde:    9001        ..      STR      r0,[sp,#4]
;;;906      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x08000de0:    2002        .       MOVS     r0,#2
        0x08000de2:    9002        ..      STR      r0,[sp,#8]
;;;907      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08000de4:    2000        .       MOVS     r0,#0
        0x08000de6:    9003        ..      STR      r0,[sp,#0xc]
;;;908      LL_GPIO_Init(MOTOR_Z_ENABLE_GPIO_Port, &GPIO_InitStruct);
        0x08000de8:    4669        iF      MOV      r1,sp
        0x08000dea:    480e        .H      LDR      r0,[pc,#56] ; [0x8000e24] = 0x40010c00
        0x08000dec:    f7fffba2    ....    BL       LL_GPIO_Init ; 0x8000534
;;;909    
;;;910      /**/
;;;911      GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_12|LL_GPIO_PIN_13|LL_GPIO_PIN_14 
        0x08000df0:    480f        .H      LDR      r0,[pc,#60] ; [0x8000e30] = 0x4f23cfe
        0x08000df2:    9000        ..      STR      r0,[sp,#0]
;;;912                              |LL_GPIO_PIN_15|LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_5 
;;;913                              |LL_GPIO_PIN_9;
;;;914      GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x08000df4:    2000        .       MOVS     r0,#0
        0x08000df6:    9001        ..      STR      r0,[sp,#4]
;;;915      LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x08000df8:    4669        iF      MOV      r1,sp
        0x08000dfa:    480a        .H      LDR      r0,[pc,#40] ; [0x8000e24] = 0x40010c00
        0x08000dfc:    f7fffb9a    ....    BL       LL_GPIO_Init ; 0x8000534
;;;916    
;;;917      /**/
;;;918      GPIO_InitStruct.Pin = BUTTON_1_Pin|BUTTON_2_Pin;
        0x08000e00:    480c        .H      LDR      r0,[pc,#48] ; [0x8000e34] = 0x4030003
        0x08000e02:    9000        ..      STR      r0,[sp,#0]
;;;919      GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        0x08000e04:    2008        .       MOVS     r0,#8
        0x08000e06:    9001        ..      STR      r0,[sp,#4]
;;;920      GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
        0x08000e08:    2001        .       MOVS     r0,#1
        0x08000e0a:    9004        ..      STR      r0,[sp,#0x10]
;;;921      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08000e0c:    4669        iF      MOV      r1,sp
        0x08000e0e:    4804        .H      LDR      r0,[pc,#16] ; [0x8000e20] = 0x40010800
        0x08000e10:    f7fffb90    ....    BL       LL_GPIO_Init ; 0x8000534
;;;922    
;;;923    }
        0x08000e14:    b005        ..      ADD      sp,sp,#0x14
        0x08000e16:    bd00        ..      POP      {pc}
    $d
        0x08000e18:    04a000a0    ....    DCD    77594784
        0x08000e1c:    40011000    ...@    DCD    1073811456
        0x08000e20:    40010800    ...@    DCD    1073809408
        0x08000e24:    40010c00    ...@    DCD    1073810432
        0x08000e28:    04400040    @.@.    DCD    71303232
        0x08000e2c:    049c3dbd    .=..    DCD    77348285
        0x08000e30:    04f23cfe    .<..    DCD    82984190
        0x08000e34:    04030003    ....    DCD    67305475
    $t
    i.MX_I2C2_Init
    MX_I2C2_Init
;;; .\../Src/main.c (546)
        0x08000e38:    b530        0.      PUSH     {r4,r5,lr}
        0x08000e3a:    b08b        ..      SUB      sp,sp,#0x2c
;;;547    
;;;548      LL_I2C_InitTypeDef I2C_InitStruct;
;;;549    
;;;550      LL_GPIO_InitTypeDef GPIO_InitStruct;
;;;551    
;;;552      /**I2C2 GPIO Configuration  
;;;553      PB10   ------> I2C2_SCL
;;;554      PB11   ------> I2C2_SDA 
;;;555      */
;;;556      GPIO_InitStruct.Pin = LL_GPIO_PIN_10|LL_GPIO_PIN_11;
        0x08000e3c:    485a        ZH      LDR      r0,[pc,#360] ; [0x8000fa8] = 0x40c000c
        0x08000e3e:    9000        ..      STR      r0,[sp,#0]
;;;557      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x08000e40:    2009        .       MOVS     r0,#9
        0x08000e42:    9001        ..      STR      r0,[sp,#4]
;;;558      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x08000e44:    2003        .       MOVS     r0,#3
        0x08000e46:    9002        ..      STR      r0,[sp,#8]
;;;559      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
        0x08000e48:    2004        .       MOVS     r0,#4
        0x08000e4a:    9003        ..      STR      r0,[sp,#0xc]
;;;560      LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x08000e4c:    4669        iF      MOV      r1,sp
        0x08000e4e:    4857        WH      LDR      r0,[pc,#348] ; [0x8000fac] = 0x40010c00
        0x08000e50:    f7fffb70    ..p.    BL       LL_GPIO_Init ; 0x8000534
;;;561    
;;;562      /* Peripheral clock enable */
;;;563      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_I2C2);
        0x08000e54:    f44f0080    O...    MOV      r0,#0x400000
        0x08000e58:    f7fffafa    ....    BL       LL_APB1_GRP1_EnableClock ; 0x8000450
;;;564    
;;;565      /* I2C2 DMA Init */
;;;566      
;;;567      /* I2C2_TX Init */
;;;568      LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_CHANNEL_4, LL_DMA_DIRECTION_MEMORY_TO_PERIPH);
        0x08000e5c:    4854        TH      LDR      r0,[pc,#336] ; [0x8000fb0] = 0x40020000
        0x08000e5e:    2104        .!      MOVS     r1,#4
        0x08000e60:    2210        ."      MOVS     r2,#0x10
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;571      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
        0x08000e62:    1e4b        K.      SUBS     r3,r1,#1
        0x08000e64:    4c53        SL      LDR      r4,[pc,#332] ; [0x8000fb4] = 0x8003dd0
        0x08000e66:    5ce3        .\      LDRB     r3,[r4,r3]
        0x08000e68:    58c3        .X      LDR      r3,[r0,r3]
        0x08000e6a:    f2440410    D...    MOV      r4,#0x4010
        0x08000e6e:    43a3        .C      BICS     r3,r3,r4
        0x08000e70:    4313        .C      ORRS     r3,r3,r2
        0x08000e72:    1e4c        L.      SUBS     r4,r1,#1
        0x08000e74:    4d4f        OM      LDR      r5,[pc,#316] ; [0x8000fb4] = 0x8003dd0
        0x08000e76:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x08000e78:    5103        .Q      STR      r3,[r0,r4]
;;;572                 DMA_CCR_DIR | DMA_CCR_MEM2MEM, Direction);
;;;573    }
        0x08000e7a:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;570      LL_DMA_SetChannelPriorityLevel(DMA1, LL_DMA_CHANNEL_4, LL_DMA_PRIORITY_LOW);
        0x08000e7c:    2200        ."      MOVS     r2,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;851      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
        0x08000e7e:    1e4b        K.      SUBS     r3,r1,#1
        0x08000e80:    462c        ,F      MOV      r4,r5
        0x08000e82:    5ce3        .\      LDRB     r3,[r4,r3]
        0x08000e84:    58c3        .X      LDR      r3,[r0,r3]
        0x08000e86:    f4235340    #.@S    BIC      r3,r3,#0x3000
        0x08000e8a:    4313        .C      ORRS     r3,r3,r2
        0x08000e8c:    1e4c        L.      SUBS     r4,r1,#1
        0x08000e8e:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x08000e90:    5103        .Q      STR      r3,[r0,r4]
;;;852                 Priority);
;;;853    }
        0x08000e92:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;572      LL_DMA_SetMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MODE_NORMAL);
        0x08000e94:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;620      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
        0x08000e96:    1e4b        K.      SUBS     r3,r1,#1
        0x08000e98:    462c        ,F      MOV      r4,r5
        0x08000e9a:    5ce3        .\      LDRB     r3,[r4,r3]
        0x08000e9c:    58c3        .X      LDR      r3,[r0,r3]
        0x08000e9e:    f0230320    #. .    BIC      r3,r3,#0x20
        0x08000ea2:    4313        .C      ORRS     r3,r3,r2
        0x08000ea4:    1e4c        L.      SUBS     r4,r1,#1
        0x08000ea6:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x08000ea8:    5103        .Q      STR      r3,[r0,r4]
;;;621                 Mode);
;;;622    }
        0x08000eaa:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;574      LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_PERIPH_NOINCREMENT);
        0x08000eac:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;665      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
        0x08000eae:    1e4b        K.      SUBS     r3,r1,#1
        0x08000eb0:    462c        ,F      MOV      r4,r5
        0x08000eb2:    5ce3        .\      LDRB     r3,[r4,r3]
        0x08000eb4:    58c3        .X      LDR      r3,[r0,r3]
        0x08000eb6:    f0230340    #.@.    BIC      r3,r3,#0x40
        0x08000eba:    4313        .C      ORRS     r3,r3,r2
        0x08000ebc:    1e4c        L.      SUBS     r4,r1,#1
        0x08000ebe:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x08000ec0:    5103        .Q      STR      r3,[r0,r4]
;;;666                 PeriphOrM2MSrcIncMode);
;;;667    }
        0x08000ec2:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;576      LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MEMORY_INCREMENT);
        0x08000ec4:    2280        ."      MOVS     r2,#0x80
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;710      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
        0x08000ec6:    1e4b        K.      SUBS     r3,r1,#1
        0x08000ec8:    462c        ,F      MOV      r4,r5
        0x08000eca:    5ce3        .\      LDRB     r3,[r4,r3]
        0x08000ecc:    58c3        .X      LDR      r3,[r0,r3]
        0x08000ece:    f0230380    #...    BIC      r3,r3,#0x80
        0x08000ed2:    4313        .C      ORRS     r3,r3,r2
        0x08000ed4:    1e4c        L.      SUBS     r4,r1,#1
        0x08000ed6:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x08000ed8:    5103        .Q      STR      r3,[r0,r4]
;;;711                 MemoryOrM2MDstIncMode);
;;;712    }
        0x08000eda:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;578      LL_DMA_SetPeriphSize(DMA1, LL_DMA_CHANNEL_4, LL_DMA_PDATAALIGN_BYTE);
        0x08000edc:    2200        ."      MOVS     r2,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;756      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
        0x08000ede:    1e4b        K.      SUBS     r3,r1,#1
        0x08000ee0:    462c        ,F      MOV      r4,r5
        0x08000ee2:    5ce3        .\      LDRB     r3,[r4,r3]
        0x08000ee4:    58c3        .X      LDR      r3,[r0,r3]
        0x08000ee6:    f4237340    #.@s    BIC      r3,r3,#0x300
        0x08000eea:    4313        .C      ORRS     r3,r3,r2
        0x08000eec:    1e4c        L.      SUBS     r4,r1,#1
        0x08000eee:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x08000ef0:    5103        .Q      STR      r3,[r0,r4]
;;;757                 PeriphOrM2MSrcDataSize);
;;;758    }
        0x08000ef2:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;580      LL_DMA_SetMemorySize(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MDATAALIGN_BYTE);
        0x08000ef4:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;803      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
        0x08000ef6:    1e4b        K.      SUBS     r3,r1,#1
        0x08000ef8:    462c        ,F      MOV      r4,r5
        0x08000efa:    5ce3        .\      LDRB     r3,[r4,r3]
        0x08000efc:    58c3        .X      LDR      r3,[r0,r3]
        0x08000efe:    f4236340    #.@c    BIC      r3,r3,#0xc00
        0x08000f02:    4313        .C      ORRS     r3,r3,r2
        0x08000f04:    1e4c        L.      SUBS     r4,r1,#1
        0x08000f06:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x08000f08:    5103        .Q      STR      r3,[r0,r4]
;;;804                 MemoryOrM2MDstDataSize);
;;;805    }
        0x08000f0a:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;583      NVIC_SetPriority(I2C2_EV_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x08000f0c:    f000fa2a    ..*.    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x08000f10:    4605        .F      MOV      r5,r0
        0x08000f12:    2200        ."      MOVS     r2,#0
        0x08000f14:    2102        .!      MOVS     r1,#2
        0x08000f16:    f000fa04    ....    BL       NVIC_EncodePriority ; 0x8001322
        0x08000f1a:    4604        .F      MOV      r4,r0
        0x08000f1c:    4621        !F      MOV      r1,r4
        0x08000f1e:    2021        !       MOVS     r0,#0x21
        0x08000f20:    f000fa28    ..(.    BL       NVIC_SetPriority ; 0x8001374
;;;584      NVIC_EnableIRQ(I2C2_EV_IRQn);
        0x08000f24:    2021        !       MOVS     r0,#0x21
        0x08000f26:    f000f9f1    ....    BL       NVIC_EnableIRQ ; 0x800130c
;;;585      NVIC_SetPriority(I2C2_ER_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x08000f2a:    f000fa1b    ....    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x08000f2e:    4605        .F      MOV      r5,r0
        0x08000f30:    2200        ."      MOVS     r2,#0
        0x08000f32:    2102        .!      MOVS     r1,#2
        0x08000f34:    f000f9f5    ....    BL       NVIC_EncodePriority ; 0x8001322
        0x08000f38:    4604        .F      MOV      r4,r0
        0x08000f3a:    4621        !F      MOV      r1,r4
        0x08000f3c:    2022        "       MOVS     r0,#0x22
        0x08000f3e:    f000fa19    ....    BL       NVIC_SetPriority ; 0x8001374
;;;586      NVIC_EnableIRQ(I2C2_ER_IRQn);
        0x08000f42:    2022        "       MOVS     r0,#0x22
        0x08000f44:    f000f9e2    ....    BL       NVIC_EnableIRQ ; 0x800130c
;;;587    
;;;588        /**I2C Initialization 
;;;589        */
;;;590      LL_I2C_DisableOwnAddress2(I2C2);
        0x08000f48:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;590      CLEAR_BIT(I2Cx->OAR2, I2C_OAR2_ENDUAL);
        0x08000f4a:    481b        .H      LDR      r0,[pc,#108] ; [0x8000fb8] = 0x40005800
        0x08000f4c:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08000f4e:    f0200001     ...    BIC      r0,r0,#1
        0x08000f52:    4919        .I      LDR      r1,[pc,#100] ; [0x8000fb8] = 0x40005800
        0x08000f54:    60c8        .`      STR      r0,[r1,#0xc]
;;;591    }
        0x08000f56:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;592      LL_I2C_DisableGeneralCall(I2C2);
        0x08000f58:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;526      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ENGC);
        0x08000f5a:    4608        .F      MOV      r0,r1
        0x08000f5c:    6800        .h      LDR      r0,[r0,#0]
        0x08000f5e:    f0200040     .@.    BIC      r0,r0,#0x40
        0x08000f62:    6008        .`      STR      r0,[r1,#0]
;;;527    }
        0x08000f64:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;594      LL_I2C_EnableClockStretching(I2C2);
        0x08000f66:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;479      CLEAR_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
        0x08000f68:    4608        .F      MOV      r0,r1
        0x08000f6a:    6800        .h      LDR      r0,[r0,#0]
        0x08000f6c:    f0200080     ...    BIC      r0,r0,#0x80
        0x08000f70:    6008        .`      STR      r0,[r1,#0]
;;;480    }
        0x08000f72:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;596      I2C_InitStruct.PeripheralMode = LL_I2C_MODE_I2C;
        0x08000f74:    2000        .       MOVS     r0,#0
        0x08000f76:    9005        ..      STR      r0,[sp,#0x14]
;;;597      I2C_InitStruct.ClockSpeed = 400000;
        0x08000f78:    4810        .H      LDR      r0,[pc,#64] ; [0x8000fbc] = 0x61a80
        0x08000f7a:    9006        ..      STR      r0,[sp,#0x18]
;;;598      I2C_InitStruct.DutyCycle = LL_I2C_DUTYCYCLE_2;
        0x08000f7c:    2000        .       MOVS     r0,#0
        0x08000f7e:    9007        ..      STR      r0,[sp,#0x1c]
;;;599      I2C_InitStruct.OwnAddress1 = 0;
        0x08000f80:    9008        ..      STR      r0,[sp,#0x20]
;;;600      I2C_InitStruct.TypeAcknowledge = LL_I2C_ACK;
        0x08000f82:    1508        ..      ASRS     r0,r1,#20
        0x08000f84:    9009        ..      STR      r0,[sp,#0x24]
;;;601      I2C_InitStruct.OwnAddrSize = LL_I2C_OWNADDRESS1_7BIT;
        0x08000f86:    0100        ..      LSLS     r0,r0,#4
        0x08000f88:    900a        ..      STR      r0,[sp,#0x28]
;;;602      LL_I2C_Init(I2C2, &I2C_InitStruct);
        0x08000f8a:    a905        ..      ADD      r1,sp,#0x14
        0x08000f8c:    480a        .H      LDR      r0,[pc,#40] ; [0x8000fb8] = 0x40005800
        0x08000f8e:    f7fffbdc    ....    BL       LL_I2C_Init ; 0x800074a
;;;603    
;;;604      LL_I2C_SetOwnAddress2(I2C2, 0);
        0x08000f92:    2000        .       MOVS     r0,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;568      MODIFY_REG(I2Cx->OAR2, I2C_OAR2_ADD2, OwnAddress2);
        0x08000f94:    4908        .I      LDR      r1,[pc,#32] ; [0x8000fb8] = 0x40005800
        0x08000f96:    68c9        .h      LDR      r1,[r1,#0xc]
        0x08000f98:    f02101fe    !...    BIC      r1,r1,#0xfe
        0x08000f9c:    4301        .C      ORRS     r1,r1,r0
        0x08000f9e:    4a06        .J      LDR      r2,[pc,#24] ; [0x8000fb8] = 0x40005800
        0x08000fa0:    60d1        .`      STR      r1,[r2,#0xc]
;;;569    }
        0x08000fa2:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;606    }
        0x08000fa4:    b00b        ..      ADD      sp,sp,#0x2c
        0x08000fa6:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x08000fa8:    040c000c    ....    DCD    67895308
        0x08000fac:    40010c00    ...@    DCD    1073810432
        0x08000fb0:    40020000    ...@    DCD    1073872896
        0x08000fb4:    08003dd0    .=..    DCD    134233552
        0x08000fb8:    40005800    .X.@    DCD    1073764352
        0x08000fbc:    00061a80    ....    DCD    400000
    $t
    i.MX_TIM1_Init
    MX_TIM1_Init
;;;607    
;;;608    /* TIM1 init function */
;;;609    static void MX_TIM1_Init(void)
;;;610    {
        0x08000fc0:    b530        0.      PUSH     {r4,r5,lr}
        0x08000fc2:    b093        ..      SUB      sp,sp,#0x4c
;;;611    
;;;612      LL_TIM_InitTypeDef TIM_InitStruct;
;;;613      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct;
;;;614      LL_TIM_BDTR_InitTypeDef TIM_BDTRInitStruct;
;;;615    
;;;616      /* Peripheral clock enable */
;;;617      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM1);
        0x08000fc4:    f44f6000    O..`    MOV      r0,#0x800
        0x08000fc8:    f7fffa50    ..P.    BL       LL_APB2_GRP1_EnableClock ; 0x800046c
;;;618    
;;;619      /* TIM1 interrupt Init */
;;;620      NVIC_SetPriority(TIM1_UP_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),15, 0));
        0x08000fcc:    f000f9ca    ....    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x08000fd0:    4605        .F      MOV      r5,r0
        0x08000fd2:    2200        ."      MOVS     r2,#0
        0x08000fd4:    210f        .!      MOVS     r1,#0xf
        0x08000fd6:    f000f9a4    ....    BL       NVIC_EncodePriority ; 0x8001322
        0x08000fda:    4604        .F      MOV      r4,r0
        0x08000fdc:    4621        !F      MOV      r1,r4
        0x08000fde:    2019        .       MOVS     r0,#0x19
        0x08000fe0:    f000f9c8    ....    BL       NVIC_SetPriority ; 0x8001374
;;;621      NVIC_EnableIRQ(TIM1_UP_IRQn);
        0x08000fe4:    2019        .       MOVS     r0,#0x19
        0x08000fe6:    f000f991    ....    BL       NVIC_EnableIRQ ; 0x800130c
;;;622    
;;;623      TIM_InitStruct.Prescaler = 720;
        0x08000fea:    f44f7034    O.4p    MOV      r0,#0x2d0
        0x08000fee:    f8ad0038    ..8.    STRH     r0,[sp,#0x38]
;;;624      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x08000ff2:    2000        .       MOVS     r0,#0
        0x08000ff4:    900f        ..      STR      r0,[sp,#0x3c]
;;;625      TIM_InitStruct.Autoreload = 0;
        0x08000ff6:    9010        ..      STR      r0,[sp,#0x40]
;;;626      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08000ff8:    9011        ..      STR      r0,[sp,#0x44]
;;;627      TIM_InitStruct.RepetitionCounter = 0;
        0x08000ffa:    f88d0048    ..H.    STRB     r0,[sp,#0x48]
;;;628      LL_TIM_Init(TIM1, &TIM_InitStruct);
        0x08000ffe:    a90e        ..      ADD      r1,sp,#0x38
        0x08001000:    481d        .H      LDR      r0,[pc,#116] ; [0x8001078] = 0x40012c00
        0x08001002:    f7fffd89    ....    BL       LL_TIM_Init ; 0x8000b18
;;;629    
;;;630      LL_TIM_DisableARRPreload(TIM1);
        0x08001006:    481c        .H      LDR      r0,[pc,#112] ; [0x8001078] = 0x40012c00
        0x08001008:    f7fffca9    ....    BL       LL_TIM_DisableARRPreload ; 0x800095e
;;;631    
;;;632      LL_TIM_SetClockSource(TIM1, LL_TIM_CLOCKSOURCE_INTERNAL);
        0x0800100c:    2100        .!      MOVS     r1,#0
        0x0800100e:    481a        .H      LDR      r0,[pc,#104] ; [0x8001078] = 0x40012c00
        0x08001010:    f7fffe5a    ..Z.    BL       LL_TIM_SetClockSource ; 0x8000cc8
;;;633    
;;;634      LL_TIM_OC_EnablePreload(TIM1, LL_TIM_CHANNEL_CH1);
        0x08001014:    2101        .!      MOVS     r1,#1
        0x08001016:    4818        .H      LDR      r0,[pc,#96] ; [0x8001078] = 0x40012c00
        0x08001018:    f7fffdf6    ....    BL       LL_TIM_OC_EnablePreload ; 0x8000c08
;;;635    
;;;636      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM1;
        0x0800101c:    2060        `       MOVS     r0,#0x60
        0x0800101e:    9006        ..      STR      r0,[sp,#0x18]
;;;637      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08001020:    2000        .       MOVS     r0,#0
        0x08001022:    9007        ..      STR      r0,[sp,#0x1c]
;;;638      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x08001024:    9008        ..      STR      r0,[sp,#0x20]
;;;639      TIM_OC_InitStruct.CompareValue = 0;
        0x08001026:    9009        ..      STR      r0,[sp,#0x24]
;;;640      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08001028:    900a        ..      STR      r0,[sp,#0x28]
;;;641      TIM_OC_InitStruct.OCNPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x0800102a:    900b        ..      STR      r0,[sp,#0x2c]
;;;642      TIM_OC_InitStruct.OCIdleState = LL_TIM_OCIDLESTATE_LOW;
        0x0800102c:    900c        ..      STR      r0,[sp,#0x30]
;;;643      TIM_OC_InitStruct.OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
        0x0800102e:    900d        ..      STR      r0,[sp,#0x34]
;;;644      LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x08001030:    aa06        ..      ADD      r2,sp,#0x18
        0x08001032:    2101        .!      MOVS     r1,#1
        0x08001034:    4810        .H      LDR      r0,[pc,#64] ; [0x8001078] = 0x40012c00
        0x08001036:    f7fffe17    ....    BL       LL_TIM_OC_Init ; 0x8000c68
;;;645    
;;;646      LL_TIM_OC_DisableFast(TIM1, LL_TIM_CHANNEL_CH1);
        0x0800103a:    2101        .!      MOVS     r1,#1
        0x0800103c:    480e        .H      LDR      r0,[pc,#56] ; [0x8001078] = 0x40012c00
        0x0800103e:    f7fffdb3    ....    BL       LL_TIM_OC_DisableFast ; 0x8000ba8
;;;647    
;;;648      LL_TIM_SetTriggerOutput(TIM1, LL_TIM_TRGO_RESET);
        0x08001042:    2100        .!      MOVS     r1,#0
        0x08001044:    480c        .H      LDR      r0,[pc,#48] ; [0x8001078] = 0x40012c00
        0x08001046:    f7fffe46    ..F.    BL       LL_TIM_SetTriggerOutput ; 0x8000cd6
;;;649    
;;;650      LL_TIM_DisableMasterSlaveMode(TIM1);
        0x0800104a:    480b        .H      LDR      r0,[pc,#44] ; [0x8001078] = 0x40012c00
        0x0800104c:    f7fffc8c    ....    BL       LL_TIM_DisableMasterSlaveMode ; 0x8000968
;;;651    
;;;652      TIM_BDTRInitStruct.OSSRState = LL_TIM_OSSR_DISABLE;
        0x08001050:    2000        .       MOVS     r0,#0
        0x08001052:    9000        ..      STR      r0,[sp,#0]
;;;653      TIM_BDTRInitStruct.OSSIState = LL_TIM_OSSI_DISABLE;
        0x08001054:    9001        ..      STR      r0,[sp,#4]
;;;654      TIM_BDTRInitStruct.LockLevel = LL_TIM_LOCKLEVEL_OFF;
        0x08001056:    9002        ..      STR      r0,[sp,#8]
;;;655      TIM_BDTRInitStruct.DeadTime = 0;
        0x08001058:    f88d000c    ....    STRB     r0,[sp,#0xc]
;;;656      TIM_BDTRInitStruct.BreakState = LL_TIM_BREAK_DISABLE;
        0x0800105c:    f8ad000e    ....    STRH     r0,[sp,#0xe]
;;;657      TIM_BDTRInitStruct.BreakPolarity = LL_TIM_BREAK_POLARITY_HIGH;
        0x08001060:    f44f5000    O..P    MOV      r0,#0x2000
        0x08001064:    9004        ..      STR      r0,[sp,#0x10]
;;;658      TIM_BDTRInitStruct.AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
        0x08001066:    2000        .       MOVS     r0,#0
        0x08001068:    9005        ..      STR      r0,[sp,#0x14]
;;;659      LL_TIM_BDTR_Init(TIM1, &TIM_BDTRInitStruct);
        0x0800106a:    4669        iF      MOV      r1,sp
        0x0800106c:    4802        .H      LDR      r0,[pc,#8] ; [0x8001078] = 0x40012c00
        0x0800106e:    f7fffc4d    ..M.    BL       LL_TIM_BDTR_Init ; 0x800090c
;;;660    
;;;661    }
        0x08001072:    b013        ..      ADD      sp,sp,#0x4c
        0x08001074:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x08001076:    0000        ..      DCW    0
        0x08001078:    40012c00    .,.@    DCD    1073818624
    $t
    i.MX_TIM2_Init
    MX_TIM2_Init
;;;662    
;;;663    /* TIM2 init function */
;;;664    static void MX_TIM2_Init(void)
;;;665    {
        0x0800107c:    b530        0.      PUSH     {r4,r5,lr}
        0x0800107e:    b08d        ..      SUB      sp,sp,#0x34
;;;666    
;;;667      LL_TIM_InitTypeDef TIM_InitStruct;
;;;668      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct;
;;;669    
;;;670      /* Peripheral clock enable */
;;;671      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM2);
        0x08001080:    2001        .       MOVS     r0,#1
        0x08001082:    f7fff9e5    ....    BL       LL_APB1_GRP1_EnableClock ; 0x8000450
;;;672    
;;;673      /* TIM2 interrupt Init */
;;;674      NVIC_SetPriority(TIM2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),15, 0));
        0x08001086:    f000f96d    ..m.    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x0800108a:    4605        .F      MOV      r5,r0
        0x0800108c:    2200        ."      MOVS     r2,#0
        0x0800108e:    210f        .!      MOVS     r1,#0xf
        0x08001090:    f000f947    ..G.    BL       NVIC_EncodePriority ; 0x8001322
        0x08001094:    4604        .F      MOV      r4,r0
        0x08001096:    4621        !F      MOV      r1,r4
        0x08001098:    201c        .       MOVS     r0,#0x1c
        0x0800109a:    f000f96b    ..k.    BL       NVIC_SetPriority ; 0x8001374
;;;675      NVIC_EnableIRQ(TIM2_IRQn);
        0x0800109e:    201c        .       MOVS     r0,#0x1c
        0x080010a0:    f000f934    ..4.    BL       NVIC_EnableIRQ ; 0x800130c
;;;676    
;;;677      TIM_InitStruct.Prescaler = 720;
        0x080010a4:    f44f7034    O.4p    MOV      r0,#0x2d0
        0x080010a8:    f8ad0020    .. .    STRH     r0,[sp,#0x20]
;;;678      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x080010ac:    2000        .       MOVS     r0,#0
        0x080010ae:    9009        ..      STR      r0,[sp,#0x24]
;;;679      TIM_InitStruct.Autoreload = 0;
        0x080010b0:    900a        ..      STR      r0,[sp,#0x28]
;;;680      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x080010b2:    900b        ..      STR      r0,[sp,#0x2c]
;;;681      LL_TIM_Init(TIM2, &TIM_InitStruct);
        0x080010b4:    a908        ..      ADD      r1,sp,#0x20
        0x080010b6:    f04f4080    O..@    MOV      r0,#0x40000000
        0x080010ba:    f7fffd2d    ..-.    BL       LL_TIM_Init ; 0x8000b18
;;;682    
;;;683      LL_TIM_EnableARRPreload(TIM2);
        0x080010be:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1195     SET_BIT(TIMx->CR1, TIM_CR1_ARPE);
        0x080010c0:    f04f4080    O..@    MOV      r0,#0x40000000
        0x080010c4:    6800        .h      LDR      r0,[r0,#0]
        0x080010c6:    f0400080    @...    ORR      r0,r0,#0x80
        0x080010ca:    f04f4180    O..A    MOV      r1,#0x40000000
        0x080010ce:    6008        .`      STR      r0,[r1,#0]
;;;1196   }
        0x080010d0:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;685      LL_TIM_SetClockSource(TIM2, LL_TIM_CLOCKSOURCE_INTERNAL);
        0x080010d2:    2100        .!      MOVS     r1,#0
        0x080010d4:    f04f4080    O..@    MOV      r0,#0x40000000
        0x080010d8:    f7fffdf6    ....    BL       LL_TIM_SetClockSource ; 0x8000cc8
;;;686    
;;;687      LL_TIM_OC_EnablePreload(TIM2, LL_TIM_CHANNEL_CH1);
        0x080010dc:    2101        .!      MOVS     r1,#1
        0x080010de:    0788        ..      LSLS     r0,r1,#30
        0x080010e0:    f7fffd92    ....    BL       LL_TIM_OC_EnablePreload ; 0x8000c08
;;;688    
;;;689      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM1;
        0x080010e4:    2060        `       MOVS     r0,#0x60
        0x080010e6:    9000        ..      STR      r0,[sp,#0]
;;;690      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x080010e8:    2000        .       MOVS     r0,#0
        0x080010ea:    9001        ..      STR      r0,[sp,#4]
;;;691      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x080010ec:    9002        ..      STR      r0,[sp,#8]
;;;692      TIM_OC_InitStruct.CompareValue = 0;
        0x080010ee:    9003        ..      STR      r0,[sp,#0xc]
;;;693      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x080010f0:    9004        ..      STR      r0,[sp,#0x10]
;;;694      LL_TIM_OC_Init(TIM2, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x080010f2:    466a        jF      MOV      r2,sp
        0x080010f4:    2101        .!      MOVS     r1,#1
        0x080010f6:    0788        ..      LSLS     r0,r1,#30
        0x080010f8:    f7fffdb6    ....    BL       LL_TIM_OC_Init ; 0x8000c68
;;;695    
;;;696      LL_TIM_OC_DisableFast(TIM2, LL_TIM_CHANNEL_CH1);
        0x080010fc:    2101        .!      MOVS     r1,#1
        0x080010fe:    0788        ..      LSLS     r0,r1,#30
        0x08001100:    f7fffd52    ..R.    BL       LL_TIM_OC_DisableFast ; 0x8000ba8
;;;697    
;;;698      LL_TIM_SetTriggerOutput(TIM2, LL_TIM_TRGO_RESET);
        0x08001104:    2100        .!      MOVS     r1,#0
        0x08001106:    f04f4080    O..@    MOV      r0,#0x40000000
        0x0800110a:    f7fffde4    ....    BL       LL_TIM_SetTriggerOutput ; 0x8000cd6
;;;699    
;;;700      LL_TIM_DisableMasterSlaveMode(TIM2);
        0x0800110e:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08001112:    f7fffc29    ..).    BL       LL_TIM_DisableMasterSlaveMode ; 0x8000968
;;;701    
;;;702    }
        0x08001116:    b00d        ..      ADD      sp,sp,#0x34
        0x08001118:    bd30        0.      POP      {r4,r5,pc}
        0x0800111a:    0000        ..      MOVS     r0,r0
    i.MX_TIM3_Init
    MX_TIM3_Init
;;;703    
;;;704    /* TIM3 init function */
;;;705    static void MX_TIM3_Init(void)
;;;706    {
        0x0800111c:    b500        ..      PUSH     {lr}
        0x0800111e:    b093        ..      SUB      sp,sp,#0x4c
;;;707    
;;;708      LL_TIM_InitTypeDef TIM_InitStruct;
;;;709      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct;
;;;710    
;;;711      LL_GPIO_InitTypeDef GPIO_InitStruct;
;;;712    
;;;713      /* Peripheral clock enable */
;;;714      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM3);
        0x08001120:    2002        .       MOVS     r0,#2
        0x08001122:    f7fff995    ....    BL       LL_APB1_GRP1_EnableClock ; 0x8000450
;;;715    
;;;716      TIM_InitStruct.Prescaler = 0;
        0x08001126:    2000        .       MOVS     r0,#0
        0x08001128:    f8ad0038    ..8.    STRH     r0,[sp,#0x38]
;;;717      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x0800112c:    900f        ..      STR      r0,[sp,#0x3c]
;;;718      TIM_InitStruct.Autoreload = min_pulse;
        0x0800112e:    2091        .       MOVS     r0,#0x91
        0x08001130:    9010        ..      STR      r0,[sp,#0x40]
;;;719      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08001132:    2000        .       MOVS     r0,#0
        0x08001134:    9011        ..      STR      r0,[sp,#0x44]
;;;720      LL_TIM_Init(TIM3, &TIM_InitStruct);
        0x08001136:    a90e        ..      ADD      r1,sp,#0x38
        0x08001138:    482c        ,H      LDR      r0,[pc,#176] ; [0x80011ec] = 0x40000400
        0x0800113a:    f7fffced    ....    BL       LL_TIM_Init ; 0x8000b18
;;;721    
;;;722      LL_TIM_DisableARRPreload(TIM3);
        0x0800113e:    482b        +H      LDR      r0,[pc,#172] ; [0x80011ec] = 0x40000400
        0x08001140:    f7fffc0d    ....    BL       LL_TIM_DisableARRPreload ; 0x800095e
;;;723    
;;;724      LL_TIM_OC_EnablePreload(TIM3, LL_TIM_CHANNEL_CH1);
        0x08001144:    2101        .!      MOVS     r1,#1
        0x08001146:    4829        )H      LDR      r0,[pc,#164] ; [0x80011ec] = 0x40000400
        0x08001148:    f7fffd5e    ..^.    BL       LL_TIM_OC_EnablePreload ; 0x8000c08
;;;725    
;;;726      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM2;
        0x0800114c:    2070        p       MOVS     r0,#0x70
        0x0800114e:    9006        ..      STR      r0,[sp,#0x18]
;;;727      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08001150:    2000        .       MOVS     r0,#0
        0x08001152:    9007        ..      STR      r0,[sp,#0x1c]
;;;728      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x08001154:    9008        ..      STR      r0,[sp,#0x20]
;;;729      TIM_OC_InitStruct.CompareValue = 0;
        0x08001156:    9009        ..      STR      r0,[sp,#0x24]
;;;730      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08001158:    900a        ..      STR      r0,[sp,#0x28]
;;;731      LL_TIM_OC_Init(TIM3, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x0800115a:    aa06        ..      ADD      r2,sp,#0x18
        0x0800115c:    2101        .!      MOVS     r1,#1
        0x0800115e:    4823        #H      LDR      r0,[pc,#140] ; [0x80011ec] = 0x40000400
        0x08001160:    f7fffd82    ....    BL       LL_TIM_OC_Init ; 0x8000c68
;;;732    
;;;733      LL_TIM_OC_DisableFast(TIM3, LL_TIM_CHANNEL_CH1);
        0x08001164:    2101        .!      MOVS     r1,#1
        0x08001166:    4821        !H      LDR      r0,[pc,#132] ; [0x80011ec] = 0x40000400
        0x08001168:    f7fffd1e    ....    BL       LL_TIM_OC_DisableFast ; 0x8000ba8
;;;734    
;;;735      LL_TIM_OC_EnablePreload(TIM3, LL_TIM_CHANNEL_CH3);
        0x0800116c:    f44f7180    O..q    MOV      r1,#0x100
        0x08001170:    481e        .H      LDR      r0,[pc,#120] ; [0x80011ec] = 0x40000400
        0x08001172:    f7fffd49    ..I.    BL       LL_TIM_OC_EnablePreload ; 0x8000c08
;;;736    
;;;737      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08001176:    2000        .       MOVS     r0,#0
        0x08001178:    9007        ..      STR      r0,[sp,#0x1c]
;;;738      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x0800117a:    9008        ..      STR      r0,[sp,#0x20]
;;;739      LL_TIM_OC_Init(TIM3, LL_TIM_CHANNEL_CH3, &TIM_OC_InitStruct);
        0x0800117c:    aa06        ..      ADD      r2,sp,#0x18
        0x0800117e:    f44f7180    O..q    MOV      r1,#0x100
        0x08001182:    481a        .H      LDR      r0,[pc,#104] ; [0x80011ec] = 0x40000400
        0x08001184:    f7fffd70    ..p.    BL       LL_TIM_OC_Init ; 0x8000c68
;;;740    
;;;741      LL_TIM_OC_DisableFast(TIM3, LL_TIM_CHANNEL_CH3);
        0x08001188:    f44f7180    O..q    MOV      r1,#0x100
        0x0800118c:    4817        .H      LDR      r0,[pc,#92] ; [0x80011ec] = 0x40000400
        0x0800118e:    f7fffd0b    ....    BL       LL_TIM_OC_DisableFast ; 0x8000ba8
;;;742    
;;;743      LL_TIM_SetOnePulseMode(TIM3, LL_TIM_ONEPULSEMODE_SINGLE);
        0x08001192:    2008        .       MOVS     r0,#8
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1130     MODIFY_REG(TIMx->CR1, TIM_CR1_OPM, OnePulseMode);
        0x08001194:    4915        .I      LDR      r1,[pc,#84] ; [0x80011ec] = 0x40000400
        0x08001196:    6809        .h      LDR      r1,[r1,#0]
        0x08001198:    f0210108    !...    BIC      r1,r1,#8
        0x0800119c:    4301        .C      ORRS     r1,r1,r0
        0x0800119e:    4a13        .J      LDR      r2,[pc,#76] ; [0x80011ec] = 0x40000400
        0x080011a0:    6011        .`      STR      r1,[r2,#0]
;;;1131   }
        0x080011a2:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;745      LL_TIM_SetTriggerOutput(TIM3, LL_TIM_TRGO_RESET);
        0x080011a4:    2100        .!      MOVS     r1,#0
        0x080011a6:    4610        .F      MOV      r0,r2
        0x080011a8:    f7fffd95    ....    BL       LL_TIM_SetTriggerOutput ; 0x8000cd6
;;;746    
;;;747      LL_TIM_DisableMasterSlaveMode(TIM3);
        0x080011ac:    480f        .H      LDR      r0,[pc,#60] ; [0x80011ec] = 0x40000400
        0x080011ae:    f7fffbdb    ....    BL       LL_TIM_DisableMasterSlaveMode ; 0x8000968
;;;748    
;;;749      /**TIM3 GPIO Configuration  
;;;750      PA6   ------> TIM3_CH1
;;;751      PB0   ------> TIM3_CH3 
;;;752      */
;;;753      GPIO_InitStruct.Pin = MOTOR_X_STEP_Pin;
        0x080011b2:    f2440040    D.@.    MOV      r0,#0x4040
        0x080011b6:    9001        ..      STR      r0,[sp,#4]
;;;754      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x080011b8:    2009        .       MOVS     r0,#9
        0x080011ba:    9002        ..      STR      r0,[sp,#8]
;;;755      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x080011bc:    2003        .       MOVS     r0,#3
        0x080011be:    9003        ..      STR      r0,[sp,#0xc]
;;;756      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x080011c0:    2000        .       MOVS     r0,#0
        0x080011c2:    9004        ..      STR      r0,[sp,#0x10]
;;;757      LL_GPIO_Init(MOTOR_X_STEP_GPIO_Port, &GPIO_InitStruct);
        0x080011c4:    a901        ..      ADD      r1,sp,#4
        0x080011c6:    480a        .H      LDR      r0,[pc,#40] ; [0x80011f0] = 0x40010800
        0x080011c8:    f7fff9b4    ....    BL       LL_GPIO_Init ; 0x8000534
;;;758    
;;;759      GPIO_InitStruct.Pin = MOTOR_Z_STEP_Pin;
        0x080011cc:    f2401001    @...    MOV      r0,#0x101
        0x080011d0:    9001        ..      STR      r0,[sp,#4]
;;;760      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x080011d2:    2009        .       MOVS     r0,#9
        0x080011d4:    9002        ..      STR      r0,[sp,#8]
;;;761      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x080011d6:    2003        .       MOVS     r0,#3
        0x080011d8:    9003        ..      STR      r0,[sp,#0xc]
;;;762      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x080011da:    2000        .       MOVS     r0,#0
        0x080011dc:    9004        ..      STR      r0,[sp,#0x10]
;;;763      LL_GPIO_Init(MOTOR_Z_STEP_GPIO_Port, &GPIO_InitStruct);
        0x080011de:    a901        ..      ADD      r1,sp,#4
        0x080011e0:    4804        .H      LDR      r0,[pc,#16] ; [0x80011f4] = 0x40010c00
        0x080011e2:    f7fff9a7    ....    BL       LL_GPIO_Init ; 0x8000534
;;;764    
;;;765    }
        0x080011e6:    b013        ..      ADD      sp,sp,#0x4c
        0x080011e8:    bd00        ..      POP      {pc}
    $d
        0x080011ea:    0000        ..      DCW    0
        0x080011ec:    40000400    ...@    DCD    1073742848
        0x080011f0:    40010800    ...@    DCD    1073809408
        0x080011f4:    40010c00    ...@    DCD    1073810432
    $t
    i.MX_TIM4_Init
    MX_TIM4_Init
;;;766    
;;;767    /* TIM4 init function */
;;;768    static void MX_TIM4_Init(void)
;;;769    {
        0x080011f8:    b530        0.      PUSH     {r4,r5,lr}
        0x080011fa:    b08b        ..      SUB      sp,sp,#0x2c
;;;770    
;;;771      LL_TIM_InitTypeDef TIM_InitStruct;
;;;772    
;;;773      LL_GPIO_InitTypeDef GPIO_InitStruct;
;;;774    
;;;775      /* Peripheral clock enable */
;;;776      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM4);
        0x080011fc:    2004        .       MOVS     r0,#4
        0x080011fe:    f7fff927    ..'.    BL       LL_APB1_GRP1_EnableClock ; 0x8000450
;;;777      
;;;778      /**TIM4 GPIO Configuration  
;;;779      PB6   ------> TIM4_CH1
;;;780      PB7   ------> TIM4_CH2
;;;781      PB8   ------> TIM4_CH3 
;;;782      */
;;;783      GPIO_InitStruct.Pin = ENC_A_Pin|ENC_B_Pin|ENC_ZERO_Pin;
        0x08001202:    483f        ?H      LDR      r0,[pc,#252] ; [0x8001300] = 0x401c0c1
        0x08001204:    9001        ..      STR      r0,[sp,#4]
;;;784      GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        0x08001206:    2008        .       MOVS     r0,#8
        0x08001208:    9002        ..      STR      r0,[sp,#8]
;;;785      GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
        0x0800120a:    2001        .       MOVS     r0,#1
        0x0800120c:    9005        ..      STR      r0,[sp,#0x14]
;;;786      LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x0800120e:    a901        ..      ADD      r1,sp,#4
        0x08001210:    483c        <H      LDR      r0,[pc,#240] ; [0x8001304] = 0x40010c00
        0x08001212:    f7fff98f    ....    BL       LL_GPIO_Init ; 0x8000534
;;;787    
;;;788      /* TIM4 interrupt Init */
;;;789      NVIC_SetPriority(TIM4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x08001216:    f000f8a5    ....    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x0800121a:    4605        .F      MOV      r5,r0
        0x0800121c:    2200        ."      MOVS     r2,#0
        0x0800121e:    4611        .F      MOV      r1,r2
        0x08001220:    f000f87f    ....    BL       NVIC_EncodePriority ; 0x8001322
        0x08001224:    4604        .F      MOV      r4,r0
        0x08001226:    4621        !F      MOV      r1,r4
        0x08001228:    201e        .       MOVS     r0,#0x1e
        0x0800122a:    f000f8a3    ....    BL       NVIC_SetPriority ; 0x8001374
;;;790      NVIC_EnableIRQ(TIM4_IRQn);
        0x0800122e:    201e        .       MOVS     r0,#0x1e
        0x08001230:    f000f86c    ..l.    BL       NVIC_EnableIRQ ; 0x800130c
;;;791    
;;;792      TIM_InitStruct.Prescaler = 0;
        0x08001234:    2000        .       MOVS     r0,#0
        0x08001236:    f8ad0018    ....    STRH     r0,[sp,#0x18]
;;;793      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x0800123a:    9007        ..      STR      r0,[sp,#0x1c]
;;;794      TIM_InitStruct.Autoreload = 8;
        0x0800123c:    2008        .       MOVS     r0,#8
        0x0800123e:    9008        ..      STR      r0,[sp,#0x20]
;;;795      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08001240:    2000        .       MOVS     r0,#0
        0x08001242:    9009        ..      STR      r0,[sp,#0x24]
;;;796      LL_TIM_Init(TIM4, &TIM_InitStruct);
        0x08001244:    a906        ..      ADD      r1,sp,#0x18
        0x08001246:    4830        0H      LDR      r0,[pc,#192] ; [0x8001308] = 0x40000800
        0x08001248:    f7fffc66    ..f.    BL       LL_TIM_Init ; 0x8000b18
;;;797    
;;;798      LL_TIM_DisableARRPreload(TIM4);
        0x0800124c:    482e        .H      LDR      r0,[pc,#184] ; [0x8001308] = 0x40000800
        0x0800124e:    f7fffb86    ....    BL       LL_TIM_DisableARRPreload ; 0x800095e
;;;799    
;;;800      LL_TIM_SetEncoderMode(TIM4, LL_TIM_ENCODERMODE_X2_TI1);
        0x08001252:    2001        .       MOVS     r0,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2546     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
        0x08001254:    492c        ,I      LDR      r1,[pc,#176] ; [0x8001308] = 0x40000800
        0x08001256:    6889        .h      LDR      r1,[r1,#8]
        0x08001258:    f0210107    !...    BIC      r1,r1,#7
        0x0800125c:    4301        .C      ORRS     r1,r1,r0
        0x0800125e:    4a2a        *J      LDR      r2,[pc,#168] ; [0x8001308] = 0x40000800
        0x08001260:    6091        .`      STR      r1,[r2,#8]
;;;2547   }
        0x08001262:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;802      LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x08001264:    0402        ..      LSLS     r2,r0,#16
        0x08001266:    2101        .!      MOVS     r1,#1
        0x08001268:    4827        'H      LDR      r0,[pc,#156] ; [0x8001308] = 0x40000800
        0x0800126a:    f7fffb87    ....    BL       LL_TIM_IC_SetActiveInput ; 0x800097c
;;;803    
;;;804      LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_ICPSC_DIV1);
        0x0800126e:    2200        ."      MOVS     r2,#0
        0x08001270:    2101        .!      MOVS     r1,#1
        0x08001272:    4825        %H      LDR      r0,[pc,#148] ; [0x8001308] = 0x40000800
        0x08001274:    f7fffc1a    ....    BL       LL_TIM_IC_SetPrescaler ; 0x8000aac
;;;805    
;;;806      LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_IC_FILTER_FDIV32_N8);
        0x08001278:    f44f0270    O.p.    MOV      r2,#0xf00000
        0x0800127c:    2101        .!      MOVS     r1,#1
        0x0800127e:    4822        "H      LDR      r0,[pc,#136] ; [0x8001308] = 0x40000800
        0x08001280:    f7fffbb2    ....    BL       LL_TIM_IC_SetFilter ; 0x80009e8
;;;807    
;;;808      LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_IC_POLARITY_RISING);
        0x08001284:    2200        ."      MOVS     r2,#0
        0x08001286:    2101        .!      MOVS     r1,#1
        0x08001288:    481f        .H      LDR      r0,[pc,#124] ; [0x8001308] = 0x40000800
        0x0800128a:    f7fffbe3    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000a54
;;;809    
;;;810      LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x0800128e:    f44f3280    O..2    MOV      r2,#0x10000
        0x08001292:    2110        .!      MOVS     r1,#0x10
        0x08001294:    481c        .H      LDR      r0,[pc,#112] ; [0x8001308] = 0x40000800
        0x08001296:    f7fffb71    ..q.    BL       LL_TIM_IC_SetActiveInput ; 0x800097c
;;;811    
;;;812      LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_ICPSC_DIV1);
        0x0800129a:    2200        ."      MOVS     r2,#0
        0x0800129c:    2110        .!      MOVS     r1,#0x10
        0x0800129e:    481a        .H      LDR      r0,[pc,#104] ; [0x8001308] = 0x40000800
        0x080012a0:    f7fffc04    ....    BL       LL_TIM_IC_SetPrescaler ; 0x8000aac
;;;813    
;;;814      LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_IC_FILTER_FDIV32_N8);
        0x080012a4:    f44f0270    O.p.    MOV      r2,#0xf00000
        0x080012a8:    2110        .!      MOVS     r1,#0x10
        0x080012aa:    4817        .H      LDR      r0,[pc,#92] ; [0x8001308] = 0x40000800
        0x080012ac:    f7fffb9c    ....    BL       LL_TIM_IC_SetFilter ; 0x80009e8
;;;815    
;;;816      LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_IC_POLARITY_RISING);
        0x080012b0:    2200        ."      MOVS     r2,#0
        0x080012b2:    2110        .!      MOVS     r1,#0x10
        0x080012b4:    4814        .H      LDR      r0,[pc,#80] ; [0x8001308] = 0x40000800
        0x080012b6:    f7fffbcd    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000a54
;;;817    
;;;818      LL_TIM_SetTriggerOutput(TIM4, LL_TIM_TRGO_RESET);
        0x080012ba:    2100        .!      MOVS     r1,#0
        0x080012bc:    4812        .H      LDR      r0,[pc,#72] ; [0x8001308] = 0x40000800
        0x080012be:    f7fffd0a    ....    BL       LL_TIM_SetTriggerOutput ; 0x8000cd6
;;;819    
;;;820      LL_TIM_DisableMasterSlaveMode(TIM4);
        0x080012c2:    4811        .H      LDR      r0,[pc,#68] ; [0x8001308] = 0x40000800
        0x080012c4:    f7fffb50    ..P.    BL       LL_TIM_DisableMasterSlaveMode ; 0x8000968
;;;821    
;;;822      LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x080012c8:    f44f3280    O..2    MOV      r2,#0x10000
        0x080012cc:    1211        ..      ASRS     r1,r2,#8
        0x080012ce:    480e        .H      LDR      r0,[pc,#56] ; [0x8001308] = 0x40000800
        0x080012d0:    f7fffb54    ..T.    BL       LL_TIM_IC_SetActiveInput ; 0x800097c
;;;823    
;;;824      LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_ICPSC_DIV1);
        0x080012d4:    2200        ."      MOVS     r2,#0
        0x080012d6:    f44f7180    O..q    MOV      r1,#0x100
        0x080012da:    480b        .H      LDR      r0,[pc,#44] ; [0x8001308] = 0x40000800
        0x080012dc:    f7fffbe6    ....    BL       LL_TIM_IC_SetPrescaler ; 0x8000aac
;;;825    
;;;826      LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_IC_FILTER_FDIV32_N8);
        0x080012e0:    f44f0270    O.p.    MOV      r2,#0xf00000
        0x080012e4:    f44f7180    O..q    MOV      r1,#0x100
        0x080012e8:    4807        .H      LDR      r0,[pc,#28] ; [0x8001308] = 0x40000800
        0x080012ea:    f7fffb7d    ..}.    BL       LL_TIM_IC_SetFilter ; 0x80009e8
;;;827    
;;;828      LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_IC_POLARITY_RISING);
        0x080012ee:    2200        ."      MOVS     r2,#0
        0x080012f0:    f44f7180    O..q    MOV      r1,#0x100
        0x080012f4:    4804        .H      LDR      r0,[pc,#16] ; [0x8001308] = 0x40000800
        0x080012f6:    f7fffbad    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000a54
;;;829    
;;;830    }
        0x080012fa:    b00b        ..      ADD      sp,sp,#0x2c
        0x080012fc:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080012fe:    0000        ..      DCW    0
        0x08001300:    0401c0c1    ....    DCD    67223745
        0x08001304:    40010c00    ...@    DCD    1073810432
        0x08001308:    40000800    ...@    DCD    1073743872
    $t
    i.NVIC_EnableIRQ
    NVIC_EnableIRQ
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1454     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
        0x0800130c:    f000021f    ....    AND      r2,r0,#0x1f
        0x08001310:    2101        .!      MOVS     r1,#1
        0x08001312:    4091        .@      LSLS     r1,r1,r2
        0x08001314:    0942        B.      LSRS     r2,r0,#5
        0x08001316:    0092        ..      LSLS     r2,r2,#2
        0x08001318:    f10222e0    ..."    ADD      r2,r2,#0xe000e000
        0x0800131c:    f8c21100    ....    STR      r1,[r2,#0x100]
;;;1455   }
        0x08001320:    4770        pG      BX       lr
    i.NVIC_EncodePriority
    NVIC_EncodePriority
;;;1456   
;;;1457   
;;;1458   /**
;;;1459     \brief   Disable External Interrupt
;;;1460     \details Disables a device-specific interrupt in the NVIC interrupt controller.
;;;1461     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1462    */
;;;1463   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
;;;1464   {
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1466   }
;;;1467   
;;;1468   
;;;1469   /**
;;;1470     \brief   Get Pending Interrupt
;;;1471     \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
;;;1472     \param [in]      IRQn  Interrupt number.
;;;1473     \return             0  Interrupt status is not pending.
;;;1474     \return             1  Interrupt status is pending.
;;;1475    */
;;;1476   __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
;;;1477   {
;;;1478     return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1479   }
;;;1480   
;;;1481   
;;;1482   /**
;;;1483     \brief   Set Pending Interrupt
;;;1484     \details Sets the pending bit of an external interrupt.
;;;1485     \param [in]      IRQn  Interrupt number. Value cannot be negative.
;;;1486    */
;;;1487   __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
;;;1488   {
;;;1489     NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1490   }
;;;1491   
;;;1492   
;;;1493   /**
;;;1494     \brief   Clear Pending Interrupt
;;;1495     \details Clears the pending bit of an external interrupt.
;;;1496     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1497    */
;;;1498   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
;;;1499   {
;;;1500     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1501   }
;;;1502   
;;;1503   
;;;1504   /**
;;;1505     \brief   Get Active Interrupt
;;;1506     \details Reads the active register in NVIC and returns the active bit.
;;;1507     \param [in]      IRQn  Interrupt number.
;;;1508     \return             0  Interrupt status is not active.
;;;1509     \return             1  Interrupt status is active.
;;;1510    */
;;;1511   __STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
;;;1512   {
;;;1513     return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1514   }
;;;1515   
;;;1516   
;;;1517   /**
;;;1518     \brief   Set Interrupt Priority
;;;1519     \details Sets the priority of an interrupt.
;;;1520     \note    The priority cannot be set for every core interrupt.
;;;1521     \param [in]      IRQn  Interrupt number.
;;;1522     \param [in]  priority  Priority to set.
;;;1523    */
;;;1524   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
;;;1525   {
;;;1526     if ((int32_t)(IRQn) < 0)
;;;1527     {
;;;1528       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1529     }
;;;1530     else
;;;1531     {
;;;1532       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1533     }
;;;1534   }
;;;1535   
;;;1536   
;;;1537   /**
;;;1538     \brief   Get Interrupt Priority
;;;1539     \details Reads the priority of an interrupt.
;;;1540              The interrupt number can be positive to specify an external (device specific) interrupt,
;;;1541              or negative to specify an internal (core) interrupt.
;;;1542     \param [in]   IRQn  Interrupt number.
;;;1543     \return             Interrupt Priority.
;;;1544                         Value is aligned automatically to the implemented priority bits of the microcontroller.
;;;1545    */
;;;1546   __STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
;;;1547   {
;;;1548   
;;;1549     if ((int32_t)(IRQn) < 0)
;;;1550     {
;;;1551       return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
;;;1552     }
;;;1553     else
;;;1554     {
;;;1555       return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
;;;1556     }
;;;1557   }
;;;1558   
;;;1559   
;;;1560   /**
;;;1561     \brief   Encode Priority
;;;1562     \details Encodes the priority for an interrupt with the given priority group,
;;;1563              preemptive priority value, and subpriority value.
;;;1564              In case of a conflict between priority grouping and available
;;;1565              priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
;;;1566     \param [in]     PriorityGroup  Used priority group.
;;;1567     \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
;;;1568     \param [in]       SubPriority  Subpriority value (starting from 0).
;;;1569     \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
;;;1570    */
;;;1571   __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
;;;1572   {
        0x08001322:    b5f0        ..      PUSH     {r4-r7,lr}
        0x08001324:    4603        .F      MOV      r3,r0
        0x08001326:    460c        .F      MOV      r4,r1
;;;1573     uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
        0x08001328:    f0030107    ....    AND      r1,r3,#7
;;;1574     uint32_t PreemptPriorityBits;
;;;1575     uint32_t SubPriorityBits;
;;;1576   
;;;1577     PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
        0x0800132c:    f1c10007    ....    RSB      r0,r1,#7
        0x08001330:    2804        .(      CMP      r0,#4
        0x08001332:    d901        ..      BLS      0x8001338 ; NVIC_EncodePriority + 22
        0x08001334:    2004        .       MOVS     r0,#4
        0x08001336:    e001        ..      B        0x800133c ; NVIC_EncodePriority + 26
        0x08001338:    f1c10007    ....    RSB      r0,r1,#7
        0x0800133c:    4606        .F      MOV      r6,r0
;;;1578     SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
        0x0800133e:    1d08        ..      ADDS     r0,r1,#4
        0x08001340:    2807        .(      CMP      r0,#7
        0x08001342:    d201        ..      BCS      0x8001348 ; NVIC_EncodePriority + 38
        0x08001344:    2000        .       MOVS     r0,#0
        0x08001346:    e000        ..      B        0x800134a ; NVIC_EncodePriority + 40
        0x08001348:    1ec8        ..      SUBS     r0,r1,#3
        0x0800134a:    4605        .F      MOV      r5,r0
;;;1579   
;;;1580     return (
        0x0800134c:    2001        .       MOVS     r0,#1
        0x0800134e:    40b0        .@      LSLS     r0,r0,r6
        0x08001350:    1e40        @.      SUBS     r0,r0,#1
        0x08001352:    4020         @      ANDS     r0,r0,r4
        0x08001354:    40a8        .@      LSLS     r0,r0,r5
        0x08001356:    2701        .'      MOVS     r7,#1
        0x08001358:    40af        .@      LSLS     r7,r7,r5
        0x0800135a:    1e7f        ..      SUBS     r7,r7,#1
        0x0800135c:    4017        .@      ANDS     r7,r7,r2
        0x0800135e:    4338        8C      ORRS     r0,r0,r7
;;;1581              ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
;;;1582              ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
;;;1583            );
;;;1584   }
        0x08001360:    bdf0        ..      POP      {r4-r7,pc}
        0x08001362:    0000        ..      MOVS     r0,r0
    i.NVIC_GetPriorityGrouping
    NVIC_GetPriorityGrouping
;;; ../Drivers/CMSIS/Include/core_cm3.h (1443)
        0x08001364:    4802        .H      LDR      r0,[pc,#8] ; [0x8001370] = 0xe000ed0c
        0x08001366:    6800        .h      LDR      r0,[r0,#0]
        0x08001368:    f3c02002    ...     UBFX     r0,r0,#8,#3
;;;1444   }
        0x0800136c:    4770        pG      BX       lr
    $d
        0x0800136e:    0000        ..      DCW    0
        0x08001370:    e000ed0c    ....    DCD    3758157068
    $t
    i.NVIC_SetPriority
    NVIC_SetPriority
;;;1445   
;;;1446   
;;;1447   /**
;;;1448     \brief   Enable External Interrupt
;;;1449     \details Enables a device-specific interrupt in the NVIC interrupt controller.
;;;1450     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1451    */
;;;1452   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
;;;1453   {
;;;1454     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1455   }
;;;1456   
;;;1457   
;;;1458   /**
;;;1459     \brief   Disable External Interrupt
;;;1460     \details Disables a device-specific interrupt in the NVIC interrupt controller.
;;;1461     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1462    */
;;;1463   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
;;;1464   {
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1466   }
;;;1467   
;;;1468   
;;;1469   /**
;;;1470     \brief   Get Pending Interrupt
;;;1471     \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
;;;1472     \param [in]      IRQn  Interrupt number.
;;;1473     \return             0  Interrupt status is not pending.
;;;1474     \return             1  Interrupt status is pending.
;;;1475    */
;;;1476   __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
;;;1477   {
;;;1478     return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1479   }
;;;1480   
;;;1481   
;;;1482   /**
;;;1483     \brief   Set Pending Interrupt
;;;1484     \details Sets the pending bit of an external interrupt.
;;;1485     \param [in]      IRQn  Interrupt number. Value cannot be negative.
;;;1486    */
;;;1487   __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
;;;1488   {
;;;1489     NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1490   }
;;;1491   
;;;1492   
;;;1493   /**
;;;1494     \brief   Clear Pending Interrupt
;;;1495     \details Clears the pending bit of an external interrupt.
;;;1496     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1497    */
;;;1498   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
;;;1499   {
;;;1500     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1501   }
;;;1502   
;;;1503   
;;;1504   /**
;;;1505     \brief   Get Active Interrupt
;;;1506     \details Reads the active register in NVIC and returns the active bit.
;;;1507     \param [in]      IRQn  Interrupt number.
;;;1508     \return             0  Interrupt status is not active.
;;;1509     \return             1  Interrupt status is active.
;;;1510    */
;;;1511   __STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
;;;1512   {
;;;1513     return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1514   }
;;;1515   
;;;1516   
;;;1517   /**
;;;1518     \brief   Set Interrupt Priority
;;;1519     \details Sets the priority of an interrupt.
;;;1520     \note    The priority cannot be set for every core interrupt.
;;;1521     \param [in]      IRQn  Interrupt number.
;;;1522     \param [in]  priority  Priority to set.
;;;1523    */
;;;1524   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
;;;1525   {
        0x08001374:    b510        ..      PUSH     {r4,lr}
;;;1526     if ((int32_t)(IRQn) < 0)
        0x08001376:    2800        .(      CMP      r0,#0
        0x08001378:    da07        ..      BGE      0x800138a ; NVIC_SetPriority + 22
;;;1527     {
;;;1528       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
        0x0800137a:    070a        ..      LSLS     r2,r1,#28
        0x0800137c:    0e14        ..      LSRS     r4,r2,#24
        0x0800137e:    4a05        .J      LDR      r2,[pc,#20] ; [0x8001394] = 0xe000ed18
        0x08001380:    f000030f    ....    AND      r3,r0,#0xf
        0x08001384:    1f1b        ..      SUBS     r3,r3,#4
        0x08001386:    54d4        .T      STRB     r4,[r2,r3]
        0x08001388:    e003        ..      B        0x8001392 ; NVIC_SetPriority + 30
;;;1529     }
;;;1530     else
;;;1531     {
;;;1532       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
        0x0800138a:    070a        ..      LSLS     r2,r1,#28
        0x0800138c:    0e13        ..      LSRS     r3,r2,#24
        0x0800138e:    4a02        .J      LDR      r2,[pc,#8] ; [0x8001398] = 0xe000e400
        0x08001390:    5413        .T      STRB     r3,[r2,r0]
;;;1533     }
;;;1534   }
        0x08001392:    bd10        ..      POP      {r4,pc}
    $d
        0x08001394:    e000ed18    ....    DCD    3758157080
        0x08001398:    e000e400    ....    DCD    3758154752
    $t
    i.OC1Config
    OC1Config
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;766    {
        0x0800139c:    b570        p.      PUSH     {r4-r6,lr}
        0x0800139e:    4602        .F      MOV      r2,r0
;;;767      uint32_t tmpccmr1 = 0U;
        0x080013a0:    2400        .$      MOVS     r4,#0
;;;768      uint32_t tmpccer = 0U;
        0x080013a2:    2300        .#      MOVS     r3,#0
;;;769      uint32_t tmpcr2 = 0U;
        0x080013a4:    2500        .%      MOVS     r5,#0
;;;770    
;;;771      /* Check the parameters */
;;;772      assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;773      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;774      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;775      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;776      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;777      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;778    
;;;779      /* Disable the Channel 1: Reset the CC1E Bit */
;;;780      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
        0x080013a6:    6a10        .j      LDR      r0,[r2,#0x20]
        0x080013a8:    f0200001     ...    BIC      r0,r0,#1
        0x080013ac:    6210        .b      STR      r0,[r2,#0x20]
;;;781    
;;;782      /* Get the TIMx CCER register value */
;;;783      tmpccer = LL_TIM_ReadReg(TIMx, CCER);
        0x080013ae:    6a13        .j      LDR      r3,[r2,#0x20]
;;;784    
;;;785      /* Get the TIMx CR2 register value */
;;;786      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x080013b0:    6855        Uh      LDR      r5,[r2,#4]
;;;787    
;;;788      /* Get the TIMx CCMR1 register value */
;;;789      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
        0x080013b2:    6994        .i      LDR      r4,[r2,#0x18]
;;;790    
;;;791      /* Reset Capture/Compare selection Bits */
;;;792      CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
        0x080013b4:    f0240403    $...    BIC      r4,r4,#3
;;;793    
;;;794      /* Set the Output Compare Mode */
;;;795      MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
        0x080013b8:    f0240070    $.p.    BIC      r0,r4,#0x70
        0x080013bc:    680e        .h      LDR      r6,[r1,#0]
        0x080013be:    ea400406    @...    ORR      r4,r0,r6
;;;796    
;;;797      /* Set the Output Compare Polarity */
;;;798      MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
        0x080013c2:    f0230002    #...    BIC      r0,r3,#2
        0x080013c6:    690e        .i      LDR      r6,[r1,#0x10]
        0x080013c8:    ea400306    @...    ORR      r3,r0,r6
;;;799    
;;;800      /* Set the Output State */
;;;801      MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
        0x080013cc:    f0230001    #...    BIC      r0,r3,#1
        0x080013d0:    684e        Nh      LDR      r6,[r1,#4]
        0x080013d2:    ea400306    @...    ORR      r3,r0,r6
;;;802    
;;;803      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x080013d6:    480f        .H      LDR      r0,[pc,#60] ; [0x8001414] = 0x40012c00
        0x080013d8:    4282        .B      CMP      r2,r0
        0x080013da:    d113        ..      BNE      0x8001404 ; OC1Config + 104
;;;804      {
;;;805        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;806        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;807    
;;;808        /* Set the complementary output Polarity */
;;;809        MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
        0x080013dc:    f0230008    #...    BIC      r0,r3,#8
        0x080013e0:    694e        Ni      LDR      r6,[r1,#0x14]
        0x080013e2:    ea400386    @...    ORR      r3,r0,r6,LSL #2
;;;810    
;;;811        /* Set the complementary output State */
;;;812        MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
        0x080013e6:    f0230004    #...    BIC      r0,r3,#4
        0x080013ea:    688e        .h      LDR      r6,[r1,#8]
        0x080013ec:    ea400386    @...    ORR      r3,r0,r6,LSL #2
;;;813    
;;;814        /* Set the Output Idle state */
;;;815        MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
        0x080013f0:    f4257080    %..p    BIC      r0,r5,#0x100
        0x080013f4:    698e        .i      LDR      r6,[r1,#0x18]
        0x080013f6:    ea400506    @...    ORR      r5,r0,r6
;;;816    
;;;817        /* Set the complementary output Idle state */
;;;818        MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
        0x080013fa:    f4257000    %..p    BIC      r0,r5,#0x200
        0x080013fe:    69ce        .i      LDR      r6,[r1,#0x1c]
        0x08001400:    ea400546    @.F.    ORR      r5,r0,r6,LSL #1
;;;819      }
;;;820    
;;;821      /* Write to TIMx CR2 */
;;;822      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001404:    6055        U`      STR      r5,[r2,#4]
;;;823    
;;;824      /* Write to TIMx CCMR1 */
;;;825      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
        0x08001406:    6194        .a      STR      r4,[r2,#0x18]
;;;826    
;;;827      /* Set the Capture Compare Register value */
;;;828      LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
        0x08001408:    68c8        .h      LDR      r0,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1994     WRITE_REG(TIMx->CCR1, CompareValue);
        0x0800140a:    6350        Pc      STR      r0,[r2,#0x34]
;;;1995   }
        0x0800140c:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;831      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x0800140e:    6213        .b      STR      r3,[r2,#0x20]
;;;832    
;;;833      return SUCCESS;
        0x08001410:    2001        .       MOVS     r0,#1
;;;834    }
        0x08001412:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001414:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC2Config
    OC2Config
;;;835    
;;;836    /**
;;;837      * @brief  Configure the TIMx output channel 2.
;;;838      * @param  TIMx Timer Instance
;;;839      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 2 configuration data structure
;;;840      * @retval An ErrorStatus enumeration value:
;;;841      *          - SUCCESS: TIMx registers are de-initialized
;;;842      *          - ERROR: not applicable
;;;843      */
;;;844    static ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;845    {
        0x08001418:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0800141c:    4604        .F      MOV      r4,r0
        0x0800141e:    460d        .F      MOV      r5,r1
;;;846      uint32_t tmpccmr1 = 0U;
        0x08001420:    2700        .'      MOVS     r7,#0
;;;847      uint32_t tmpccer = 0U;
        0x08001422:    2600        .&      MOVS     r6,#0
;;;848      uint32_t tmpcr2 = 0U;
        0x08001424:    46b0        .F      MOV      r8,r6
;;;849    
;;;850      /* Check the parameters */
;;;851      assert_param(IS_TIM_CC2_INSTANCE(TIMx));
;;;852      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;853      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;854      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;855      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;856      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;857    
;;;858      /* Disable the Channel 2: Reset the CC2E Bit */
;;;859      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
        0x08001426:    6a20         j      LDR      r0,[r4,#0x20]
        0x08001428:    f0200010     ...    BIC      r0,r0,#0x10
        0x0800142c:    6220         b      STR      r0,[r4,#0x20]
;;;860    
;;;861      /* Get the TIMx CCER register value */
;;;862      tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
        0x0800142e:    6a26        &j      LDR      r6,[r4,#0x20]
;;;863    
;;;864      /* Get the TIMx CR2 register value */
;;;865      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x08001430:    f8d48004    ....    LDR      r8,[r4,#4]
;;;866    
;;;867      /* Get the TIMx CCMR1 register value */
;;;868      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
        0x08001434:    69a7        .i      LDR      r7,[r4,#0x18]
;;;869    
;;;870      /* Reset Capture/Compare selection Bits */
;;;871      CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
        0x08001436:    f4277740    '.@w    BIC      r7,r7,#0x300
;;;872    
;;;873      /* Select the Output Compare Mode */
;;;874      MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
        0x0800143a:    f42740e0    '..@    BIC      r0,r7,#0x7000
        0x0800143e:    6829        )h      LDR      r1,[r5,#0]
        0x08001440:    ea402701    @..'    ORR      r7,r0,r1,LSL #8
;;;875    
;;;876      /* Set the Output Compare Polarity */
;;;877      MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
        0x08001444:    f0260020    &. .    BIC      r0,r6,#0x20
        0x08001448:    6929        )i      LDR      r1,[r5,#0x10]
        0x0800144a:    ea401601    @...    ORR      r6,r0,r1,LSL #4
;;;878    
;;;879      /* Set the Output State */
;;;880      MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
        0x0800144e:    f0260010    &...    BIC      r0,r6,#0x10
        0x08001452:    6869        ih      LDR      r1,[r5,#4]
        0x08001454:    ea401601    @...    ORR      r6,r0,r1,LSL #4
;;;881    
;;;882      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001458:    4810        .H      LDR      r0,[pc,#64] ; [0x800149c] = 0x40012c00
        0x0800145a:    4284        .B      CMP      r4,r0
        0x0800145c:    d113        ..      BNE      0x8001486 ; OC2Config + 110
;;;883      {
;;;884        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;885        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;886    
;;;887        /* Set the complementary output Polarity */
;;;888        MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
        0x0800145e:    f0260080    &...    BIC      r0,r6,#0x80
        0x08001462:    6969        ii      LDR      r1,[r5,#0x14]
        0x08001464:    ea401681    @...    ORR      r6,r0,r1,LSL #6
;;;889    
;;;890        /* Set the complementary output State */
;;;891        MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
        0x08001468:    f0260040    &.@.    BIC      r0,r6,#0x40
        0x0800146c:    68a9        .h      LDR      r1,[r5,#8]
        0x0800146e:    ea401681    @...    ORR      r6,r0,r1,LSL #6
;;;892    
;;;893        /* Set the Output Idle state */
;;;894        MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
        0x08001472:    f4286080    (..`    BIC      r0,r8,#0x400
        0x08001476:    69a9        .i      LDR      r1,[r5,#0x18]
        0x08001478:    ea400881    @...    ORR      r8,r0,r1,LSL #2
;;;895    
;;;896        /* Set the complementary output Idle state */
;;;897        MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
        0x0800147c:    f4286000    (..`    BIC      r0,r8,#0x800
        0x08001480:    69e9        .i      LDR      r1,[r5,#0x1c]
        0x08001482:    ea4008c1    @...    ORR      r8,r0,r1,LSL #3
;;;898      }
;;;899    
;;;900      /* Write to TIMx CR2 */
;;;901      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001486:    f8c48004    ....    STR      r8,[r4,#4]
;;;902    
;;;903      /* Write to TIMx CCMR1 */
;;;904      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
        0x0800148a:    61a7        .a      STR      r7,[r4,#0x18]
;;;905    
;;;906      /* Set the Capture Compare Register value */
;;;907      LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
        0x0800148c:    4620         F      MOV      r0,r4
        0x0800148e:    68e9        .h      LDR      r1,[r5,#0xc]
        0x08001490:    f7fffc18    ....    BL       LL_TIM_OC_SetCompareCH2 ; 0x8000cc4
;;;908    
;;;909      /* Write to TIMx CCER */
;;;910      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001494:    6226        &b      STR      r6,[r4,#0x20]
;;;911    
;;;912      return SUCCESS;
        0x08001496:    2001        .       MOVS     r0,#1
;;;913    }
        0x08001498:    e8bd81f0    ....    POP      {r4-r8,pc}
    $d
        0x0800149c:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC3Config
    OC3Config
;;;914    
;;;915    /**
;;;916      * @brief  Configure the TIMx output channel 3.
;;;917      * @param  TIMx Timer Instance
;;;918      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 3 configuration data structure
;;;919      * @retval An ErrorStatus enumeration value:
;;;920      *          - SUCCESS: TIMx registers are de-initialized
;;;921      *          - ERROR: not applicable
;;;922      */
;;;923    static ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;924    {
        0x080014a0:    b570        p.      PUSH     {r4-r6,lr}
        0x080014a2:    4602        .F      MOV      r2,r0
;;;925      uint32_t tmpccmr2 = 0U;
        0x080014a4:    2400        .$      MOVS     r4,#0
;;;926      uint32_t tmpccer = 0U;
        0x080014a6:    2300        .#      MOVS     r3,#0
;;;927      uint32_t tmpcr2 = 0U;
        0x080014a8:    2500        .%      MOVS     r5,#0
;;;928    
;;;929      /* Check the parameters */
;;;930      assert_param(IS_TIM_CC3_INSTANCE(TIMx));
;;;931      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;932      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;933      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;934      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;935      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;936    
;;;937      /* Disable the Channel 3: Reset the CC3E Bit */
;;;938      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
        0x080014aa:    6a10        .j      LDR      r0,[r2,#0x20]
        0x080014ac:    f4207080     ..p    BIC      r0,r0,#0x100
        0x080014b0:    6210        .b      STR      r0,[r2,#0x20]
;;;939    
;;;940      /* Get the TIMx CCER register value */
;;;941      tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
        0x080014b2:    6a13        .j      LDR      r3,[r2,#0x20]
;;;942    
;;;943      /* Get the TIMx CR2 register value */
;;;944      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x080014b4:    6855        Uh      LDR      r5,[r2,#4]
;;;945    
;;;946      /* Get the TIMx CCMR2 register value */
;;;947      tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
        0x080014b6:    69d4        .i      LDR      r4,[r2,#0x1c]
;;;948    
;;;949      /* Reset Capture/Compare selection Bits */
;;;950      CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
        0x080014b8:    f0240403    $...    BIC      r4,r4,#3
;;;951    
;;;952      /* Select the Output Compare Mode */
;;;953      MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
        0x080014bc:    f0240070    $.p.    BIC      r0,r4,#0x70
        0x080014c0:    680e        .h      LDR      r6,[r1,#0]
        0x080014c2:    ea400406    @...    ORR      r4,r0,r6
;;;954    
;;;955      /* Set the Output Compare Polarity */
;;;956      MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
        0x080014c6:    f4237000    #..p    BIC      r0,r3,#0x200
        0x080014ca:    690e        .i      LDR      r6,[r1,#0x10]
        0x080014cc:    ea402306    @..#    ORR      r3,r0,r6,LSL #8
;;;957    
;;;958      /* Set the Output State */
;;;959      MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
        0x080014d0:    f4237080    #..p    BIC      r0,r3,#0x100
        0x080014d4:    684e        Nh      LDR      r6,[r1,#4]
        0x080014d6:    ea402306    @..#    ORR      r3,r0,r6,LSL #8
;;;960    
;;;961      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x080014da:    480f        .H      LDR      r0,[pc,#60] ; [0x8001518] = 0x40012c00
        0x080014dc:    4282        .B      CMP      r2,r0
        0x080014de:    d113        ..      BNE      0x8001508 ; OC3Config + 104
;;;962      {
;;;963        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;964        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;965    
;;;966        /* Set the complementary output Polarity */
;;;967        MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
        0x080014e0:    f4236000    #..`    BIC      r0,r3,#0x800
        0x080014e4:    694e        Ni      LDR      r6,[r1,#0x14]
        0x080014e6:    ea402386    @..#    ORR      r3,r0,r6,LSL #10
;;;968    
;;;969        /* Set the complementary output State */
;;;970        MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
        0x080014ea:    f4236080    #..`    BIC      r0,r3,#0x400
        0x080014ee:    688e        .h      LDR      r6,[r1,#8]
        0x080014f0:    ea402386    @..#    ORR      r3,r0,r6,LSL #10
;;;971    
;;;972        /* Set the Output Idle state */
;;;973        MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
        0x080014f4:    f4255080    %..P    BIC      r0,r5,#0x1000
        0x080014f8:    698e        .i      LDR      r6,[r1,#0x18]
        0x080014fa:    ea401506    @...    ORR      r5,r0,r6,LSL #4
;;;974    
;;;975        /* Set the complementary output Idle state */
;;;976        MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
        0x080014fe:    f4255000    %..P    BIC      r0,r5,#0x2000
        0x08001502:    69ce        .i      LDR      r6,[r1,#0x1c]
        0x08001504:    ea401546    @.F.    ORR      r5,r0,r6,LSL #5
;;;977      }
;;;978    
;;;979      /* Write to TIMx CR2 */
;;;980      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001508:    6055        U`      STR      r5,[r2,#4]
;;;981    
;;;982      /* Write to TIMx CCMR2 */
;;;983      LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
        0x0800150a:    61d4        .a      STR      r4,[r2,#0x1c]
;;;984    
;;;985      /* Set the Capture Compare Register value */
;;;986      LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
        0x0800150c:    68c8        .h      LDR      r0,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2022     WRITE_REG(TIMx->CCR3, CompareValue);
        0x0800150e:    63d0        .c      STR      r0,[r2,#0x3c]
;;;2023   }
        0x08001510:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;989      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001512:    6213        .b      STR      r3,[r2,#0x20]
;;;990    
;;;991      return SUCCESS;
        0x08001514:    2001        .       MOVS     r0,#1
;;;992    }
        0x08001516:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001518:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC4Config
    OC4Config
;;;993    
;;;994    /**
;;;995      * @brief  Configure the TIMx output channel 4.
;;;996      * @param  TIMx Timer Instance
;;;997      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 4 configuration data structure
;;;998      * @retval An ErrorStatus enumeration value:
;;;999      *          - SUCCESS: TIMx registers are de-initialized
;;;1000     *          - ERROR: not applicable
;;;1001     */
;;;1002   static ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;1003   {
        0x0800151c:    b570        p.      PUSH     {r4-r6,lr}
        0x0800151e:    4602        .F      MOV      r2,r0
;;;1004     uint32_t tmpccmr2 = 0U;
        0x08001520:    2300        .#      MOVS     r3,#0
;;;1005     uint32_t tmpccer = 0U;
        0x08001522:    2400        .$      MOVS     r4,#0
;;;1006     uint32_t tmpcr2 = 0U;
        0x08001524:    2500        .%      MOVS     r5,#0
;;;1007   
;;;1008     /* Check the parameters */
;;;1009     assert_param(IS_TIM_CC4_INSTANCE(TIMx));
;;;1010     assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;1011     assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;1012     assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;1013     assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;1014     assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;1015   
;;;1016     /* Disable the Channel 4: Reset the CC4E Bit */
;;;1017     CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
        0x08001526:    6a10        .j      LDR      r0,[r2,#0x20]
        0x08001528:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x0800152c:    6210        .b      STR      r0,[r2,#0x20]
;;;1018   
;;;1019     /* Get the TIMx CCER register value */
;;;1020     tmpccer = LL_TIM_ReadReg(TIMx, CCER);
        0x0800152e:    6a14        .j      LDR      r4,[r2,#0x20]
;;;1021   
;;;1022     /* Get the TIMx CR2 register value */
;;;1023     tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
        0x08001530:    6855        Uh      LDR      r5,[r2,#4]
;;;1024   
;;;1025     /* Get the TIMx CCMR2 register value */
;;;1026     tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
        0x08001532:    69d3        .i      LDR      r3,[r2,#0x1c]
;;;1027   
;;;1028     /* Reset Capture/Compare selection Bits */
;;;1029     CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
        0x08001534:    f4237340    #.@s    BIC      r3,r3,#0x300
;;;1030   
;;;1031     /* Select the Output Compare Mode */
;;;1032     MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
        0x08001538:    f42340e0    #..@    BIC      r0,r3,#0x7000
        0x0800153c:    680e        .h      LDR      r6,[r1,#0]
        0x0800153e:    ea402306    @..#    ORR      r3,r0,r6,LSL #8
;;;1033   
;;;1034     /* Set the Output Compare Polarity */
;;;1035     MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
        0x08001542:    f4245000    $..P    BIC      r0,r4,#0x2000
        0x08001546:    690e        .i      LDR      r6,[r1,#0x10]
        0x08001548:    ea403406    @..4    ORR      r4,r0,r6,LSL #12
;;;1036   
;;;1037     /* Set the Output State */
;;;1038     MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
        0x0800154c:    f4245080    $..P    BIC      r0,r4,#0x1000
        0x08001550:    684e        Nh      LDR      r6,[r1,#4]
        0x08001552:    ea403406    @..4    ORR      r4,r0,r6,LSL #12
;;;1039   
;;;1040     if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001556:    4808        .H      LDR      r0,[pc,#32] ; [0x8001578] = 0x40012c00
        0x08001558:    4282        .B      CMP      r2,r0
        0x0800155a:    d104        ..      BNE      0x8001566 ; OC4Config + 74
;;;1041     {
;;;1042       assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;1043       assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;1044   
;;;1045       /* Set the Output Idle state */
;;;1046       MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
        0x0800155c:    f4254080    %..@    BIC      r0,r5,#0x4000
        0x08001560:    698e        .i      LDR      r6,[r1,#0x18]
        0x08001562:    ea401586    @...    ORR      r5,r0,r6,LSL #6
;;;1047     }
;;;1048   
;;;1049     /* Write to TIMx CR2 */
;;;1050     LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001566:    6055        U`      STR      r5,[r2,#4]
;;;1051   
;;;1052     /* Write to TIMx CCMR2 */
;;;1053     LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
        0x08001568:    61d3        .a      STR      r3,[r2,#0x1c]
;;;1054   
;;;1055     /* Set the Capture Compare Register value */
;;;1056     LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
        0x0800156a:    68c8        .h      LDR      r0,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2036     WRITE_REG(TIMx->CCR4, CompareValue);
        0x0800156c:    6410        .d      STR      r0,[r2,#0x40]
;;;2037   }
        0x0800156e:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;1059     LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001570:    6214        .b      STR      r4,[r2,#0x20]
;;;1060   
;;;1061     return SUCCESS;
        0x08001572:    2001        .       MOVS     r0,#1
;;;1062   }
        0x08001574:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001576:    0000        ..      DCW    0
        0x08001578:    40012c00    .,.@    DCD    1073818624
    $t
    i.PendSV_Handler
    PendSV_Handler
;;; .\../Src/stm32f1xx_it.c
;;;109    }
        0x0800157c:    4770        pG      BX       lr
        0x0800157e:    0000        ..      MOVS     r0,r0
    i.RCC_GetHCLKClockFreq
    RCC_GetHCLKClockFreq
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;388    {
        0x08001580:    4601        .F      MOV      r1,r0
;;;389      /* HCLK clock frequency */
;;;390      return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
        0x08001582:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1116     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
        0x08001584:    4804        .H      LDR      r0,[pc,#16] ; [0x8001598] = 0x40021000
        0x08001586:    6840        @h      LDR      r0,[r0,#4]
        0x08001588:    f00000f0    ....    AND      r0,r0,#0xf0
        0x0800158c:    0900        ..      LSRS     r0,r0,#4
        0x0800158e:    4a03        .J      LDR      r2,[pc,#12] ; [0x800159c] = 0x8002c28
        0x08001590:    5c12        .\      LDRB     r2,[r2,r0]
        0x08001592:    fa21f002    !...    LSR      r0,r1,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;391    }
        0x08001596:    4770        pG      BX       lr
    $d
        0x08001598:    40021000    ...@    DCD    1073876992
        0x0800159c:    08002c28    (,..    DCD    134229032
    $t
    i.RCC_GetPCLK1ClockFreq
    RCC_GetPCLK1ClockFreq
;;;392    
;;;393    /**
;;;394      * @brief  Return PCLK1 clock frequency
;;;395      * @param  HCLK_Frequency HCLK clock frequency
;;;396      * @retval PCLK1 clock frequency (in Hz)
;;;397      */
;;;398    uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
;;;399    {
        0x080015a0:    4601        .F      MOV      r1,r0
;;;400      /* PCLK1 clock frequency */
;;;401      return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
        0x080015a2:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1131     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
        0x080015a4:    4805        .H      LDR      r0,[pc,#20] ; [0x80015bc] = 0x40021000
        0x080015a6:    6840        @h      LDR      r0,[r0,#4]
        0x080015a8:    f40060e0    ...`    AND      r0,r0,#0x700
        0x080015ac:    4a04        .J      LDR      r2,[pc,#16] ; [0x80015c0] = 0x8002c38
        0x080015ae:    eb022010    ...     ADD      r0,r2,r0,LSR #8
        0x080015b2:    7802        .x      LDRB     r2,[r0,#0]
        0x080015b4:    fa21f002    !...    LSR      r0,r1,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;402    }
        0x080015b8:    4770        pG      BX       lr
    $d
        0x080015ba:    0000        ..      DCW    0
        0x080015bc:    40021000    ...@    DCD    1073876992
        0x080015c0:    08002c38    8,..    DCD    134229048
    $t
    i.RCC_GetPCLK2ClockFreq
    RCC_GetPCLK2ClockFreq
;;;403    
;;;404    /**
;;;405      * @brief  Return PCLK2 clock frequency
;;;406      * @param  HCLK_Frequency HCLK clock frequency
;;;407      * @retval PCLK2 clock frequency (in Hz)
;;;408      */
;;;409    uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
;;;410    {
        0x080015c4:    4601        .F      MOV      r1,r0
;;;411      /* PCLK2 clock frequency */
;;;412      return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
        0x080015c6:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1146     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
        0x080015c8:    4805        .H      LDR      r0,[pc,#20] ; [0x80015e0] = 0x40021000
        0x080015ca:    6840        @h      LDR      r0,[r0,#4]
        0x080015cc:    f4005060    ..`P    AND      r0,r0,#0x3800
        0x080015d0:    4a04        .J      LDR      r2,[pc,#16] ; [0x80015e4] = 0x8002c38
        0x080015d2:    eb0220d0    ...     ADD      r0,r2,r0,LSR #11
        0x080015d6:    7802        .x      LDRB     r2,[r0,#0]
        0x080015d8:    fa21f002    !...    LSR      r0,r1,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;413    }
        0x080015dc:    4770        pG      BX       lr
    $d
        0x080015de:    0000        ..      DCW    0
        0x080015e0:    40021000    ...@    DCD    1073876992
        0x080015e4:    08002c38    8,..    DCD    134229048
    $t
    i.RCC_GetSystemClockFreq
    RCC_GetSystemClockFreq
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c (356)
        0x080015e8:    b510        ..      PUSH     {r4,lr}
;;;357      uint32_t frequency = 0U;
        0x080015ea:    2400        .$      MOVS     r4,#0
;;;358    
;;;359      /* Get SYSCLK source -------------------------------------------------------*/
;;;360      switch (LL_RCC_GetSysClkSource())
        0x080015ec:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1045     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
        0x080015ee:    480b        .H      LDR      r0,[pc,#44] ; [0x800161c] = 0x40021000
        0x080015f0:    6840        @h      LDR      r0,[r0,#4]
        0x080015f2:    f000000c    ....    AND      r0,r0,#0xc
        0x080015f6:    b120         .      CBZ      r0,0x8001602 ; RCC_GetSystemClockFreq + 26
        0x080015f8:    2804        .(      CMP      r0,#4
        0x080015fa:    d004        ..      BEQ      0x8001606 ; RCC_GetSystemClockFreq + 30
        0x080015fc:    2808        .(      CMP      r0,#8
        0x080015fe:    d108        ..      BNE      0x8001612 ; RCC_GetSystemClockFreq + 42
        0x08001600:    e003        ..      B        0x800160a ; RCC_GetSystemClockFreq + 34
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;363          frequency = HSI_VALUE;
        0x08001602:    4c07        .L      LDR      r4,[pc,#28] ; [0x8001620] = 0x7a1200
;;;364          break;
        0x08001604:    e007        ..      B        0x8001616 ; RCC_GetSystemClockFreq + 46
;;;365    
;;;366        case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
;;;367          frequency = HSE_VALUE;
        0x08001606:    4c06        .L      LDR      r4,[pc,#24] ; [0x8001620] = 0x7a1200
;;;368          break;
        0x08001608:    e005        ..      B        0x8001616 ; RCC_GetSystemClockFreq + 46
;;;369    
;;;370        case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
;;;371          frequency = RCC_PLL_GetFreqDomain_SYS();
        0x0800160a:    f000f80b    ....    BL       RCC_PLL_GetFreqDomain_SYS ; 0x8001624
        0x0800160e:    4604        .F      MOV      r4,r0
;;;372          break;
        0x08001610:    e001        ..      B        0x8001616 ; RCC_GetSystemClockFreq + 46
;;;373    
;;;374        default:
;;;375          frequency = HSI_VALUE;
        0x08001612:    4c03        .L      LDR      r4,[pc,#12] ; [0x8001620] = 0x7a1200
;;;376          break;
        0x08001614:    bf00        ..      NOP      
        0x08001616:    bf00        ..      NOP      
;;;377      }
;;;378    
;;;379      return frequency;
        0x08001618:    4620         F      MOV      r0,r4
;;;380    }
        0x0800161a:    bd10        ..      POP      {r4,pc}
    $d
        0x0800161c:    40021000    ...@    DCD    1073876992
        0x08001620:    007a1200    ..z.    DCD    8000000
    $t
    i.RCC_PLL_GetFreqDomain_SYS
    RCC_PLL_GetFreqDomain_SYS
;;;381    
;;;382    /**
;;;383      * @brief  Return HCLK clock frequency
;;;384      * @param  SYSCLK_Frequency SYSCLK clock frequency
;;;385      * @retval HCLK clock frequency (in Hz)
;;;386      */
;;;387    uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
;;;388    {
;;;389      /* HCLK clock frequency */
;;;390      return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
;;;391    }
;;;392    
;;;393    /**
;;;394      * @brief  Return PCLK1 clock frequency
;;;395      * @param  HCLK_Frequency HCLK clock frequency
;;;396      * @retval PCLK1 clock frequency (in Hz)
;;;397      */
;;;398    uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
;;;399    {
;;;400      /* PCLK1 clock frequency */
;;;401      return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
;;;402    }
;;;403    
;;;404    /**
;;;405      * @brief  Return PCLK2 clock frequency
;;;406      * @param  HCLK_Frequency HCLK clock frequency
;;;407      * @retval PCLK2 clock frequency (in Hz)
;;;408      */
;;;409    uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
;;;410    {
;;;411      /* PCLK2 clock frequency */
;;;412      return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
;;;413    }
;;;414    
;;;415    /**
;;;416      * @brief  Return PLL clock frequency used for system domain
;;;417      * @retval PLL clock frequency (in Hz)
;;;418      */
;;;419    uint32_t RCC_PLL_GetFreqDomain_SYS(void)
;;;420    {
;;;421      uint32_t pllinputfreq = 0U, pllsource = 0U;
        0x08001624:    2100        .!      MOVS     r1,#0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c (421)
        0x08001626:    2200        ."      MOVS     r2,#0
;;;422    
;;;423      /* PLL_VCO = (HSE_VALUE, HSI_VALUE or PLL2 / PLL Predivider) * PLL Multiplicator */
;;;424    
;;;425      /* Get PLL source */
;;;426      pllsource = LL_RCC_PLL_GetMainSource();
        0x08001628:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1543     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLSRC));
        0x0800162a:    4811        .H      LDR      r0,[pc,#68] ; [0x8001670] = 0x40021000
        0x0800162c:    6840        @h      LDR      r0,[r0,#4]
        0x0800162e:    f4003080    ...0    AND      r0,r0,#0x10000
        0x08001632:    4602        .F      MOV      r2,r0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;428      switch (pllsource)
        0x08001634:    b11a        ..      CBZ      r2,0x800163e ; RCC_PLL_GetFreqDomain_SYS + 26
        0x08001636:    f5b23f80    ...?    CMP      r2,#0x10000
        0x0800163a:    d10c        ..      BNE      0x8001656 ; RCC_PLL_GetFreqDomain_SYS + 50
        0x0800163c:    e001        ..      B        0x8001642 ; RCC_PLL_GetFreqDomain_SYS + 30
;;;429      {
;;;430        case LL_RCC_PLLSOURCE_HSI_DIV_2: /* HSI used as PLL clock source */
;;;431          pllinputfreq = HSI_VALUE / 2U;
        0x0800163e:    490d        .I      LDR      r1,[pc,#52] ; [0x8001674] = 0x3d0900
;;;432          break;
        0x08001640:    e00b        ..      B        0x800165a ; RCC_PLL_GetFreqDomain_SYS + 54
;;;433    
;;;434        case LL_RCC_PLLSOURCE_HSE:       /* HSE used as PLL clock source */
;;;435          pllinputfreq = HSE_VALUE / (LL_RCC_PLL_GetPrediv() + 1U);
        0x08001642:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1605     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLXTPRE));
        0x08001644:    480a        .H      LDR      r0,[pc,#40] ; [0x8001670] = 0x40021000
        0x08001646:    6840        @h      LDR      r0,[r0,#4]
        0x08001648:    f4003000    ...0    AND      r0,r0,#0x20000
        0x0800164c:    1c40        @.      ADDS     r0,r0,#1
        0x0800164e:    4b0a        .K      LDR      r3,[pc,#40] ; [0x8001678] = 0x7a1200
        0x08001650:    fbb3f1f0    ....    UDIV     r1,r3,r0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;436          break;
        0x08001654:    e001        ..      B        0x800165a ; RCC_PLL_GetFreqDomain_SYS + 54
;;;437    
;;;438    #if defined(RCC_PLL2_SUPPORT)
;;;439        case LL_RCC_PLLSOURCE_PLL2:       /* PLL2 used as PLL clock source */
;;;440          pllinputfreq = RCC_PLL2_GetFreqClockFreq() / (LL_RCC_PLL_GetPrediv() + 1U);
;;;441          break;
;;;442    #endif /* RCC_PLL2_SUPPORT */
;;;443    
;;;444        default:
;;;445          pllinputfreq = HSI_VALUE / 2U;
        0x08001656:    4907        .I      LDR      r1,[pc,#28] ; [0x8001674] = 0x3d0900
;;;446          break;
        0x08001658:    bf00        ..      NOP      
        0x0800165a:    bf00        ..      NOP      
;;;447      }
;;;448      return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetMultiplicator());
        0x0800165c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1572     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLMULL));
        0x0800165e:    4804        .H      LDR      r0,[pc,#16] ; [0x8001670] = 0x40021000
        0x08001660:    6840        @h      LDR      r0,[r0,#4]
        0x08001662:    f4001070    ..p.    AND      r0,r0,#0x3c0000
        0x08001666:    2302        .#      MOVS     r3,#2
        0x08001668:    eb034090    ...@    ADD      r0,r3,r0,LSR #18
        0x0800166c:    4348        HC      MULS     r0,r1,r0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;449    }
        0x0800166e:    4770        pG      BX       lr
    $d
        0x08001670:    40021000    ...@    DCD    1073876992
        0x08001674:    003d0900    ..=.    DCD    4000000
        0x08001678:    007a1200    ..z.    DCD    8000000
    $t
    i.SSD1306_Fill
    SSD1306_Fill
;;; .\..\Src\ssd1306.c
;;;125    void SSD1306_Fill(uint8_t color) {
        0x0800167c:    b510        ..      PUSH     {r4,lr}
        0x0800167e:    4604        .F      MOV      r4,r0
;;;126    	/* Set memory */
;;;127    	memset(SSD1306_Buffer, (color == SSD1306_COLOR_BLACK) ? 0x00 : 0xFF, SSD1306_WIDTH * SSD1306_HEIGHT / 8);
        0x08001680:    b90c        ..      CBNZ     r4,0x8001686 ; SSD1306_Fill + 10
        0x08001682:    2000        .       MOVS     r0,#0
        0x08001684:    e000        ..      B        0x8001688 ; SSD1306_Fill + 12
        0x08001686:    20ff        .       MOVS     r0,#0xff
        0x08001688:    4602        .F      MOV      r2,r0
        0x0800168a:    f44f6180    O..a    MOV      r1,#0x400
        0x0800168e:    4802        .H      LDR      r0,[pc,#8] ; [0x8001698] = 0x20000008
        0x08001690:    6800        .h      LDR      r0,[r0,#0]
        0x08001692:    f7fefd78    ..x.    BL       __aeabi_memset ; 0x8000186
;;;128    }
        0x08001696:    bd10        ..      POP      {r4,pc}
    $d
        0x08001698:    20000008    ...     DCD    536870920
    $t
    i.SSD1306_GotoXY
    SSD1306_GotoXY
;;;129    
;;;130    void SSD1306_DrawPixel(uint16_t x, uint16_t y, uint8_t color) {
;;;131    	if (
;;;132    		x >= SSD1306_WIDTH ||
;;;133    		y >= SSD1306_HEIGHT
;;;134    	) {
;;;135    		/* Error */
;;;136    		return;
;;;137    	}
;;;138    	
;;;139    	/* Check if pixels are inverted */
;;;140    	if (SSD1306.Inverted) {
;;;141    		color = (uint8_t)!color;
;;;142    	}
;;;143    	
;;;144    	/* Set color */
;;;145    	if (color == SSD1306_COLOR_WHITE) {
;;;146    		SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] |= 1 << (y % 8);
;;;147    	} else {
;;;148    		SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] &= ~(1 << (y % 8));
;;;149    	}
;;;150    }
;;;151    
;;;152    void SSD1306_GotoXY(uint16_t x, uint16_t y) {
;;;153    	/* Set write pointers */
;;;154    	SSD1306.CurrentX = x;
        0x0800169c:    4a01        .J      LDR      r2,[pc,#4] ; [0x80016a4] = 0x2000000c
        0x0800169e:    8010        ..      STRH     r0,[r2,#0]
;;;155    	SSD1306.CurrentY = y;
        0x080016a0:    8051        Q.      STRH     r1,[r2,#2]
;;;156    }
        0x080016a2:    4770        pG      BX       lr
    $d
        0x080016a4:    2000000c    ...     DCD    536870924
    $t
    i.SSD1306_Init
    SSD1306_Init
;;; .\..\Src\ssd1306.c (50)
        0x080016a8:    b570        p.      PUSH     {r4-r6,lr}
        0x080016aa:    4604        .F      MOV      r4,r0
;;;51     
;;;52     	hi2c_screen = hi2c;
        0x080016ac:    4850        PH      LDR      r0,[pc,#320] ; [0x80017f0] = 0x20000004
        0x080016ae:    6004        .`      STR      r4,[r0,#0]
;;;53     	/* Init I2C */
;;;54     	ssd1306_I2C_Init();
        0x080016b0:    f001f8c6    ....    BL       ssd1306_I2C_Init ; 0x8002840
;;;55     /* haltodo	
;;;56     	// Check if LCD connected to I2C
;;;57     	if (HAL_I2C_IsDeviceReady(hi2c_screen, SSD1306_I2C_ADDR, 5, 1000) != HAL_OK) {
;;;58     		return 0;
;;;59     	}
;;;60     	*/
;;;61     	/* A little delay */
;;;62     	uint32_t p = 2500;
        0x080016b4:    f64015c4    @...    MOV      r5,#0x9c4
;;;63     	while(p>0)
        0x080016b8:    e000        ..      B        0x80016bc ; SSD1306_Init + 20
        0x080016ba:    1e6d        m.      SUBS     r5,r5,#1
        0x080016bc:    2d00        .-      CMP      r5,#0
        0x080016be:    d1fc        ..      BNE      0x80016ba ; SSD1306_Init + 18
;;;64     		p--;
;;;65     	
;;;66     	/* Init LCD */
;;;67     	SSD1306_WRITECOMMAND(0xAE); //display off
        0x080016c0:    22ae        ."      MOVS     r2,#0xae
        0x080016c2:    2100        .!      MOVS     r1,#0
        0x080016c4:    2078        x       MOVS     r0,#0x78
        0x080016c6:    f001f8c3    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;68     	SSD1306_WRITECOMMAND(0x20); //Set Memory Addressing Mode   
        0x080016ca:    2220         "      MOVS     r2,#0x20
        0x080016cc:    2100        .!      MOVS     r1,#0
        0x080016ce:    2078        x       MOVS     r0,#0x78
        0x080016d0:    f001f8be    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;69     	SSD1306_WRITECOMMAND(0x10); //00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid
        0x080016d4:    2210        ."      MOVS     r2,#0x10
        0x080016d6:    2100        .!      MOVS     r1,#0
        0x080016d8:    2078        x       MOVS     r0,#0x78
        0x080016da:    f001f8b9    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;70     	SSD1306_WRITECOMMAND(0xB0); //Set Page Start Address for Page Addressing Mode,0-7
        0x080016de:    22b0        ."      MOVS     r2,#0xb0
        0x080016e0:    2100        .!      MOVS     r1,#0
        0x080016e2:    2078        x       MOVS     r0,#0x78
        0x080016e4:    f001f8b4    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;71     	SSD1306_WRITECOMMAND(0xC8); //Set COM Output Scan Direction
        0x080016e8:    22c8        ."      MOVS     r2,#0xc8
        0x080016ea:    2100        .!      MOVS     r1,#0
        0x080016ec:    2078        x       MOVS     r0,#0x78
        0x080016ee:    f001f8af    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;72     	SSD1306_WRITECOMMAND(0x00); //---set low column address
        0x080016f2:    2200        ."      MOVS     r2,#0
        0x080016f4:    4611        .F      MOV      r1,r2
        0x080016f6:    2078        x       MOVS     r0,#0x78
        0x080016f8:    f001f8aa    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;73     	SSD1306_WRITECOMMAND(0x10); //---set high column address
        0x080016fc:    2210        ."      MOVS     r2,#0x10
        0x080016fe:    2100        .!      MOVS     r1,#0
        0x08001700:    2078        x       MOVS     r0,#0x78
        0x08001702:    f001f8a5    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;74     	SSD1306_WRITECOMMAND(0x40); //--set start line address
        0x08001706:    2240        @"      MOVS     r2,#0x40
        0x08001708:    2100        .!      MOVS     r1,#0
        0x0800170a:    2078        x       MOVS     r0,#0x78
        0x0800170c:    f001f8a0    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;75     	SSD1306_WRITECOMMAND(0x81); //--set contrast control register
        0x08001710:    2281        ."      MOVS     r2,#0x81
        0x08001712:    2100        .!      MOVS     r1,#0
        0x08001714:    2078        x       MOVS     r0,#0x78
        0x08001716:    f001f89b    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;76     	SSD1306_WRITECOMMAND(0xFF);
        0x0800171a:    22ff        ."      MOVS     r2,#0xff
        0x0800171c:    2100        .!      MOVS     r1,#0
        0x0800171e:    2078        x       MOVS     r0,#0x78
        0x08001720:    f001f896    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;77     	SSD1306_WRITECOMMAND(0xA1); //--set segment re-map 0 to 127
        0x08001724:    22a1        ."      MOVS     r2,#0xa1
        0x08001726:    2100        .!      MOVS     r1,#0
        0x08001728:    2078        x       MOVS     r0,#0x78
        0x0800172a:    f001f891    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;78     	SSD1306_WRITECOMMAND(0xA6); //--set normal display
        0x0800172e:    22a6        ."      MOVS     r2,#0xa6
        0x08001730:    2100        .!      MOVS     r1,#0
        0x08001732:    2078        x       MOVS     r0,#0x78
        0x08001734:    f001f88c    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;79     	SSD1306_WRITECOMMAND(0xA8); //--set multiplex ratio(1 to 64)
        0x08001738:    22a8        ."      MOVS     r2,#0xa8
        0x0800173a:    2100        .!      MOVS     r1,#0
        0x0800173c:    2078        x       MOVS     r0,#0x78
        0x0800173e:    f001f887    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;80     	SSD1306_WRITECOMMAND(0x3F); //
        0x08001742:    223f        ?"      MOVS     r2,#0x3f
        0x08001744:    2100        .!      MOVS     r1,#0
        0x08001746:    2078        x       MOVS     r0,#0x78
        0x08001748:    f001f882    ....    BL       ssd1306_I2C_Write ; 0x8002850
;;;81     	SSD1306_WRITECOMMAND(0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content
        0x0800174c:    22a4        ."      MOVS     r2,#0xa4
        0x0800174e:    2100        .!      MOVS     r1,#0
        0x08001750:    2078        x       MOVS     r0,#0x78
        0x08001752:    f001f87d    ..}.    BL       ssd1306_I2C_Write ; 0x8002850
;;;82     	SSD1306_WRITECOMMAND(0xD3); //-set display offset
        0x08001756:    22d3        ."      MOVS     r2,#0xd3
        0x08001758:    2100        .!      MOVS     r1,#0
        0x0800175a:    2078        x       MOVS     r0,#0x78
        0x0800175c:    f001f878    ..x.    BL       ssd1306_I2C_Write ; 0x8002850
;;;83     	SSD1306_WRITECOMMAND(0x00); //-not offset
        0x08001760:    2200        ."      MOVS     r2,#0
        0x08001762:    4611        .F      MOV      r1,r2
        0x08001764:    2078        x       MOVS     r0,#0x78
        0x08001766:    f001f873    ..s.    BL       ssd1306_I2C_Write ; 0x8002850
;;;84     	SSD1306_WRITECOMMAND(0xD5); //--set display clock divide ratio/oscillator frequency
        0x0800176a:    22d5        ."      MOVS     r2,#0xd5
        0x0800176c:    2100        .!      MOVS     r1,#0
        0x0800176e:    2078        x       MOVS     r0,#0x78
        0x08001770:    f001f86e    ..n.    BL       ssd1306_I2C_Write ; 0x8002850
;;;85     	SSD1306_WRITECOMMAND(0xF0); //--set divide ratio
        0x08001774:    22f0        ."      MOVS     r2,#0xf0
        0x08001776:    2100        .!      MOVS     r1,#0
        0x08001778:    2078        x       MOVS     r0,#0x78
        0x0800177a:    f001f869    ..i.    BL       ssd1306_I2C_Write ; 0x8002850
;;;86     	SSD1306_WRITECOMMAND(0xD9); //--set pre-charge period
        0x0800177e:    22d9        ."      MOVS     r2,#0xd9
        0x08001780:    2100        .!      MOVS     r1,#0
        0x08001782:    2078        x       MOVS     r0,#0x78
        0x08001784:    f001f864    ..d.    BL       ssd1306_I2C_Write ; 0x8002850
;;;87     	SSD1306_WRITECOMMAND(0x22); //
        0x08001788:    2222        ""      MOVS     r2,#0x22
        0x0800178a:    2100        .!      MOVS     r1,#0
        0x0800178c:    2078        x       MOVS     r0,#0x78
        0x0800178e:    f001f85f    .._.    BL       ssd1306_I2C_Write ; 0x8002850
;;;88     	SSD1306_WRITECOMMAND(0xDA); //--set com pins hardware configuration
        0x08001792:    22da        ."      MOVS     r2,#0xda
        0x08001794:    2100        .!      MOVS     r1,#0
        0x08001796:    2078        x       MOVS     r0,#0x78
        0x08001798:    f001f85a    ..Z.    BL       ssd1306_I2C_Write ; 0x8002850
;;;89     	SSD1306_WRITECOMMAND(0x12);
        0x0800179c:    2212        ."      MOVS     r2,#0x12
        0x0800179e:    2100        .!      MOVS     r1,#0
        0x080017a0:    2078        x       MOVS     r0,#0x78
        0x080017a2:    f001f855    ..U.    BL       ssd1306_I2C_Write ; 0x8002850
;;;90     	SSD1306_WRITECOMMAND(0xDB); //--set vcomh
        0x080017a6:    22db        ."      MOVS     r2,#0xdb
        0x080017a8:    2100        .!      MOVS     r1,#0
        0x080017aa:    2078        x       MOVS     r0,#0x78
        0x080017ac:    f001f850    ..P.    BL       ssd1306_I2C_Write ; 0x8002850
;;;91     	SSD1306_WRITECOMMAND(0x20); //0x20,0.77xVcc
        0x080017b0:    2220         "      MOVS     r2,#0x20
        0x080017b2:    2100        .!      MOVS     r1,#0
        0x080017b4:    2078        x       MOVS     r0,#0x78
        0x080017b6:    f001f84b    ..K.    BL       ssd1306_I2C_Write ; 0x8002850
;;;92     	SSD1306_WRITECOMMAND(0x8D); //--set DC-DC enable
        0x080017ba:    228d        ."      MOVS     r2,#0x8d
        0x080017bc:    2100        .!      MOVS     r1,#0
        0x080017be:    2078        x       MOVS     r0,#0x78
        0x080017c0:    f001f846    ..F.    BL       ssd1306_I2C_Write ; 0x8002850
;;;93     	SSD1306_WRITECOMMAND(0x14); //
        0x080017c4:    2214        ."      MOVS     r2,#0x14
        0x080017c6:    2100        .!      MOVS     r1,#0
        0x080017c8:    2078        x       MOVS     r0,#0x78
        0x080017ca:    f001f841    ..A.    BL       ssd1306_I2C_Write ; 0x8002850
;;;94     	SSD1306_WRITECOMMAND(0xAF); //--turn on SSD1306 panel
        0x080017ce:    22af        ."      MOVS     r2,#0xaf
        0x080017d0:    2100        .!      MOVS     r1,#0
        0x080017d2:    2078        x       MOVS     r0,#0x78
        0x080017d4:    f001f83c    ..<.    BL       ssd1306_I2C_Write ; 0x8002850
;;;95     	
;;;96     	/* Clear screen */
;;;97     	SSD1306_Fill(SSD1306_COLOR_BLACK);
        0x080017d8:    2000        .       MOVS     r0,#0
        0x080017da:    f7ffff4f    ..O.    BL       SSD1306_Fill ; 0x800167c
;;;98     	
;;;99     	/* Update screen */
;;;100    	SSD1306_UpdateScreen();
        0x080017de:    f000f8b5    ....    BL       SSD1306_UpdateScreen ; 0x800194c
;;;101    	
;;;102    	/* Set default values */
;;;103    	SSD1306.CurrentX = 0;
        0x080017e2:    2000        .       MOVS     r0,#0
        0x080017e4:    4903        .I      LDR      r1,[pc,#12] ; [0x80017f4] = 0x2000000c
        0x080017e6:    8008        ..      STRH     r0,[r1,#0]
;;;104    	SSD1306.CurrentY = 0;
        0x080017e8:    8048        H.      STRH     r0,[r1,#2]
;;;105    	
;;;106    	/* Initialized OK */
;;;107    	SSD1306.Initialized = 1;
        0x080017ea:    2001        .       MOVS     r0,#1
        0x080017ec:    7148        Hq      STRB     r0,[r1,#5]
;;;108    	
;;;109    	/* Return OK */
;;;110    	return 1;
;;;111    }
        0x080017ee:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x080017f0:    20000004    ...     DCD    536870916
        0x080017f4:    2000000c    ...     DCD    536870924
    $t
    i.SSD1306_Putc2big
    SSD1306_Putc2big
;;;112    
;;;113    void SSD1306_ToggleInvert(void) {
;;;114    	uint16_t i;
;;;115    	
;;;116    	/* Toggle invert */
;;;117    	SSD1306.Inverted = !SSD1306.Inverted;
;;;118    	
;;;119    	/* Do memory toggle */
;;;120    	for (i = 0; i < sizeof(SSD1306_Buffer); i++) {
;;;121    		SSD1306_Buffer[i] = ~SSD1306_Buffer[i];
;;;122    	}
;;;123    }
;;;124    
;;;125    void SSD1306_Fill(uint8_t color) {
;;;126    	/* Set memory */
;;;127    	memset(SSD1306_Buffer, (color == SSD1306_COLOR_BLACK) ? 0x00 : 0xFF, SSD1306_WIDTH * SSD1306_HEIGHT / 8);
;;;128    }
;;;129    
;;;130    void SSD1306_DrawPixel(uint16_t x, uint16_t y, uint8_t color) {
;;;131    	if (
;;;132    		x >= SSD1306_WIDTH ||
;;;133    		y >= SSD1306_HEIGHT
;;;134    	) {
;;;135    		/* Error */
;;;136    		return;
;;;137    	}
;;;138    	
;;;139    	/* Check if pixels are inverted */
;;;140    	if (SSD1306.Inverted) {
;;;141    		color = (uint8_t)!color;
;;;142    	}
;;;143    	
;;;144    	/* Set color */
;;;145    	if (color == SSD1306_COLOR_WHITE) {
;;;146    		SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] |= 1 << (y % 8);
;;;147    	} else {
;;;148    		SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] &= ~(1 << (y % 8));
;;;149    	}
;;;150    }
;;;151    
;;;152    void SSD1306_GotoXY(uint16_t x, uint16_t y) {
;;;153    	/* Set write pointers */
;;;154    	SSD1306.CurrentX = x;
;;;155    	SSD1306.CurrentY = y;
;;;156    }
;;;157    
;;;158    void SSD1306_Putc2big(char ch, const FONT_INFO* Font) {
        0x080017f8:    e92d43f0    -..C    PUSH     {r4-r9,lr}
        0x080017fc:    4604        .F      MOV      r4,r0
;;;159    	char ch_index = ch - Font->startChar;
        0x080017fe:    7848        Hx      LDRB     r0,[r1,#1]
        0x08001800:    1a20         .      SUBS     r0,r4,r0
        0x08001802:    b2c2        ..      UXTB     r2,r0
;;;160    	uint16_t offset =  Font->charInfo[ch_index].offset;
        0x08001804:    6848        Hh      LDR      r0,[r1,#4]
        0x08001806:    eb000082    ....    ADD      r0,r0,r2,LSL #2
        0x0800180a:    8847        G.      LDRH     r7,[r0,#2]
;;;161    	uint16_t x = SSD1306.CurrentX, y = SSD1306.CurrentY / 8;
        0x0800180c:    481a        .H      LDR      r0,[pc,#104] ; [0x8001878] = 0x2000000c
        0x0800180e:    8805        ..      LDRH     r5,[r0,#0]
        0x08001810:    4603        .F      MOV      r3,r0
        0x08001812:    8858        X.      LDRH     r0,[r3,#2]
        0x08001814:    17c3        ..      ASRS     r3,r0,#31
        0x08001816:    eb007353    ..Ss    ADD      r3,r0,r3,LSR #29
        0x0800181a:    10de        ..      ASRS     r6,r3,#3
;;;162    	for (int h = y; h < Font->heightPages + y; h++ ){
        0x0800181c:    4630        0F      MOV      r0,r6
        0x0800181e:    e01b        ..      B        0x8001858 ; SSD1306_Putc2big + 96
;;;163    		for (int w = x; w < Font->charInfo[ch_index].widthBits+x; w++ ){
        0x08001820:    462b        +F      MOV      r3,r5
        0x08001822:    e011        ..      B        0x8001848 ; SSD1306_Putc2big + 80
        0x08001824:    46bc        .F      MOV      r12,r7
        0x08001826:    f1070801    ....    ADD      r8,r7,#1
        0x0800182a:    fa1ff788    ....    UXTH     r7,r8
        0x0800182e:    f8d19008    ....    LDR      r9,[r1,#8]
        0x08001832:    f819c00c    ....    LDRB     r12,[r9,r12]
        0x08001836:    eb0318c0    ....    ADD      r8,r3,r0,LSL #7
        0x0800183a:    f8df9040    ..@.    LDR      r9,[pc,#64] ; [0x800187c] = 0x20000008
        0x0800183e:    f8d99000    ....    LDR      r9,[r9,#0]
        0x08001842:    f809c008    ....    STRB     r12,[r9,r8]
        0x08001846:    1c5b        [.      ADDS     r3,r3,#1
        0x08001848:    f8d1c004    ....    LDR      r12,[r1,#4]
        0x0800184c:    f81cc022    ..".    LDRB     r12,[r12,r2,LSL #2]
        0x08001850:    44ac        .D      ADD      r12,r12,r5
        0x08001852:    459c        .E      CMP      r12,r3
        0x08001854:    dce6        ..      BGT      0x8001824 ; SSD1306_Putc2big + 44
        0x08001856:    1c40        @.      ADDS     r0,r0,#1
        0x08001858:    780b        .x      LDRB     r3,[r1,#0]
        0x0800185a:    4433        3D      ADD      r3,r3,r6
        0x0800185c:    4283        .B      CMP      r3,r0
        0x0800185e:    dcdf        ..      BGT      0x8001820 ; SSD1306_Putc2big + 40
;;;164    			SSD1306_Buffer[w + h * SSD1306_WIDTH] = Font->data[offset++];
;;;165    		}
;;;166    	}
;;;167    	SSD1306.CurrentX += Font->charInfo[ch_index].widthBits + 1;
        0x08001860:    6848        Hh      LDR      r0,[r1,#4]
        0x08001862:    f8100022    ..".    LDRB     r0,[r0,r2,LSL #2]
        0x08001866:    1c40        @.      ADDS     r0,r0,#1
        0x08001868:    4b03        .K      LDR      r3,[pc,#12] ; [0x8001878] = 0x2000000c
        0x0800186a:    881b        ..      LDRH     r3,[r3,#0]
        0x0800186c:    4418        .D      ADD      r0,r0,r3
        0x0800186e:    4b02        .K      LDR      r3,[pc,#8] ; [0x8001878] = 0x2000000c
        0x08001870:    8018        ..      STRH     r0,[r3,#0]
;;;168    }
        0x08001872:    e8bd83f0    ....    POP      {r4-r9,pc}
    $d
        0x08001876:    0000        ..      DCW    0
        0x08001878:    2000000c    ...     DCD    536870924
        0x0800187c:    20000008    ...     DCD    536870920
    $t
    i.SSD1306_Putc2bigInv
    SSD1306_Putc2bigInv
;;;169    
;;;170    void SSD1306_Putc2bigInv(char ch, const FONT_INFO* Font) {
        0x08001880:    e92d43f0    -..C    PUSH     {r4-r9,lr}
        0x08001884:    4604        .F      MOV      r4,r0
;;;171    	char ch_index = ch - Font->startChar;
        0x08001886:    7848        Hx      LDRB     r0,[r1,#1]
        0x08001888:    1a20         .      SUBS     r0,r4,r0
        0x0800188a:    b2c2        ..      UXTB     r2,r0
;;;172    	uint16_t offset =  Font->charInfo[ch_index].offset;
        0x0800188c:    6848        Hh      LDR      r0,[r1,#4]
        0x0800188e:    eb000082    ....    ADD      r0,r0,r2,LSL #2
        0x08001892:    8847        G.      LDRH     r7,[r0,#2]
;;;173    	uint16_t x = SSD1306.CurrentX, y = SSD1306.CurrentY / 8;
        0x08001894:    481e        .H      LDR      r0,[pc,#120] ; [0x8001910] = 0x2000000c
        0x08001896:    8805        ..      LDRH     r5,[r0,#0]
        0x08001898:    4603        .F      MOV      r3,r0
        0x0800189a:    8858        X.      LDRH     r0,[r3,#2]
        0x0800189c:    17c3        ..      ASRS     r3,r0,#31
        0x0800189e:    eb007353    ..Ss    ADD      r3,r0,r3,LSR #29
        0x080018a2:    10de        ..      ASRS     r6,r3,#3
;;;174    	for (int h = y; h < Font->heightPages + y; h++ ){
        0x080018a4:    4630        0F      MOV      r0,r6
        0x080018a6:    e023        #.      B        0x80018f0 ; SSD1306_Putc2bigInv + 112
;;;175    		for (int w = x; w < Font->charInfo[ch_index].widthBits+x; w++ ){
        0x080018a8:    462b        +F      MOV      r3,r5
        0x080018aa:    e019        ..      B        0x80018e0 ; SSD1306_Putc2bigInv + 96
        0x080018ac:    46bc        .F      MOV      r12,r7
        0x080018ae:    f1070801    ....    ADD      r8,r7,#1
        0x080018b2:    fa1ff788    ....    UXTH     r7,r8
        0x080018b6:    f8d19008    ....    LDR      r9,[r1,#8]
        0x080018ba:    f819c00c    ....    LDRB     r12,[r9,r12]
        0x080018be:    f1bc0f00    ....    CMP      r12,#0
        0x080018c2:    d102        ..      BNE      0x80018ca ; SSD1306_Putc2bigInv + 74
        0x080018c4:    f04f0c01    O...    MOV      r12,#1
        0x080018c8:    e001        ..      B        0x80018ce ; SSD1306_Putc2bigInv + 78
        0x080018ca:    f04f0c00    O...    MOV      r12,#0
        0x080018ce:    eb0318c0    ....    ADD      r8,r3,r0,LSL #7
        0x080018d2:    f8df9040    ..@.    LDR      r9,[pc,#64] ; [0x8001914] = 0x20000008
        0x080018d6:    f8d99000    ....    LDR      r9,[r9,#0]
        0x080018da:    f809c008    ....    STRB     r12,[r9,r8]
        0x080018de:    1c5b        [.      ADDS     r3,r3,#1
        0x080018e0:    f8d1c004    ....    LDR      r12,[r1,#4]
        0x080018e4:    f81cc022    ..".    LDRB     r12,[r12,r2,LSL #2]
        0x080018e8:    44ac        .D      ADD      r12,r12,r5
        0x080018ea:    459c        .E      CMP      r12,r3
        0x080018ec:    dcde        ..      BGT      0x80018ac ; SSD1306_Putc2bigInv + 44
        0x080018ee:    1c40        @.      ADDS     r0,r0,#1
        0x080018f0:    780b        .x      LDRB     r3,[r1,#0]
        0x080018f2:    4433        3D      ADD      r3,r3,r6
        0x080018f4:    4283        .B      CMP      r3,r0
        0x080018f6:    dcd7        ..      BGT      0x80018a8 ; SSD1306_Putc2bigInv + 40
;;;176    			SSD1306_Buffer[w + h * SSD1306_WIDTH] = !Font->data[offset++];
;;;177    		}
;;;178    	}
;;;179    	SSD1306.CurrentX += Font->charInfo[ch_index].widthBits + 1;
        0x080018f8:    6848        Hh      LDR      r0,[r1,#4]
        0x080018fa:    f8100022    ..".    LDRB     r0,[r0,r2,LSL #2]
        0x080018fe:    1c40        @.      ADDS     r0,r0,#1
        0x08001900:    4b03        .K      LDR      r3,[pc,#12] ; [0x8001910] = 0x2000000c
        0x08001902:    881b        ..      LDRH     r3,[r3,#0]
        0x08001904:    4418        .D      ADD      r0,r0,r3
        0x08001906:    4b02        .K      LDR      r3,[pc,#8] ; [0x8001910] = 0x2000000c
        0x08001908:    8018        ..      STRH     r0,[r3,#0]
;;;180    }
        0x0800190a:    e8bd83f0    ....    POP      {r4-r9,pc}
    $d
        0x0800190e:    0000        ..      DCW    0
        0x08001910:    2000000c    ...     DCD    536870924
        0x08001914:    20000008    ...     DCD    536870920
    $t
    i.SSD1306_Puts2
    SSD1306_Puts2
;;;181    
;;;182    char SSD1306_Puts2(char* str, const FONT_INFO* Font, uint8_t color) {
        0x08001918:    b570        p.      PUSH     {r4-r6,lr}
        0x0800191a:    4604        .F      MOV      r4,r0
        0x0800191c:    460e        .F      MOV      r6,r1
        0x0800191e:    4615        .F      MOV      r5,r2
;;;183    	/* Write characters */
;;;184    	if(color){
        0x08001920:    b14d        M.      CBZ      r5,0x8001936 ; SSD1306_Puts2 + 30
;;;185    		while (*str) {
        0x08001922:    e004        ..      B        0x800192e ; SSD1306_Puts2 + 22
        0x08001924:    7820         x      LDRB     r0,[r4,#0]
        0x08001926:    4631        1F      MOV      r1,r6
        0x08001928:    f7ffff66    ..f.    BL       SSD1306_Putc2big ; 0x80017f8
        0x0800192c:    1c64        d.      ADDS     r4,r4,#1
        0x0800192e:    7820         x      LDRB     r0,[r4,#0]
        0x08001930:    2800        .(      CMP      r0,#0
        0x08001932:    d1f7        ..      BNE      0x8001924 ; SSD1306_Puts2 + 12
        0x08001934:    e008        ..      B        0x8001948 ; SSD1306_Puts2 + 48
;;;186    			/* Write character by character */
;;;187    			SSD1306_Putc2big(*str, Font);
;;;188    			str++;
;;;189    		}
;;;190    	} else {
;;;191    		while (*str) {
        0x08001936:    e004        ..      B        0x8001942 ; SSD1306_Puts2 + 42
        0x08001938:    7820         x      LDRB     r0,[r4,#0]
        0x0800193a:    4631        1F      MOV      r1,r6
        0x0800193c:    f7ffffa0    ....    BL       SSD1306_Putc2bigInv ; 0x8001880
        0x08001940:    1c64        d.      ADDS     r4,r4,#1
        0x08001942:    7820         x      LDRB     r0,[r4,#0]
        0x08001944:    2800        .(      CMP      r0,#0
        0x08001946:    d1f7        ..      BNE      0x8001938 ; SSD1306_Puts2 + 32
;;;192    			/* Write character by character */
;;;193    			SSD1306_Putc2bigInv(*str, Font);
;;;194    			str++;
;;;195    		}
;;;196    	}
;;;197    
;;;198    	/* Everything OK, zero should be returned */
;;;199    	return *str;
        0x08001948:    7820         x      LDRB     r0,[r4,#0]
;;;200    }
        0x0800194a:    bd70        p.      POP      {r4-r6,pc}
    i.SSD1306_UpdateScreen
    SSD1306_UpdateScreen
;;;201    
;;;202    char SSD1306_Putc(char ch, FontDef_t* Font, uint8_t color) {
;;;203    	uint32_t i, b, j;
;;;204    	
;;;205    	b = 0;
;;;206    	
;;;207    	for (i = 0; i < Font->FontHeight; i++) {
;;;208    		b = Font->data[(ch - 32) * Font->FontHeight + i];
;;;209    		for (j = 0; j < Font->FontWidth; j++) {
;;;210    			if ((b << j) & 0x8000) {
;;;211    				SSD1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (uint8_t) color);
;;;212    			} else {
;;;213    				SSD1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (uint8_t) !color);
;;;214    			}
;;;215    		}
;;;216    	}
;;;217    	/* Increase pointer */
;;;218    	SSD1306.CurrentX += Font->FontWidth;
;;;219    	
;;;220    	/* Return character written */
;;;221    	return ch;
;;;222    }
;;;223    
;;;224    char SSD1306_Puts(char* str, FontDef_t* Font, uint8_t color) {
;;;225    	/* Write characters */
;;;226    	while (*str) {
;;;227    		/* Write character by character */
;;;228    		if (SSD1306_Putc(*str, Font, color) != *str) {
;;;229    			/* Return error */
;;;230    			return *str;
;;;231    		}
;;;232    		
;;;233    		/* Increase string pointer */
;;;234    		str++;
;;;235    	}
;;;236    	
;;;237    	/* Everything OK, zero should be returned */
;;;238    	return *str;
;;;239    }
;;;240     
;;;241    
;;;242    void ssd1306_I2C_Init() {
;;;243    	//MX_I2C1_Init();
;;;244    //	Activate_I2C_Master();
;;;245    
;;;246    	uint32_t p = 250000;
;;;247    	while(p>0)
;;;248    		p--;
;;;249    	//HAL_I2C_DeInit(hi2c_screen);
;;;250    	//p = 250000;
;;;251    	//while(p>0)
;;;252    	//	p--;
;;;253    	//MX_I2C1_Init();
;;;254    }
;;;255    /*
;;;256    void ssd1306_I2C_WriteMulti(uint8_t address, uint8_t reg, uint8_t* data, uint16_t count) {
;;;257    	uint8_t dt[count + 1];
;;;258    	dt[0] = reg;
;;;259    	uint8_t i;
;;;260    	for(i = 1; i <= count; i++)
;;;261    		dt[i] = data[i-1];
;;;262    //	Handle_I2C_Master(hi2c_screen, address, dt, count, 10);
;;;263    	// haltodo HAL_I2C_Master_Transmit(hi2c_screen, address, dt, count, 10);
;;;264    }
;;;265    
;;;266    
;;;267    void ssd1306_I2C_WriteMulti_DMA(uint8_t address, uint8_t reg, uint8_t* data, uint16_t count) {	
;;;268    	//haltodo HAL_I2C_Master_Transmit(hi2c_screen, address, &reg, 1, 100);
;;;269    	//haltodo HAL_I2C_Master_Transmit_DMA(hi2c_screen, address, data, count);
;;;270    }
;;;271    */
;;;272    
;;;273    void ssd1306_I2C_Write(uint8_t address, uint8_t reg, uint8_t data) {
;;;274    	uint8_t dt[2] = {reg, data};
;;;275    //	dt[0] = reg;
;;;276    //	dt[1] = data;
;;;277    	Handle_I2C_MasterDMA_IT(hi2c_screen, address, dt, 2, 10);
;;;278    //	HAL_I2C_Master_Transmit(hi2c_screen, address, dt, 2, 10);
;;;279    }
;;;280    
;;;281    void SSD1306_UpdateScreen(void) {
        0x0800194c:    b510        ..      PUSH     {r4,lr}
;;;282    	SSD1306_Buffer_all[0] = 0x40;
        0x0800194e:    2040        @       MOVS     r0,#0x40
        0x08001950:    4903        .I      LDR      r1,[pc,#12] ; [0x8001960] = 0x20000598
        0x08001952:    7008        .p      STRB     r0,[r1,#0]
;;;283    //	HAL_I2C_Master_Transmit(hi2c_screen, SSD1306_I2C_ADDR, SSD1306_Buffer_all, SSD1306_WIDTH * SSD1306_HEIGHT / 8 + 1, 100);
;;;284    	Handle_I2C_MasterDMA_IT_async(SSD1306_I2C_ADDR, SSD1306_Buffer_all, SSD1306_WIDTH * SSD1306_HEIGHT / 8 + 1);
        0x08001954:    f2404201    @..B    MOV      r2,#0x401
        0x08001958:    2078        x       MOVS     r0,#0x78
        0x0800195a:    f7fefd0d    ....    BL       Handle_I2C_MasterDMA_IT_async ; 0x8000378
;;;285    //	Handle_I2C_MasterDMA_IT(hi2c_screen, SSD1306_I2C_ADDR, SSD1306_Buffer_all, SSD1306_WIDTH * SSD1306_HEIGHT / 8 + 1, 100);
;;;286    //  if(LL_I2C_IsActiveFlag_SB(I2C2)) {
;;;287    
;;;288    	/* haltodo
;;;289    	if(hi2c_screen->hdmatx->State == HAL_DMA_STATE_READY)
;;;290    		HAL_I2C_Master_Transmit_DMA(hi2c_screen, SSD1306_I2C_ADDR, SSD1306_Buffer_all, SSD1306_WIDTH * SSD1306_HEIGHT / 8 + 1);
;;;291    //	HAL_I2C_Master_Transmit(hi2c_screen, SSD1306_I2C_ADDR, SSD1306_Buffer_all, SSD1306_WIDTH * SSD1306_HEIGHT / 8 + 1, 100);
;;;292    //	while(HAL_DMA_GetState(hi2c_screen->hdmatx) != HAL_DMA_STATE_READY)
;;;293    //	{
;;;294    //		HAL_Delay(1); //Change for your RTOS
;;;295    //	}
;;;296    	*/
;;;297    //	}
;;;298    }
        0x0800195e:    bd10        ..      POP      {r4,pc}
    $d
        0x08001960:    20000598    ...     DCD    536872344
    $t
    i.SVC_Handler
    SVC_Handler
;;; .\../Src/stm32f1xx_it.c
;;;96     }
        0x08001964:    4770        pG      BX       lr
        0x08001966:    0000        ..      MOVS     r0,r0
    i.SysTick_Handler
    SysTick_Handler
;;;97     
;;;98     /**
;;;99     * @brief This function handles Pendable request for system service.
;;;100    */
;;;101    void PendSV_Handler(void)
;;;102    {
;;;103      /* USER CODE BEGIN PendSV_IRQn 0 */
;;;104    
;;;105      /* USER CODE END PendSV_IRQn 0 */
;;;106      /* USER CODE BEGIN PendSV_IRQn 1 */
;;;107    
;;;108      /* USER CODE END PendSV_IRQn 1 */
;;;109    }
;;;110    
;;;111    /**
;;;112    * @brief This function handles System tick timer.
;;;113    */
;;;114    void SysTick_Handler(void)
;;;115    {
;;;116      /* USER CODE BEGIN SysTick_IRQn 0 */
;;;117    
;;;118      /* USER CODE END SysTick_IRQn 0 */
;;;119      
;;;120      /* USER CODE BEGIN SysTick_IRQn 1 */
;;;121    
;;;122    /*
;;;123    #if  defined ( _SIMU )
;;;124    
;;;125    //simulate spindle
;;;126    	if(++tacho_cnt == 1800 ) {
;;;127    		tacho_debug = 1;
;;;128    		tacho_cnt = 0;
;;;129    		TIM4_IRQHandler();
;;;130    	}
;;;131    	if(++TIM4->CNT > TIM4->ARR) {
;;;132    		TIM4->CNT = 0; // overflow emulation
;;;133    		encoder = true;
;;;134    		TIM4_IRQHandler();
;;;135    	}
;;;136    #endif
;;;137    */
;;;138    //      if(auto_mode_delay > 0)
;;;139    //              auto_mode_delay--;
;;;140    	for(int a = 0; a<BT_TOTAL;a++){
        0x08001968:    2000        .       MOVS     r0,#0
;;; .\../Src/stm32f1xx_it.c (140)
        0x0800196a:    e00e        ..      B        0x800198a ; SysTick_Handler + 34
        0x0800196c:    4908        .I      LDR      r1,[pc,#32] ; [0x8001990] = 0x20000a14
        0x0800196e:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x08001972:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001974:    b141        A.      CBZ      r1,0x8001988 ; SysTick_Handler + 32
        0x08001976:    4906        .I      LDR      r1,[pc,#24] ; [0x8001990] = 0x20000a14
        0x08001978:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x0800197c:    6909        .i      LDR      r1,[r1,#0x10]
        0x0800197e:    1c49        I.      ADDS     r1,r1,#1
        0x08001980:    4a03        .J      LDR      r2,[pc,#12] ; [0x8001990] = 0x20000a14
        0x08001982:    eb021240    ..@.    ADD      r2,r2,r0,LSL #5
        0x08001986:    6111        .a      STR      r1,[r2,#0x10]
        0x08001988:    1c40        @.      ADDS     r0,r0,#1
        0x0800198a:    2801        .(      CMP      r0,#1
        0x0800198c:    dbee        ..      BLT      0x800196c ; SysTick_Handler + 4
;;;141    		if( bt[a].buttons_mstick > 0 )
;;;142    			bt[a].buttons_mstick++;
;;;143    	}
;;;144      /* USER CODE END SysTick_IRQn 1 */
;;;145    }
        0x0800198e:    4770        pG      BX       lr
    $d
        0x08001990:    20000a14    ...     DCD    536873492
    $t
    i.SystemClock_Config
    SystemClock_Config
;;; .\../Src/main.c
;;;497    {
        0x08001994:    b570        p.      PUSH     {r4-r6,lr}
;;;498    
;;;499      LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
        0x08001996:    2002        .       MOVS     r0,#2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_system.h
;;;488      MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
        0x08001998:    494a        JI      LDR      r1,[pc,#296] ; [0x8001ac4] = 0x40022000
        0x0800199a:    6809        .h      LDR      r1,[r1,#0]
        0x0800199c:    f0210107    !...    BIC      r1,r1,#7
        0x080019a0:    4301        .C      ORRS     r1,r1,r0
        0x080019a2:    4a48        HJ      LDR      r2,[pc,#288] ; [0x8001ac4] = 0x40022000
        0x080019a4:    6011        .`      STR      r1,[r2,#0]
;;;489    }
        0x080019a6:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;501       if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
        0x080019a8:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_system.h
;;;501      return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
        0x080019aa:    4610        .F      MOV      r0,r2
        0x080019ac:    6800        .h      LDR      r0,[r0,#0]
        0x080019ae:    f0000007    ....    AND      r0,r0,#7
        0x080019b2:    2802        .(      CMP      r0,#2
        0x080019b4:    d004        ..      BEQ      0x80019c0 ; SystemClock_Config + 44
;;; .\../Src/main.c
;;;503        Error_Handler();  
        0x080019b6:    f24011f7    @...    MOV      r1,#0x1f7
        0x080019ba:    a043        C.      ADR      r0,{pc}+0x10e ; 0x8001ac8
        0x080019bc:    f000f970    ..p.    BL       _Error_Handler ; 0x8001ca0
;;;504      }
;;;505      LL_RCC_HSE_Enable();
        0x080019c0:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;792      SET_BIT(RCC->CR, RCC_CR_HSEON);
        0x080019c2:    4845        EH      LDR      r0,[pc,#276] ; [0x8001ad8] = 0x40021000
        0x080019c4:    6800        .h      LDR      r0,[r0,#0]
        0x080019c6:    f4403080    @..0    ORR      r0,r0,#0x10000
        0x080019ca:    4943        CI      LDR      r1,[pc,#268] ; [0x8001ad8] = 0x40021000
        0x080019cc:    6008        .`      STR      r0,[r1,#0]
;;;793    }
        0x080019ce:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;508      while(LL_RCC_HSE_IsReady() != 1)
        0x080019d0:    bf00        ..      NOP      
        0x080019d2:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;812      return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
        0x080019d4:    4840        @H      LDR      r0,[pc,#256] ; [0x8001ad8] = 0x40021000
        0x080019d6:    6800        .h      LDR      r0,[r0,#0]
        0x080019d8:    f3c04040    ..@@    UBFX     r0,r0,#17,#1
        0x080019dc:    2800        .(      CMP      r0,#0
        0x080019de:    d0f8        ..      BEQ      0x80019d2 ; SystemClock_Config + 62
;;; .\../Src/main.c
;;;512      LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE_DIV_1, LL_RCC_PLL_MUL_9);
        0x080019e0:    f44f3080    O..0    MOV      r0,#0x10000
        0x080019e4:    f44f11e0    O...    MOV      r1,#0x1c0000
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1495     MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
        0x080019e8:    4a3b        ;J      LDR      r2,[pc,#236] ; [0x8001ad8] = 0x40021000
        0x080019ea:    6852        Rh      LDR      r2,[r2,#4]
        0x080019ec:    f422127c    ".|.    BIC      r2,r2,#0x3f0000
        0x080019f0:    f4003340    ..@3    AND      r3,r0,#0x30000
        0x080019f4:    430b        .C      ORRS     r3,r3,r1
        0x080019f6:    431a        .C      ORRS     r2,r2,r3
        0x080019f8:    4b37        7K      LDR      r3,[pc,#220] ; [0x8001ad8] = 0x40021000
        0x080019fa:    605a        Z`      STR      r2,[r3,#4]
;;;1496                (Source & (RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE)) | PLLMul);
;;;1497   #if defined(RCC_CFGR2_PREDIV1)
;;;1498   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1499     MODIFY_REG(RCC->CFGR2, (RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC),
;;;1500                (Source & RCC_CFGR2_PREDIV1) | ((Source & (RCC_CFGR2_PREDIV1SRC << 4U)) >> 4U));
;;;1501   #else
;;;1502     MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV1, (Source & RCC_CFGR2_PREDIV1));
;;;1503   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1504   #endif /*RCC_CFGR2_PREDIV1*/
;;;1505   }
        0x080019fc:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;514      LL_RCC_PLL_Enable();
        0x080019fe:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1405     SET_BIT(RCC->CR, RCC_CR_PLLON);
        0x08001a00:    4618        .F      MOV      r0,r3
        0x08001a02:    6800        .h      LDR      r0,[r0,#0]
        0x08001a04:    f0407080    @..p    ORR      r0,r0,#0x1000000
        0x08001a08:    4619        .F      MOV      r1,r3
        0x08001a0a:    6008        .`      STR      r0,[r1,#0]
;;;1406   }
        0x08001a0c:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;517      while(LL_RCC_PLL_IsReady() != 1)
        0x08001a0e:    bf00        ..      NOP      
        0x08001a10:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1426     return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
        0x08001a12:    4831        1H      LDR      r0,[pc,#196] ; [0x8001ad8] = 0x40021000
        0x08001a14:    6800        .h      LDR      r0,[r0,#0]
        0x08001a16:    f3c06040    ..@`    UBFX     r0,r0,#25,#1
        0x08001a1a:    2800        .(      CMP      r0,#0
        0x08001a1c:    d0f8        ..      BEQ      0x8001a10 ; SystemClock_Config + 124
;;; .\../Src/main.c
;;;521      LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
        0x08001a1e:    2000        .       MOVS     r0,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1065     MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
        0x08001a20:    492d        -I      LDR      r1,[pc,#180] ; [0x8001ad8] = 0x40021000
        0x08001a22:    6849        Ih      LDR      r1,[r1,#4]
        0x08001a24:    f02101f0    !...    BIC      r1,r1,#0xf0
        0x08001a28:    4301        .C      ORRS     r1,r1,r0
        0x08001a2a:    4a2b        +J      LDR      r2,[pc,#172] ; [0x8001ad8] = 0x40021000
        0x08001a2c:    6051        Q`      STR      r1,[r2,#4]
;;;1066   }
        0x08001a2e:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;523      LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_2);
        0x08001a30:    1510        ..      ASRS     r0,r2,#20
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1081     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
        0x08001a32:    4611        .F      MOV      r1,r2
        0x08001a34:    6849        Ih      LDR      r1,[r1,#4]
        0x08001a36:    f42161e0    !..a    BIC      r1,r1,#0x700
        0x08001a3a:    4301        .C      ORRS     r1,r1,r0
        0x08001a3c:    6051        Q`      STR      r1,[r2,#4]
;;;1082   }
        0x08001a3e:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;525      LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1);
        0x08001a40:    2000        .       MOVS     r0,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1097     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
        0x08001a42:    4611        .F      MOV      r1,r2
        0x08001a44:    6849        Ih      LDR      r1,[r1,#4]
        0x08001a46:    f4215160    !.`Q    BIC      r1,r1,#0x3800
        0x08001a4a:    4301        .C      ORRS     r1,r1,r0
        0x08001a4c:    6051        Q`      STR      r1,[r2,#4]
;;;1098   }
        0x08001a4e:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;527      LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
        0x08001a50:    2002        .       MOVS     r0,#2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1032     MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
        0x08001a52:    4611        .F      MOV      r1,r2
        0x08001a54:    6849        Ih      LDR      r1,[r1,#4]
        0x08001a56:    f0210103    !...    BIC      r1,r1,#3
        0x08001a5a:    4301        .C      ORRS     r1,r1,r0
        0x08001a5c:    6051        Q`      STR      r1,[r2,#4]
;;;1033   }
        0x08001a5e:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;530      while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
        0x08001a60:    bf00        ..      NOP      
        0x08001a62:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1045     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
        0x08001a64:    481c        .H      LDR      r0,[pc,#112] ; [0x8001ad8] = 0x40021000
        0x08001a66:    6840        @h      LDR      r0,[r0,#4]
        0x08001a68:    f000000c    ....    AND      r0,r0,#0xc
        0x08001a6c:    2808        .(      CMP      r0,#8
        0x08001a6e:    d1f8        ..      BNE      0x8001a62 ; SystemClock_Config + 206
;;; .\../Src/main.c
;;;534      LL_Init1msTick(72000000);
        0x08001a70:    481a        .H      LDR      r0,[pc,#104] ; [0x8001adc] = 0x44aa200
        0x08001a72:    f7feff25    ..%.    BL       LL_Init1msTick ; 0x80008c0
;;;535    
;;;536      LL_SYSTICK_SetClkSource(LL_SYSTICK_CLKSOURCE_HCLK);
        0x08001a76:    2004        .       MOVS     r0,#4
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;262      if (Source == LL_SYSTICK_CLKSOURCE_HCLK)
        0x08001a78:    2804        .(      CMP      r0,#4
        0x08001a7a:    d108        ..      BNE      0x8001a8e ; SystemClock_Config + 250
;;;263      {
;;;264        SET_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
        0x08001a7c:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08001a80:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001a82:    f0410104    A...    ORR      r1,r1,#4
        0x08001a86:    f04f22e0    O.."    MOV      r2,#0xe000e000
        0x08001a8a:    6111        .a      STR      r1,[r2,#0x10]
        0x08001a8c:    e007        ..      B        0x8001a9e ; SystemClock_Config + 266
;;;265      }
;;;266      else
;;;267      {
;;;268        CLEAR_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
        0x08001a8e:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08001a92:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001a94:    f0210104    !...    BIC      r1,r1,#4
        0x08001a98:    f04f22e0    O.."    MOV      r2,#0xe000e000
        0x08001a9c:    6111        .a      STR      r1,[r2,#0x10]
;;;269      }
;;;270    }
        0x08001a9e:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;538      LL_SetSystemCoreClock(72000000);
        0x08001aa0:    480e        .H      LDR      r0,[pc,#56] ; [0x8001adc] = 0x44aa200
        0x08001aa2:    f7feff2d    ..-.    BL       LL_SetSystemCoreClock ; 0x8000900
;;;539    
;;;540      /* SysTick_IRQn interrupt configuration */
;;;541      NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x08001aa6:    f7fffc5d    ..].    BL       NVIC_GetPriorityGrouping ; 0x8001364
        0x08001aaa:    4605        .F      MOV      r5,r0
        0x08001aac:    2200        ."      MOVS     r2,#0
        0x08001aae:    4611        .F      MOV      r1,r2
        0x08001ab0:    f7fffc37    ..7.    BL       NVIC_EncodePriority ; 0x8001322
        0x08001ab4:    4604        .F      MOV      r4,r0
        0x08001ab6:    4621        !F      MOV      r1,r4
        0x08001ab8:    f04f30ff    O..0    MOV      r0,#0xffffffff
        0x08001abc:    f7fffc5a    ..Z.    BL       NVIC_SetPriority ; 0x8001374
;;;542    }
        0x08001ac0:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001ac2:    0000        ..      DCW    0
        0x08001ac4:    40022000    . .@    DCD    1073881088
        0x08001ac8:    532f2e2e    ../S    DCD    1395600942
        0x08001acc:    6d2f6372    rc/m    DCD    1831822194
        0x08001ad0:    2e6e6961    ain.    DCD    778987873
        0x08001ad4:    00000063    c...    DCD    99
        0x08001ad8:    40021000    ...@    DCD    1073876992
        0x08001adc:    044aa200    ..J.    DCD    72000000
    $t
    i.SystemInit
    SystemInit
;;; .\..//Src/system_stm32f1xx.c
;;;179      RCC->CR |= (uint32_t)0x00000001;
        0x08001ae0:    4811        .H      LDR      r0,[pc,#68] ; [0x8001b28] = 0x40021000
        0x08001ae2:    6800        .h      LDR      r0,[r0,#0]
        0x08001ae4:    f0400001    @...    ORR      r0,r0,#1
        0x08001ae8:    490f        .I      LDR      r1,[pc,#60] ; [0x8001b28] = 0x40021000
        0x08001aea:    6008        .`      STR      r0,[r1,#0]
;;;180    
;;;181      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;182    #if !defined(STM32F105xC) && !defined(STM32F107xC)
;;;183      RCC->CFGR &= (uint32_t)0xF8FF0000;
        0x08001aec:    4608        .F      MOV      r0,r1
        0x08001aee:    6840        @h      LDR      r0,[r0,#4]
        0x08001af0:    490e        .I      LDR      r1,[pc,#56] ; [0x8001b2c] = 0xf8ff0000
        0x08001af2:    4008        .@      ANDS     r0,r0,r1
        0x08001af4:    490c        .I      LDR      r1,[pc,#48] ; [0x8001b28] = 0x40021000
        0x08001af6:    6048        H`      STR      r0,[r1,#4]
;;;184    #else
;;;185      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;186    #endif /* STM32F105xC */   
;;;187      
;;;188      /* Reset HSEON, CSSON and PLLON bits */
;;;189      RCC->CR &= (uint32_t)0xFEF6FFFF;
        0x08001af8:    4608        .F      MOV      r0,r1
        0x08001afa:    6800        .h      LDR      r0,[r0,#0]
        0x08001afc:    490c        .I      LDR      r1,[pc,#48] ; [0x8001b30] = 0xfef6ffff
        0x08001afe:    4008        .@      ANDS     r0,r0,r1
        0x08001b00:    4909        .I      LDR      r1,[pc,#36] ; [0x8001b28] = 0x40021000
        0x08001b02:    6008        .`      STR      r0,[r1,#0]
;;;190    
;;;191      /* Reset HSEBYP bit */
;;;192      RCC->CR &= (uint32_t)0xFFFBFFFF;
        0x08001b04:    4608        .F      MOV      r0,r1
        0x08001b06:    6800        .h      LDR      r0,[r0,#0]
        0x08001b08:    f4202080     ..     BIC      r0,r0,#0x40000
        0x08001b0c:    6008        .`      STR      r0,[r1,#0]
;;;193    
;;;194      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;195      RCC->CFGR &= (uint32_t)0xFF80FFFF;
        0x08001b0e:    4608        .F      MOV      r0,r1
        0x08001b10:    6840        @h      LDR      r0,[r0,#4]
        0x08001b12:    f42000fe     ...    BIC      r0,r0,#0x7f0000
        0x08001b16:    6048        H`      STR      r0,[r1,#4]
;;;196    
;;;197    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;198      /* Reset PLL2ON and PLL3ON bits */
;;;199      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;200    
;;;201      /* Disable all interrupts and clear pending bits  */
;;;202      RCC->CIR = 0x00FF0000;
;;;203    
;;;204      /* Reset CFGR2 register */
;;;205      RCC->CFGR2 = 0x00000000;
;;;206    #elif defined(STM32F100xB) || defined(STM32F100xE)
;;;207      /* Disable all interrupts and clear pending bits  */
;;;208      RCC->CIR = 0x009F0000;
;;;209    
;;;210      /* Reset CFGR2 register */
;;;211      RCC->CFGR2 = 0x00000000;      
;;;212    #else
;;;213      /* Disable all interrupts and clear pending bits  */
;;;214      RCC->CIR = 0x009F0000;
        0x08001b18:    f44f001f    O...    MOV      r0,#0x9f0000
        0x08001b1c:    6088        .`      STR      r0,[r1,#8]
;;;215    #endif /* STM32F105xC */
;;;216        
;;;217    #if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)
;;;218      #ifdef DATA_IN_ExtSRAM
;;;219        SystemInit_ExtMemCtl(); 
;;;220      #endif /* DATA_IN_ExtSRAM */
;;;221    #endif 
;;;222    
;;;223    #ifdef VECT_TAB_SRAM
;;;224      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;225    #else
;;;226      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
        0x08001b1e:    03c8        ..      LSLS     r0,r1,#15
        0x08001b20:    4904        .I      LDR      r1,[pc,#16] ; [0x8001b34] = 0xe000ed08
        0x08001b22:    6008        .`      STR      r0,[r1,#0]
;;;227    #endif 
;;;228    }
        0x08001b24:    4770        pG      BX       lr
    $d
        0x08001b26:    0000        ..      DCW    0
        0x08001b28:    40021000    ...@    DCD    1073876992
        0x08001b2c:    f8ff0000    ....    DCD    4177461248
        0x08001b30:    fef6ffff    ....    DCD    4277600255
        0x08001b34:    e000ed08    ....    DCD    3758157064
    $t
    i.TIM1_UP_IRQHandler
    TIM1_UP_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;182    {
        0x08001b38:    b510        ..      PUSH     {r4,lr}
;;;183      /* USER CODE BEGIN TIM1_UP_IRQn 0 */
;;;184    
;;;185      /* USER CODE END TIM1_UP_IRQn 0 */
;;;186      /* USER CODE BEGIN TIM1_UP_IRQn 1 */
;;;187      if(LL_TIM_IsActiveFlag_UPDATE(TIM1) == 1)
        0x08001b3a:    4806        .H      LDR      r0,[pc,#24] ; [0x8001b54] = 0x40012c00
        0x08001b3c:    f7fff82e    ....    BL       LL_TIM_IsActiveFlag_UPDATE ; 0x8000b9c
        0x08001b40:    2801        .(      CMP      r0,#1
        0x08001b42:    d105        ..      BNE      0x8001b50 ; TIM1_UP_IRQHandler + 24
;;;188      {
;;;189        /* Clear the update interrupt flag*/
;;;190        LL_TIM_ClearFlag_UPDATE(TIM1);
        0x08001b44:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2929     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x08001b46:    1ec0        ..      SUBS     r0,r0,#3
        0x08001b48:    4902        .I      LDR      r1,[pc,#8] ; [0x8001b54] = 0x40012c00
        0x08001b4a:    6108        .a      STR      r0,[r1,#0x10]
;;;2930   }
        0x08001b4c:    bf00        ..      NOP      
        0x08001b4e:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;194    }
        0x08001b50:    bd10        ..      POP      {r4,pc}
    $d
        0x08001b52:    0000        ..      DCW    0
        0x08001b54:    40012c00    .,.@    DCD    1073818624
    $t
    i.TIM2_IRQHandler
    TIM2_IRQHandler
;;;195    
;;;196    /**
;;;197    * @brief This function handles TIM2 global interrupt.
;;;198    */
;;;199    void TIM2_IRQHandler(void)
;;;200    {
        0x08001b58:    b510        ..      PUSH     {r4,lr}
;;;201      /* USER CODE BEGIN TIM2_IRQn 0 */
;;;202    // prescaler=((((speed=72000000)/((period=20000)/(1/hz=1)))+0,5)-1)
;;;203    //	if ( async_z == 1) {
;;;204    	if ( state.async_z == 1) {
        0x08001b5a:    481a        .H      LDR      r0,[pc,#104] ; [0x8001bc4] = 0x20000134
        0x08001b5c:    6840        @h      LDR      r0,[r0,#4]
        0x08001b5e:    2801        .(      CMP      r0,#1
        0x08001b60:    d121        !.      BNE      0x8001ba6 ; TIM2_IRQHandler + 78
;;;205    //		state.f_encoder = encoder;
;;;206    //		state.f_tacho = t4sr[TIM_SR_CC3IF_Pos];
;;;207    //		LED_GPIO_Port->BSRR = LED_Pin;   // led off
;;;208    //		LED_GPIO_Port->BRR = LED_Pin;
;;;209    //    HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
;;;210        LL_GPIO_TogglePin( LED_GPIO_Port, LED_Pin);
        0x08001b62:    4819        .H      LDR      r0,[pc,#100] ; [0x8001bc8] = 0x4200020
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;880      WRITE_REG(GPIOx->ODR, READ_REG(GPIOx->ODR) ^ ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x08001b64:    4919        .I      LDR      r1,[pc,#100] ; [0x8001bcc] = 0x40011000
        0x08001b66:    68c9        .h      LDR      r1,[r1,#0xc]
        0x08001b68:    f3c0220f    ..."    UBFX     r2,r0,#8,#16
        0x08001b6c:    4051        Q@      EORS     r1,r1,r2
        0x08001b6e:    4a17        .J      LDR      r2,[pc,#92] ; [0x8001bcc] = 0x40011000
        0x08001b70:    60d1        .`      STR      r1,[r2,#0xc]
;;;881    }
        0x08001b72:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;212    		state.function(&state);
        0x08001b74:    4813        .H      LDR      r0,[pc,#76] ; [0x8001bc4] = 0x20000134
        0x08001b76:    6801        .h      LDR      r1,[r0,#0]
        0x08001b78:    4788        .G      BLX      r1
;;;213    
;;;214    		TIM2->ARR = state.z_period;
        0x08001b7a:    4812        .H      LDR      r0,[pc,#72] ; [0x8001bc4] = 0x20000134
        0x08001b7c:    7b00        .{      LDRB     r0,[r0,#0xc]
        0x08001b7e:    f04f4180    O..A    MOV      r1,#0x40000000
        0x08001b82:    62c8        .b      STR      r0,[r1,#0x2c]
;;;215    		TIM2->EGR |= TIM_EGR_UG;
        0x08001b84:    4608        .F      MOV      r0,r1
        0x08001b86:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001b88:    f0400001    @...    ORR      r0,r0,#1
        0x08001b8c:    6148        Ha      STR      r0,[r1,#0x14]
;;;216    
;;;217    		text_buffer[tbc++] = TIM2->ARR;
        0x08001b8e:    4608        .F      MOV      r0,r1
        0x08001b90:    6ac0        .j      LDR      r0,[r0,#0x2c]
        0x08001b92:    b281        ..      UXTH     r1,r0
        0x08001b94:    480e        .H      LDR      r0,[pc,#56] ; [0x8001bd0] = 0x20000594
        0x08001b96:    6802        .h      LDR      r2,[r0,#0]
        0x08001b98:    6800        .h      LDR      r0,[r0,#0]
        0x08001b9a:    1c40        @.      ADDS     r0,r0,#1
        0x08001b9c:    4b0c        .K      LDR      r3,[pc,#48] ; [0x8001bd0] = 0x20000594
        0x08001b9e:    6018        .`      STR      r0,[r3,#0]
        0x08001ba0:    480c        .H      LDR      r0,[pc,#48] ; [0x8001bd4] = 0x20000a68
        0x08001ba2:    f8201012     ...    STRH     r1,[r0,r2,LSL #1]
;;;218    	}
;;;219    
;;;220      /* USER CODE END TIM2_IRQn 0 */
;;;221      /* USER CODE BEGIN TIM2_IRQn 1 */
;;;222      /* Check whether update interrupt is pending */
;;;223      if(LL_TIM_IsActiveFlag_UPDATE(TIM2) == 1)
        0x08001ba6:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08001baa:    f7fefff7    ....    BL       LL_TIM_IsActiveFlag_UPDATE ; 0x8000b9c
        0x08001bae:    2801        .(      CMP      r0,#1
        0x08001bb0:    d106        ..      BNE      0x8001bc0 ; TIM2_IRQHandler + 104
;;;224      {
;;;225        /* Clear the update interrupt flag*/
;;;226        LL_TIM_ClearFlag_UPDATE(TIM2);
        0x08001bb2:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2929     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x08001bb4:    1ec0        ..      SUBS     r0,r0,#3
        0x08001bb6:    f04f4180    O..A    MOV      r1,#0x40000000
        0x08001bba:    6108        .a      STR      r0,[r1,#0x10]
;;;2930   }
        0x08001bbc:    bf00        ..      NOP      
        0x08001bbe:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;229    }
        0x08001bc0:    bd10        ..      POP      {r4,pc}
    $d
        0x08001bc2:    0000        ..      DCW    0
        0x08001bc4:    20000134    4..     DCD    536871220
        0x08001bc8:    04200020     . .    DCD    69206048
        0x08001bcc:    40011000    ...@    DCD    1073811456
        0x08001bd0:    20000594    ...     DCD    536872340
        0x08001bd4:    20000a68    h..     DCD    536873576
    $t
    i.TIM4_IRQHandler
    TIM4_IRQHandler
;;;230    
;;;231    /**
;;;232    * @brief This function handles TIM4 global interrupt.
;;;233    */
;;;234    void TIM4_IRQHandler(void)
;;;235    {
        0x08001bd8:    b510        ..      PUSH     {r4,lr}
;;;236      /* USER CODE BEGIN TIM4_IRQn 0 */
;;;237    //	_Bool dir = t4cr1[TIM_CR1_DIR_Pos];
;;;238    //	if(t4sr[TIM_SR_CC3IF_Pos]){
;;;239    //		do_fsm_wait_tacho(&state);
;;;240    //	}
;;;241    	if (state.sync == true) {
        0x08001bda:    4812        .H      LDR      r0,[pc,#72] ; [0x8001c24] = 0x20000134
        0x08001bdc:    7c00        .|      LDRB     r0,[r0,#0x10]
        0x08001bde:    2801        .(      CMP      r0,#1
        0x08001be0:    d11b        ..      BNE      0x8001c1a ; TIM4_IRQHandler + 66
;;;242    		state.spindle_dir = t4cr1[TIM_CR1_DIR_Pos];
        0x08001be2:    4811        .H      LDR      r0,[pc,#68] ; [0x8001c28] = 0x42010000
        0x08001be4:    6900        .i      LDR      r0,[r0,#0x10]
        0x08001be6:    b108        ..      CBZ      r0,0x8001bec ; TIM4_IRQHandler + 20
        0x08001be8:    2001        .       MOVS     r0,#1
        0x08001bea:    e000        ..      B        0x8001bee ; TIM4_IRQHandler + 22
        0x08001bec:    2000        .       MOVS     r0,#0
        0x08001bee:    490d        .I      LDR      r1,[pc,#52] ; [0x8001c24] = 0x20000134
        0x08001bf0:    73c8        .s      STRB     r0,[r1,#0xf]
;;;243    		state.f_encoder = encoder;
        0x08001bf2:    480e        .H      LDR      r0,[pc,#56] ; [0x8001c2c] = 0x42010200
        0x08001bf4:    6800        .h      LDR      r0,[r0,#0]
        0x08001bf6:    b108        ..      CBZ      r0,0x8001bfc ; TIM4_IRQHandler + 36
        0x08001bf8:    2001        .       MOVS     r0,#1
        0x08001bfa:    e000        ..      B        0x8001bfe ; TIM4_IRQHandler + 38
        0x08001bfc:    2000        .       MOVS     r0,#0
        0x08001bfe:    4909        .I      LDR      r1,[pc,#36] ; [0x8001c24] = 0x20000134
        0x08001c00:    7348        Hs      STRB     r0,[r1,#0xd]
;;;244    		state.f_tacho = t4sr[TIM_SR_CC3IF_Pos];
        0x08001c02:    480a        .H      LDR      r0,[pc,#40] ; [0x8001c2c] = 0x42010200
        0x08001c04:    300c        .0      ADDS     r0,r0,#0xc
        0x08001c06:    6800        .h      LDR      r0,[r0,#0]
        0x08001c08:    b108        ..      CBZ      r0,0x8001c0e ; TIM4_IRQHandler + 54
        0x08001c0a:    2001        .       MOVS     r0,#1
        0x08001c0c:    e000        ..      B        0x8001c10 ; TIM4_IRQHandler + 56
        0x08001c0e:    2000        .       MOVS     r0,#0
        0x08001c10:    4904        .I      LDR      r1,[pc,#16] ; [0x8001c24] = 0x20000134
        0x08001c12:    7388        .s      STRB     r0,[r1,#0xe]
;;;245    		state.function(&state);
        0x08001c14:    4608        .F      MOV      r0,r1
        0x08001c16:    6801        .h      LDR      r1,[r0,#0]
        0x08001c18:    4788        .G      BLX      r1
;;;246    	}
;;;247    //	TIM4->SR &= ~TIM_SR_UIF; //Сбрасываем бит вызова прерывания. 
;;;248    
;;;249      /* USER CODE END TIM4_IRQn 0 */
;;;250      /* USER CODE BEGIN TIM4_IRQn 1 */
;;;251      /* Check whether update interrupt is pending */
;;;252    //	if(LL_TIM_IsActiveFlag_CC2OVR(TIM4) == 1){
;;;253    //		TIM4->SR = 0;
;;;254    //	}
;;;255    	TIM4->SR = 0;
        0x08001c1a:    2000        .       MOVS     r0,#0
        0x08001c1c:    4904        .I      LDR      r1,[pc,#16] ; [0x8001c30] = 0x40000810
        0x08001c1e:    6008        .`      STR      r0,[r1,#0]
;;;256    /*
;;;257    	if(LL_TIM_IsActiveFlag_CC2(TIM4) == 1)
;;;258        LL_TIM_ClearFlag_CC2(TIM4);
;;;259    	if(LL_TIM_IsActiveFlag_CC3(TIM4) == 1)
;;;260        LL_TIM_ClearFlag_CC3(TIM4);
;;;261    	if(LL_TIM_IsActiveFlag_UPDATE(TIM4) == 1)
;;;262      {
;;;263        LL_TIM_ClearFlag_UPDATE(TIM4); //Clear the update interrupt flag
;;;264      }
;;;265    */
;;;266      /* USER CODE END TIM4_IRQn 1 */
;;;267    }
        0x08001c20:    bd10        ..      POP      {r4,pc}
    $d
        0x08001c22:    0000        ..      DCW    0
        0x08001c24:    20000134    4..     DCD    536871220
        0x08001c28:    42010000    ...B    DCD    1107361792
        0x08001c2c:    42010200    ...B    DCD    1107362304
        0x08001c30:    40000810    ...@    DCD    1073743888
    $t
    i.Transfer_Complete_Callback
    Transfer_Complete_Callback
;;; .\..\Src\i2c_interface.c
;;;320    {
        0x08001c34:    b510        ..      PUSH     {r4,lr}
;;;321      /* Generate Stop condition */
;;;322    	while(!LL_I2C_IsActiveFlag_BTF(I2C2))
        0x08001c36:    bf00        ..      NOP      
        0x08001c38:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1160     return (READ_BIT(I2Cx->SR1, I2C_SR1_BTF) == (I2C_SR1_BTF));
        0x08001c3a:    480f        .H      LDR      r0,[pc,#60] ; [0x8001c78] = 0x40005800
        0x08001c3c:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001c3e:    f3c00080    ....    UBFX     r0,r0,#2,#1
        0x08001c42:    2800        .(      CMP      r0,#0
        0x08001c44:    d0f8        ..      BEQ      0x8001c38 ; Transfer_Complete_Callback + 4
;;; .\..\Src\i2c_interface.c
;;;325      LL_I2C_GenerateStopCondition(I2C2);
        0x08001c46:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1596     SET_BIT(I2Cx->CR1, I2C_CR1_STOP);
        0x08001c48:    480b        .H      LDR      r0,[pc,#44] ; [0x8001c78] = 0x40005800
        0x08001c4a:    6800        .h      LDR      r0,[r0,#0]
        0x08001c4c:    f4407000    @..p    ORR      r0,r0,#0x200
        0x08001c50:    4909        .I      LDR      r1,[pc,#36] ; [0x8001c78] = 0x40005800
        0x08001c52:    6008        .`      STR      r0,[r1,#0]
;;;1597   }
        0x08001c54:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;326      LL_DMA_DisableChannel(DMA1, LL_DMA_CHANNEL_4);
        0x08001c56:    4809        .H      LDR      r0,[pc,#36] ; [0x8001c7c] = 0x40020000
        0x08001c58:    2104        .!      MOVS     r1,#4
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;491      CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
        0x08001c5a:    1e4a        J.      SUBS     r2,r1,#1
        0x08001c5c:    4b08        .K      LDR      r3,[pc,#32] ; [0x8001c80] = 0x8003da4
        0x08001c5e:    5c9a        .\      LDRB     r2,[r3,r2]
        0x08001c60:    5882        .X      LDR      r2,[r0,r2]
        0x08001c62:    f0220301    "...    BIC      r3,r2,#1
        0x08001c66:    1e4a        J.      SUBS     r2,r1,#1
        0x08001c68:    4c05        .L      LDR      r4,[pc,#20] ; [0x8001c80] = 0x8003da4
        0x08001c6a:    5ca2        .\      LDRB     r2,[r4,r2]
        0x08001c6c:    5083        .P      STR      r3,[r0,r2]
;;;492    }
        0x08001c6e:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;328      ubTransferComplete = 1;
        0x08001c70:    2001        .       MOVS     r0,#1
        0x08001c72:    4904        .I      LDR      r1,[pc,#16] ; [0x8001c84] = 0x20000027
        0x08001c74:    7008        .p      STRB     r0,[r1,#0]
;;;329    }
        0x08001c76:    bd10        ..      POP      {r4,pc}
    $d
        0x08001c78:    40005800    .X.@    DCD    1073764352
        0x08001c7c:    40020000    ...@    DCD    1073872896
        0x08001c80:    08003da4    .=..    DCD    134233508
        0x08001c84:    20000027    '..     DCD    536870951
    $t
    i.Transfer_Error_Callback
    Transfer_Error_Callback
;;;330    
;;;331    /**
;;;332      * @brief  DMA transfer error callback
;;;333      * @note   This function is executed when the transfer error interrupt
;;;334      *         is generated during DMA transfer
;;;335      * @retval None
;;;336      */
;;;337    void Transfer_Error_Callback()
;;;338    {
;;;339      /* Disable DMA1_Channel4_IRQn */
;;;340      NVIC_DisableIRQ(DMA1_Channel4_IRQn);
        0x08001c88:    200e        .       MOVS     r0,#0xe
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
        0x08001c8a:    2101        .!      MOVS     r1,#1
        0x08001c8c:    4081        .@      LSLS     r1,r1,r0
        0x08001c8e:    4a03        .J      LDR      r2,[pc,#12] ; [0x8001c9c] = 0xe000e180
        0x08001c90:    0943        C.      LSRS     r3,r0,#5
        0x08001c92:    f8421023    B.#.    STR      r1,[r2,r3,LSL #2]
;;;1466   }
        0x08001c96:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;342      while(1){};
        0x08001c98:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c (342)
        0x08001c9a:    e7fe        ..      B        0x8001c9a ; Transfer_Error_Callback + 18
    $d
        0x08001c9c:    e000e180    ....    DCD    3758154112
    $t
    i._Error_Handler
    _Error_Handler
;;; .\../Src/main.c
;;;949    	while (1) {
        0x08001ca0:    bf00        ..      NOP      
;;; .\../Src/main.c (949)
        0x08001ca2:    e7fe        ..      B        0x8001ca2 ; _Error_Handler + 2
    i.__scatterload_copy
    __scatterload_copy
        0x08001ca4:    e002        ..      B        0x8001cac ; __scatterload_copy + 8
        0x08001ca6:    c808        ..      LDM      r0!,{r3}
        0x08001ca8:    1f12        ..      SUBS     r2,r2,#4
        0x08001caa:    c108        ..      STM      r1!,{r3}
        0x08001cac:    2a00        .*      CMP      r2,#0
        0x08001cae:    d1fa        ..      BNE      0x8001ca6 ; __scatterload_copy + 2
        0x08001cb0:    4770        pG      BX       lr
    i.__scatterload_null
    __scatterload_null
        0x08001cb2:    4770        pG      BX       lr
    i.__scatterload_zeroinit
    __scatterload_zeroinit
        0x08001cb4:    2000        .       MOVS     r0,#0
        0x08001cb6:    e001        ..      B        0x8001cbc ; __scatterload_zeroinit + 8
        0x08001cb8:    c101        ..      STM      r1!,{r0}
        0x08001cba:    1f12        ..      SUBS     r2,r2,#4
        0x08001cbc:    2a00        .*      CMP      r2,#0
        0x08001cbe:    d1fb        ..      BNE      0x8001cb8 ; __scatterload_zeroinit + 4
        0x08001cc0:    4770        pG      BX       lr
        0x08001cc2:    0000        ..      MOVS     r0,r0
    i.do_fsm_first_cut_ramp_down
    do_fsm_first_cut_ramp_down
;;; .\..\Src\fsm.c
;;;422    {
        0x08001cc4:    b500        ..      PUSH     {lr}
        0x08001cc6:    4603        .F      MOV      r3,r0
;;;423    	MOTOR_Z_SetPulse();
        0x08001cc8:    2001        .       MOVS     r0,#1
        0x08001cca:    4909        .I      LDR      r1,[pc,#36] ; [0x8001cf0] = 0x42008000
        0x08001ccc:    6008        .`      STR      r0,[r1,#0]
;;;424    	z_axis.current_pos++;
        0x08001cce:    4809        .H      LDR      r0,[pc,#36] ; [0x8001cf4] = 0x20000a38
        0x08001cd0:    6800        .h      LDR      r0,[r0,#0]
        0x08001cd2:    1c40        @.      ADDS     r0,r0,#1
        0x08001cd4:    4907        .I      LDR      r1,[pc,#28] ; [0x8001cf4] = 0x20000a38
        0x08001cd6:    6008        .`      STR      r0,[r1,#0]
;;;425    	if(z_axis_ramp_down()) {
        0x08001cd8:    f000fee2    ....    BL       z_axis_ramp_down ; 0x8002aa0
        0x08001cdc:    b130        0.      CBZ      r0,0x8001cec ; do_fsm_first_cut_ramp_down + 40
;;;426    		z_axis.end_pos = z_axis.current_pos;
        0x08001cde:    4805        .H      LDR      r0,[pc,#20] ; [0x8001cf4] = 0x20000a38
        0x08001ce0:    6800        .h      LDR      r0,[r0,#0]
        0x08001ce2:    4904        .I      LDR      r1,[pc,#16] ; [0x8001cf4] = 0x20000a38
        0x08001ce4:    6048        H`      STR      r0,[r1,#4]
;;;427    		z_axis_at_move_end(s);
        0x08001ce6:    4618        .F      MOV      r0,r3
        0x08001ce8:    f000fe94    ....    BL       z_axis_at_move_end ; 0x8002a14
;;;428    	}
;;;429    }
        0x08001cec:    bd00        ..      POP      {pc}
    $d
        0x08001cee:    0000        ..      DCW    0
        0x08001cf0:    42008000    ...B    DCD    1107329024
        0x08001cf4:    20000a38    8..     DCD    536873528
    $t
    i.do_fsm_main_cut
    do_fsm_main_cut
;;;430    
;;;431    
;;;432    
;;;433    void do_fsm_sclick_event(state_t* s)   // reverse movement: set direction for motor
;;;434    {
;;;435    	if(feed_direction)
;;;436    		MOTOR_Z_Forward();
;;;437    	else
;;;438    		MOTOR_Z_Reverse();
;;;439    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;440    	s->function = do_fsm_main_cut_back_ramp_up;
;;;441    }
;;;442    
;;;443    
;;;444    
;;;445    
;;;446    
;;;447    void do_fsm_main_cut_back_ramp_up(state_t* s)          // reverse movement: ramp up: accel part
;;;448    {
;;;449    	MOTOR_Z_SetPulse();
;;;450    	--z_axis.current_pos;
;;;451    	if(z_axis_ramp_up())
;;;452    		s->function = do_fsm_main_cut_back;
;;;453    }
;;;454    
;;;455    
;;;456    
;;;457    
;;;458    
;;;459    
;;;460    
;;;461    void do_fsm_main_cut_back(state_t* s)          // reverse movement: main part
;;;462    {
;;;463    	MOTOR_Z_SetPulse();
;;;464    	if( --z_axis.current_pos > z_axis.ramp_step ) {
;;;465    	} else {
;;;466    		s->function = do_fsm_main_cut_back_ramp_down;
;;;467    	}
;;;468    }
;;;469    
;;;470    
;;;471    
;;;472    void do_fsm_main_cut_back_ramp_down(state_t* s)   // reverse movement: ramp down: deccel part + stop
;;;473    {
;;;474    	if (z_axis.current_pos > 0) {
;;;475    		MOTOR_Z_SetPulse();
;;;476    		--z_axis.current_pos;
;;;477    	}
;;;478    	if(z_axis_ramp_down()) {
;;;479    		z_axis_at_move_end(s);
;;;480    	}
;;;481    }
;;;482    
;;;483    
;;;484    
;;;485    
;;;486    
;;;487    
;;;488    
;;;489    
;;;490    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;491    {
;;;492    	MOTOR_Z_SetPulse();
;;;493    	--z_axis.current_pos;
;;;494    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
;;;495    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
;;;496    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
;;;497    		z_axis.current_pos += prolong_fixpart; // add fixed part
;;;498    		z_axis.end_pos += prolong_fixpart;
;;;499    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
;;;500    		// when long_press end, get back to 46 mode to proceed
;;;501    	}
;;;502    }
;;;503    
;;;504    void do_fsm_main_cut_wait_tacho(state_t* s)   // direct movement: set direction for motor
;;;505    {
;;;506    	if(feed_direction)
;;;507    		MOTOR_Z_Forward();
;;;508    	else
;;;509    		MOTOR_Z_Reverse();
;;;510    	s->function = do_fsm_main_cut_ramp_up; // intermediate state to wait tacho pulse
;;;511    	disable_encoder_ticks(); // reset interrupt for encoder ticks, only tacho
;;;512    }
;;;513    
;;;514    void do_fsm_main_cut(state_t* s)   // direct movement: ramp up: accel by ramp map
;;;515    {
        0x08001cf8:    b500        ..      PUSH     {lr}
        0x08001cfa:    4603        .F      MOV      r3,r0
;;;516    	MOTOR_Z_SetPulse();
        0x08001cfc:    2001        .       MOVS     r0,#1
        0x08001cfe:    4908        .I      LDR      r1,[pc,#32] ; [0x8001d20] = 0x42008000
        0x08001d00:    6008        .`      STR      r0,[r1,#0]
;;;517    	z_axis.current_pos++;
        0x08001d02:    4808        .H      LDR      r0,[pc,#32] ; [0x8001d24] = 0x20000a38
        0x08001d04:    6800        .h      LDR      r0,[r0,#0]
        0x08001d06:    1c40        @.      ADDS     r0,r0,#1
        0x08001d08:    4906        .I      LDR      r1,[pc,#24] ; [0x8001d24] = 0x20000a38
        0x08001d0a:    6008        .`      STR      r0,[r1,#0]
;;;518    	if(z_axis_ramp_up()) {
        0x08001d0c:    f000ff18    ....    BL       z_axis_ramp_up ; 0x8002b40
        0x08001d10:    b120         .      CBZ      r0,0x8001d1c ; do_fsm_main_cut + 36
;;;519    		LED_GPIO_Port->BSRR = LED_Pin;   // led off
        0x08001d12:    4805        .H      LDR      r0,[pc,#20] ; [0x8001d28] = 0x4200020
        0x08001d14:    4905        .I      LDR      r1,[pc,#20] ; [0x8001d2c] = 0x40011000
        0x08001d16:    6108        .a      STR      r0,[r1,#0x10]
;;;520    		s->function = do_fsm_main_cut_infeed;
        0x08001d18:    4805        .H      LDR      r0,[pc,#20] ; [0x8001d30] = 0x8001e31
        0x08001d1a:    6018        .`      STR      r0,[r3,#0]
;;;521    	}
;;;522    }
        0x08001d1c:    bd00        ..      POP      {pc}
    $d
        0x08001d1e:    0000        ..      DCW    0
        0x08001d20:    42008000    ...B    DCD    1107329024
        0x08001d24:    20000a38    8..     DCD    536873528
        0x08001d28:    04200020     . .    DCD    69206048
        0x08001d2c:    40011000    ...@    DCD    1073811456
        0x08001d30:    08001e31    1...    DCD    134225457
    $t
    i.do_fsm_main_cut_back
    do_fsm_main_cut_back
;;; .\..\Src\fsm.c (463)
        0x08001d34:    2101        .!      MOVS     r1,#1
        0x08001d36:    4a07        .J      LDR      r2,[pc,#28] ; [0x8001d54] = 0x42008000
        0x08001d38:    6011        .`      STR      r1,[r2,#0]
;;;464    	if( --z_axis.current_pos > z_axis.ramp_step ) {
        0x08001d3a:    4907        .I      LDR      r1,[pc,#28] ; [0x8001d58] = 0x20000a38
        0x08001d3c:    6809        .h      LDR      r1,[r1,#0]
        0x08001d3e:    1e49        I.      SUBS     r1,r1,#1
        0x08001d40:    4a05        .J      LDR      r2,[pc,#20] ; [0x8001d58] = 0x20000a38
        0x08001d42:    6011        .`      STR      r1,[r2,#0]
        0x08001d44:    f8922028    ..(     LDRB     r2,[r2,#0x28]
        0x08001d48:    4291        .B      CMP      r1,r2
        0x08001d4a:    d801        ..      BHI      0x8001d50 ; do_fsm_main_cut_back + 28
;;;465    	} else {
;;;466    		s->function = do_fsm_main_cut_back_ramp_down;
        0x08001d4c:    4903        .I      LDR      r1,[pc,#12] ; [0x8001d5c] = 0x8001dd5
        0x08001d4e:    6001        .`      STR      r1,[r0,#0]
;;;467    	}
;;;468    }
        0x08001d50:    4770        pG      BX       lr
    $d
        0x08001d52:    0000        ..      DCW    0
        0x08001d54:    42008000    ...B    DCD    1107329024
        0x08001d58:    20000a38    8..     DCD    536873528
        0x08001d5c:    08001dd5    ....    DCD    134225365
    $t
    i.do_fsm_main_cut_back_prolong
    do_fsm_main_cut_back_prolong
;;;469    
;;;470    
;;;471    
;;;472    void do_fsm_main_cut_back_ramp_down(state_t* s)   // reverse movement: ramp down: deccel part + stop
;;;473    {
;;;474    	if (z_axis.current_pos > 0) {
;;;475    		MOTOR_Z_SetPulse();
;;;476    		--z_axis.current_pos;
;;;477    	}
;;;478    	if(z_axis_ramp_down()) {
;;;479    		z_axis_at_move_end(s);
;;;480    	}
;;;481    }
;;;482    
;;;483    
;;;484    
;;;485    
;;;486    
;;;487    
;;;488    
;;;489    
;;;490    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;491    {
        0x08001d60:    b530        0.      PUSH     {r4,r5,lr}
        0x08001d62:    4603        .F      MOV      r3,r0
;;;492    	MOTOR_Z_SetPulse();
        0x08001d64:    2001        .       MOVS     r0,#1
        0x08001d66:    4919        .I      LDR      r1,[pc,#100] ; [0x8001dcc] = 0x42008000
        0x08001d68:    6008        .`      STR      r0,[r1,#0]
;;;493    	--z_axis.current_pos;
        0x08001d6a:    4819        .H      LDR      r0,[pc,#100] ; [0x8001dd0] = 0x20000a38
        0x08001d6c:    6800        .h      LDR      r0,[r0,#0]
        0x08001d6e:    1e40        @.      SUBS     r0,r0,#1
        0x08001d70:    4917        .I      LDR      r1,[pc,#92] ; [0x8001dd0] = 0x20000a38
        0x08001d72:    6008        .`      STR      r0,[r1,#0]
;;;494    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
        0x08001d74:    4608        .F      MOV      r0,r1
        0x08001d76:    6800        .h      LDR      r0,[r0,#0]
        0x08001d78:    f8911028    ..(.    LDRB     r1,[r1,#0x28]
        0x08001d7c:    4288        .B      CMP      r0,r1
        0x08001d7e:    d124        $.      BNE      0x8001dca ; do_fsm_main_cut_back_prolong + 106
;;;495    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
        0x08001d80:    4913        .I      LDR      r1,[pc,#76] ; [0x8001dd0] = 0x20000a38
        0x08001d82:    e9d15108    ...Q    LDRD     r5,r1,[r1,#0x20]
        0x08001d86:    4c12        .L      LDR      r4,[pc,#72] ; [0x8001dd0] = 0x20000a38
        0x08001d88:    e9d42406    ...$    LDRD     r2,r4,[r4,#0x18]
        0x08001d8c:    18aa        ..      ADDS     r2,r5,r2
        0x08001d8e:    4161        aA      ADCS     r1,r1,r4
        0x08001d90:    4c0f        .L      LDR      r4,[pc,#60] ; [0x8001dd0] = 0x20000a38
        0x08001d92:    e9c42108    ...!    STRD     r2,r1,[r4,#0x20]
;;;496    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
        0x08001d96:    4621        !F      MOV      r1,r4
        0x08001d98:    e9d12108    ...!    LDRD     r2,r1,[r1,#0x20]
        0x08001d9c:    020c        ..      LSLS     r4,r1,#8
        0x08001d9e:    ea446012    D..`    ORR      r0,r4,r2,LSR #24
;;;497    		z_axis.current_pos += prolong_fixpart; // add fixed part
        0x08001da2:    490b        .I      LDR      r1,[pc,#44] ; [0x8001dd0] = 0x20000a38
        0x08001da4:    6809        .h      LDR      r1,[r1,#0]
        0x08001da6:    4401        .D      ADD      r1,r1,r0
        0x08001da8:    4a09        .J      LDR      r2,[pc,#36] ; [0x8001dd0] = 0x20000a38
        0x08001daa:    6011        .`      STR      r1,[r2,#0]
;;;498    		z_axis.end_pos += prolong_fixpart;
        0x08001dac:    4611        .F      MOV      r1,r2
        0x08001dae:    6849        Ih      LDR      r1,[r1,#4]
        0x08001db0:    4401        .D      ADD      r1,r1,r0
        0x08001db2:    6051        Q`      STR      r1,[r2,#4]
;;;499    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
        0x08001db4:    4611        .F      MOV      r1,r2
        0x08001db6:    e9d12108    ...!    LDRD     r2,r1,[r1,#0x20]
        0x08001dba:    f06f447f    o..D    MVN      r4,#0xff000000
        0x08001dbe:    4022        "@      ANDS     r2,r2,r4
        0x08001dc0:    2100        .!      MOVS     r1,#0
        0x08001dc2:    4c03        .L      LDR      r4,[pc,#12] ; [0x8001dd0] = 0x20000a38
        0x08001dc4:    e9c42108    ...!    STRD     r2,r1,[r4,#0x20]
;;;500    		// when long_press end, get back to 46 mode to proceed
;;;501    	}
        0x08001dc8:    bf00        ..      NOP      
;;;502    }
        0x08001dca:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x08001dcc:    42008000    ...B    DCD    1107329024
        0x08001dd0:    20000a38    8..     DCD    536873528
    $t
    i.do_fsm_main_cut_back_ramp_down
    do_fsm_main_cut_back_ramp_down
;;; .\..\Src\fsm.c (473)
        0x08001dd4:    b500        ..      PUSH     {lr}
        0x08001dd6:    4603        .F      MOV      r3,r0
;;;474    	if (z_axis.current_pos > 0) {
        0x08001dd8:    4808        .H      LDR      r0,[pc,#32] ; [0x8001dfc] = 0x20000a38
        0x08001dda:    6800        .h      LDR      r0,[r0,#0]
        0x08001ddc:    b138        8.      CBZ      r0,0x8001dee ; do_fsm_main_cut_back_ramp_down + 26
;;;475    		MOTOR_Z_SetPulse();
        0x08001dde:    2001        .       MOVS     r0,#1
        0x08001de0:    4907        .I      LDR      r1,[pc,#28] ; [0x8001e00] = 0x42008000
        0x08001de2:    6008        .`      STR      r0,[r1,#0]
;;;476    		--z_axis.current_pos;
        0x08001de4:    4805        .H      LDR      r0,[pc,#20] ; [0x8001dfc] = 0x20000a38
        0x08001de6:    6800        .h      LDR      r0,[r0,#0]
        0x08001de8:    1e40        @.      SUBS     r0,r0,#1
        0x08001dea:    4904        .I      LDR      r1,[pc,#16] ; [0x8001dfc] = 0x20000a38
        0x08001dec:    6008        .`      STR      r0,[r1,#0]
;;;477    	}
;;;478    	if(z_axis_ramp_down()) {
        0x08001dee:    f000fe57    ..W.    BL       z_axis_ramp_down ; 0x8002aa0
        0x08001df2:    b110        ..      CBZ      r0,0x8001dfa ; do_fsm_main_cut_back_ramp_down + 38
;;;479    		z_axis_at_move_end(s);
        0x08001df4:    4618        .F      MOV      r0,r3
        0x08001df6:    f000fe0d    ....    BL       z_axis_at_move_end ; 0x8002a14
;;;480    	}
;;;481    }
        0x08001dfa:    bd00        ..      POP      {pc}
    $d
        0x08001dfc:    20000a38    8..     DCD    536873528
        0x08001e00:    42008000    ...B    DCD    1107329024
    $t
    i.do_fsm_main_cut_back_ramp_up
    do_fsm_main_cut_back_ramp_up
;;; .\..\Src\fsm.c (448)
        0x08001e04:    b500        ..      PUSH     {lr}
        0x08001e06:    4603        .F      MOV      r3,r0
;;;449    	MOTOR_Z_SetPulse();
        0x08001e08:    2001        .       MOVS     r0,#1
        0x08001e0a:    4906        .I      LDR      r1,[pc,#24] ; [0x8001e24] = 0x42008000
        0x08001e0c:    6008        .`      STR      r0,[r1,#0]
;;;450    	--z_axis.current_pos;
        0x08001e0e:    4806        .H      LDR      r0,[pc,#24] ; [0x8001e28] = 0x20000a38
        0x08001e10:    6800        .h      LDR      r0,[r0,#0]
        0x08001e12:    1e40        @.      SUBS     r0,r0,#1
        0x08001e14:    4904        .I      LDR      r1,[pc,#16] ; [0x8001e28] = 0x20000a38
        0x08001e16:    6008        .`      STR      r0,[r1,#0]
;;;451    	if(z_axis_ramp_up())
        0x08001e18:    f000fe92    ....    BL       z_axis_ramp_up ; 0x8002b40
        0x08001e1c:    b108        ..      CBZ      r0,0x8001e22 ; do_fsm_main_cut_back_ramp_up + 30
;;;452    		s->function = do_fsm_main_cut_back;
        0x08001e1e:    4803        .H      LDR      r0,[pc,#12] ; [0x8001e2c] = 0x8001d35
        0x08001e20:    6018        .`      STR      r0,[r3,#0]
;;;453    }
        0x08001e22:    bd00        ..      POP      {pc}
    $d
        0x08001e24:    42008000    ...B    DCD    1107329024
        0x08001e28:    20000a38    8..     DCD    536873528
        0x08001e2c:    08001d35    5...    DCD    134225205
    $t
    i.do_fsm_main_cut_infeed
    do_fsm_main_cut_infeed
;;;454    
;;;455    
;;;456    
;;;457    
;;;458    
;;;459    
;;;460    
;;;461    void do_fsm_main_cut_back(state_t* s)          // reverse movement: main part
;;;462    {
;;;463    	MOTOR_Z_SetPulse();
;;;464    	if( --z_axis.current_pos > z_axis.ramp_step ) {
;;;465    	} else {
;;;466    		s->function = do_fsm_main_cut_back_ramp_down;
;;;467    	}
;;;468    }
;;;469    
;;;470    
;;;471    
;;;472    void do_fsm_main_cut_back_ramp_down(state_t* s)   // reverse movement: ramp down: deccel part + stop
;;;473    {
;;;474    	if (z_axis.current_pos > 0) {
;;;475    		MOTOR_Z_SetPulse();
;;;476    		--z_axis.current_pos;
;;;477    	}
;;;478    	if(z_axis_ramp_down()) {
;;;479    		z_axis_at_move_end(s);
;;;480    	}
;;;481    }
;;;482    
;;;483    
;;;484    
;;;485    
;;;486    
;;;487    
;;;488    
;;;489    
;;;490    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;491    {
;;;492    	MOTOR_Z_SetPulse();
;;;493    	--z_axis.current_pos;
;;;494    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
;;;495    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
;;;496    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
;;;497    		z_axis.current_pos += prolong_fixpart; // add fixed part
;;;498    		z_axis.end_pos += prolong_fixpart;
;;;499    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
;;;500    		// when long_press end, get back to 46 mode to proceed
;;;501    	}
;;;502    }
;;;503    
;;;504    void do_fsm_main_cut_wait_tacho(state_t* s)   // direct movement: set direction for motor
;;;505    {
;;;506    	if(feed_direction)
;;;507    		MOTOR_Z_Forward();
;;;508    	else
;;;509    		MOTOR_Z_Reverse();
;;;510    	s->function = do_fsm_main_cut_ramp_up; // intermediate state to wait tacho pulse
;;;511    	disable_encoder_ticks(); // reset interrupt for encoder ticks, only tacho
;;;512    }
;;;513    
;;;514    void do_fsm_main_cut(state_t* s)   // direct movement: ramp up: accel by ramp map
;;;515    {
;;;516    	MOTOR_Z_SetPulse();
;;;517    	z_axis.current_pos++;
;;;518    	if(z_axis_ramp_up()) {
;;;519    		LED_GPIO_Port->BSRR = LED_Pin;   // led off
;;;520    		s->function = do_fsm_main_cut_infeed;
;;;521    	}
;;;522    }
;;;523    
;;;524    
;;;525    void do_fsm_main_cut_infeed(state_t* s)   // direct movement: main part
;;;526    {
        0x08001e30:    b500        ..      PUSH     {lr}
        0x08001e32:    4603        .F      MOV      r3,r0
;;;527    	MOTOR_Z_SetPulse();
        0x08001e34:    2001        .       MOVS     r0,#1
        0x08001e36:    490b        .I      LDR      r1,[pc,#44] ; [0x8001e64] = 0x42008000
        0x08001e38:    6008        .`      STR      r0,[r1,#0]
;;;528    	z_axis.current_pos++;
        0x08001e3a:    480b        .H      LDR      r0,[pc,#44] ; [0x8001e68] = 0x20000a38
        0x08001e3c:    6800        .h      LDR      r0,[r0,#0]
        0x08001e3e:    1c40        @.      ADDS     r0,r0,#1
        0x08001e40:    4909        .I      LDR      r1,[pc,#36] ; [0x8001e68] = 0x20000a38
        0x08001e42:    6008        .`      STR      r0,[r1,#0]
;;;529    	if( z_axis.current_pos < ( z_axis.end_pos - z_axis.ramp_step ) ) {
        0x08001e44:    4608        .F      MOV      r0,r1
        0x08001e46:    6840        @h      LDR      r0,[r0,#4]
        0x08001e48:    f8911028    ..(.    LDRB     r1,[r1,#0x28]
        0x08001e4c:    1a40        @.      SUBS     r0,r0,r1
        0x08001e4e:    4906        .I      LDR      r1,[pc,#24] ; [0x8001e68] = 0x20000a38
        0x08001e50:    6809        .h      LDR      r1,[r1,#0]
        0x08001e52:    4288        .B      CMP      r0,r1
        0x08001e54:    d902        ..      BLS      0x8001e5c ; do_fsm_main_cut_infeed + 44
;;;530    		z_axis_move();
        0x08001e56:    f000fdf5    ....    BL       z_axis_move ; 0x8002a44
        0x08001e5a:    e001        ..      B        0x8001e60 ; do_fsm_main_cut_infeed + 48
;;;531    	} else {
;;;532    		s->function = do_fsm_first_cut_ramp_down;
        0x08001e5c:    4803        .H      LDR      r0,[pc,#12] ; [0x8001e6c] = 0x8001cc5
        0x08001e5e:    6018        .`      STR      r0,[r3,#0]
;;;533    	}
;;;534    }
        0x08001e60:    bd00        ..      POP      {pc}
    $d
        0x08001e62:    0000        ..      DCW    0
        0x08001e64:    42008000    ...B    DCD    1107329024
        0x08001e68:    20000a38    8..     DCD    536873528
        0x08001e6c:    08001cc5    ....    DCD    134225093
    $t
    i.do_fsm_main_cut_ramp_up
    do_fsm_main_cut_ramp_up
;;;535    
;;;536    
;;;537    void do_fsm_wait_sclick(state_t* s)
;;;538    {
;;;539    	MOTOR_Z_Disable(); //disable motor
;;;540    }
;;;541    
;;;542    void do_fsm_main_cut_ramp_up(state_t* s)
;;;543    {
;;;544    	s->function = do_fsm_main_cut;
        0x08001e70:    4915        .I      LDR      r1,[pc,#84] ; [0x8001ec8] = 0x8001cf9
        0x08001e72:    6001        .`      STR      r1,[r0,#0]
;;;545    	//reinit counter
;;;546    //                          TIM4->ARR = fixedpt_toint(Q824set) - 1;
;;;547    	LED_GPIO_Port->BRR = LED_Pin; //led on
        0x08001e74:    4915        .I      LDR      r1,[pc,#84] ; [0x8001ecc] = 0x4200020
        0x08001e76:    4a16        .J      LDR      r2,[pc,#88] ; [0x8001ed0] = 0x40011000
        0x08001e78:    6151        Qa      STR      r1,[r2,#0x14]
;;;548    
;;;549    	if(infeed_step < infeed_steps) {
        0x08001e7a:    4916        .I      LDR      r1,[pc,#88] ; [0x8001ed4] = 0x20000108
        0x08001e7c:    6809        .h      LDR      r1,[r1,#0]
        0x08001e7e:    4a16        .J      LDR      r2,[pc,#88] ; [0x8001ed8] = 0x2000010c
        0x08001e80:    6812        .h      LDR      r2,[r2,#0]
        0x08001e82:    4291        .B      CMP      r1,r2
        0x08001e84:    d20c        ..      BCS      0x8001ea0 ; do_fsm_main_cut_ramp_up + 48
;;;550    		TIM4->ARR = infeed_map[infeed_step++] + 1; // start stepper motor with shifted position by infeed map
        0x08001e86:    4913        .I      LDR      r1,[pc,#76] ; [0x8001ed4] = 0x20000108
        0x08001e88:    680a        .h      LDR      r2,[r1,#0]
        0x08001e8a:    6809        .h      LDR      r1,[r1,#0]
        0x08001e8c:    1c49        I.      ADDS     r1,r1,#1
        0x08001e8e:    4b11        .K      LDR      r3,[pc,#68] ; [0x8001ed4] = 0x20000108
        0x08001e90:    6019        .`      STR      r1,[r3,#0]
        0x08001e92:    4912        .I      LDR      r1,[pc,#72] ; [0x8001edc] = 0x20000110
        0x08001e94:    f8311012    1...    LDRH     r1,[r1,r2,LSL #1]
        0x08001e98:    1c49        I.      ADDS     r1,r1,#1
        0x08001e9a:    4a11        .J      LDR      r2,[pc,#68] ; [0x8001ee0] = 0x4000082c
        0x08001e9c:    6011        .`      STR      r1,[r2,#0]
        0x08001e9e:    e002        ..      B        0x8001ea6 ; do_fsm_main_cut_ramp_up + 54
;;;551    	} else {
;;;552    		TIM4->ARR = 1;  // start stepper motor ramp up procedure immediately after tacho event
        0x08001ea0:    2101        .!      MOVS     r1,#1
        0x08001ea2:    4a0f        .J      LDR      r2,[pc,#60] ; [0x8001ee0] = 0x4000082c
        0x08001ea4:    6011        .`      STR      r1,[r2,#0]
;;;553    	}
;;;554    	TIM4->EGR |= TIM_EGR_UG;
        0x08001ea6:    490e        .I      LDR      r1,[pc,#56] ; [0x8001ee0] = 0x4000082c
        0x08001ea8:    3918        .9      SUBS     r1,r1,#0x18
        0x08001eaa:    6809        .h      LDR      r1,[r1,#0]
        0x08001eac:    f0410101    A...    ORR      r1,r1,#1
        0x08001eb0:    4a0b        .J      LDR      r2,[pc,#44] ; [0x8001ee0] = 0x4000082c
        0x08001eb2:    3a18        .:      SUBS     r2,r2,#0x18
        0x08001eb4:    6011        .`      STR      r1,[r2,#0]
;;;555    
;;;556    	TIM4->CNT = 0;
        0x08001eb6:    2100        .!      MOVS     r1,#0
        0x08001eb8:    4a09        .J      LDR      r2,[pc,#36] ; [0x8001ee0] = 0x4000082c
        0x08001eba:    3a08        .:      SUBS     r2,r2,#8
        0x08001ebc:    6011        .`      STR      r1,[r2,#0]
;;;557    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
        0x08001ebe:    2101        .!      MOVS     r1,#1
        0x08001ec0:    4a08        .J      LDR      r2,[pc,#32] ; [0x8001ee4] = 0x42010180
        0x08001ec2:    6011        .`      STR      r1,[r2,#0]
;;;558    }
        0x08001ec4:    4770        pG      BX       lr
    $d
        0x08001ec6:    0000        ..      DCW    0
        0x08001ec8:    08001cf9    ....    DCD    134225145
        0x08001ecc:    04200020     . .    DCD    69206048
        0x08001ed0:    40011000    ...@    DCD    1073811456
        0x08001ed4:    20000108    ...     DCD    536871176
        0x08001ed8:    2000010c    ...     DCD    536871180
        0x08001edc:    20000110    ...     DCD    536871184
        0x08001ee0:    4000082c    ,..@    DCD    1073743916
        0x08001ee4:    42010180    ...B    DCD    1107362176
    $t
    i.do_fsm_main_cut_wait_tacho
    do_fsm_main_cut_wait_tacho
;;; .\..\Src\fsm.c (506)
        0x08001ee8:    4909        .I      LDR      r1,[pc,#36] ; [0x8001f10] = 0x2000015d
        0x08001eea:    7809        .x      LDRB     r1,[r1,#0]
        0x08001eec:    b121        !.      CBZ      r1,0x8001ef8 ; do_fsm_main_cut_wait_tacho + 16
;;;507    		MOTOR_Z_Forward();
        0x08001eee:    f2480180    H...    MOV      r1,#0x8080
        0x08001ef2:    4a08        .J      LDR      r2,[pc,#32] ; [0x8001f14] = 0x40010810
        0x08001ef4:    6011        .`      STR      r1,[r2,#0]
        0x08001ef6:    e004        ..      B        0x8001f02 ; do_fsm_main_cut_wait_tacho + 26
;;;508    	else
;;;509    		MOTOR_Z_Reverse();
        0x08001ef8:    f2480180    H...    MOV      r1,#0x8080
        0x08001efc:    4a05        .J      LDR      r2,[pc,#20] ; [0x8001f14] = 0x40010810
        0x08001efe:    1d12        ..      ADDS     r2,r2,#4
        0x08001f00:    6011        .`      STR      r1,[r2,#0]
;;;510    	s->function = do_fsm_main_cut_ramp_up; // intermediate state to wait tacho pulse
        0x08001f02:    4905        .I      LDR      r1,[pc,#20] ; [0x8001f18] = 0x8001e71
        0x08001f04:    6001        .`      STR      r1,[r0,#0]
;;;511    	disable_encoder_ticks(); // reset interrupt for encoder ticks, only tacho
        0x08001f06:    2100        .!      MOVS     r1,#0
        0x08001f08:    4a04        .J      LDR      r2,[pc,#16] ; [0x8001f1c] = 0x42010180
        0x08001f0a:    6011        .`      STR      r1,[r2,#0]
;;;512    }
        0x08001f0c:    4770        pG      BX       lr
    $d
        0x08001f0e:    0000        ..      DCW    0
        0x08001f10:    2000015d    ]..     DCD    536871261
        0x08001f14:    40010810    ...@    DCD    1073809424
        0x08001f18:    08001e71    q...    DCD    134225521
        0x08001f1c:    42010180    ...B    DCD    1107362176
    $t
    i.do_fsm_menu
    do_fsm_menu
;;; .\..\Src\fsm.c (228)
        0x08001f20:    b570        p.      PUSH     {r4-r6,lr}
        0x08001f22:    4604        .F      MOV      r4,r0
;;;229    	uint8_t level = Thread_Info[Menu_Step].level;
        0x08001f24:    4879        yH      LDR      r0,[pc,#484] ; [0x800210c] = 0x20000170
        0x08001f26:    497a        zI      LDR      r1,[pc,#488] ; [0x8002110] = 0x20000590
        0x08001f28:    7809        .x      LDRB     r1,[r1,#0]
        0x08001f2a:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x08001f2e:    7c45        E|      LDRB     r5,[r0,#0x11]
;;;230    	buttons_flag_set = long_press_start_Msk;
        0x08001f30:    2001        .       MOVS     r0,#1
        0x08001f32:    4978        xI      LDR      r1,[pc,#480] ; [0x8002114] = 0x20004000
        0x08001f34:    6008        .`      STR      r0,[r1,#0]
;;;231    	switch(buttons_flag_set) {
        0x08001f36:    4608        .F      MOV      r0,r1
        0x08001f38:    6800        .h      LDR      r0,[r0,#0]
        0x08001f3a:    2808        .(      CMP      r0,#8
        0x08001f3c:    d069        i.      BEQ      0x8002012 ; do_fsm_menu + 242
        0x08001f3e:    dc06        ..      BGT      0x8001f4e ; do_fsm_menu + 46
        0x08001f40:    2801        .(      CMP      r0,#1
        0x08001f42:    d074        t.      BEQ      0x800202e ; do_fsm_menu + 270
        0x08001f44:    2802        .(      CMP      r0,#2
        0x08001f46:    d06f        o.      BEQ      0x8002028 ; do_fsm_menu + 264
        0x08001f48:    2804        .(      CMP      r0,#4
        0x08001f4a:    d110        ..      BNE      0x8001f6e ; do_fsm_menu + 78
        0x08001f4c:    e01a        ..      B        0x8001f84 ; do_fsm_menu + 100
        0x08001f4e:    2811        .(      CMP      r0,#0x11
        0x08001f50:    d06c        l.      BEQ      0x800202c ; do_fsm_menu + 268
        0x08001f52:    2840        @(      CMP      r0,#0x40
        0x08001f54:    d00c        ..      BEQ      0x8001f70 ; do_fsm_menu + 80
        0x08001f56:    f5b06f80    ...o    CMP      r0,#0x400
        0x08001f5a:    d1f6        ..      BNE      0x8001f4a ; do_fsm_menu + 42
;;;232    	case single_click_Msk3: {
;;;233    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
        0x08001f5c:    486e        nH      LDR      r0,[pc,#440] ; [0x8002118] = 0x2000015d
        0x08001f5e:    7800        .x      LDRB     r0,[r0,#0]
        0x08001f60:    f0800001    ....    EOR      r0,r0,#1
        0x08001f64:    496c        lI      LDR      r1,[pc,#432] ; [0x8002118] = 0x2000015d
        0x08001f66:    7008        .p      STRB     r0,[r1,#0]
;;;234    		menu_changed = 1;
        0x08001f68:    2001        .       MOVS     r0,#1
        0x08001f6a:    496c        lI      LDR      r1,[pc,#432] ; [0x800211c] = 0x20000160
        0x08001f6c:    6008        .`      STR      r0,[r1,#0]
;;;235    		break;
        0x08001f6e:    e0ca        ..      B        0x8002106 ; do_fsm_menu + 486
;;;236    	}
;;;237    	case single_click_Msk2: {
;;;238    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
        0x08001f70:    4869        iH      LDR      r0,[pc,#420] ; [0x8002118] = 0x2000015d
        0x08001f72:    7800        .x      LDRB     r0,[r0,#0]
        0x08001f74:    f0800001    ....    EOR      r0,r0,#1
        0x08001f78:    4967        gI      LDR      r1,[pc,#412] ; [0x8002118] = 0x2000015d
        0x08001f7a:    7008        .p      STRB     r0,[r1,#0]
;;;239    		menu_changed = 1;
        0x08001f7c:    2001        .       MOVS     r0,#1
        0x08001f7e:    4967        gI      LDR      r1,[pc,#412] ; [0x800211c] = 0x20000160
        0x08001f80:    6008        .`      STR      r0,[r1,#0]
;;;240    		break;
        0x08001f82:    e0c0        ..      B        0x8002106 ; do_fsm_menu + 486
;;;241    	}
;;;242    	case single_click_Msk: {
;;;243    		if(z_axis.end_pos != 0) {
        0x08001f84:    4866        fH      LDR      r0,[pc,#408] ; [0x8002120] = 0x20000a38
        0x08001f86:    6840        @h      LDR      r0,[r0,#4]
        0x08001f88:    b190        ..      CBZ      r0,0x8001fb0 ; do_fsm_menu + 144
;;;244    
;;;245    			// first pass of thread cut was complete, so just use single click
;;;246    			//	to switch between modes to process all other cuts
;;;247    			MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
        0x08001f8a:    f2402002    @..     MOV      r0,#0x202
        0x08001f8e:    4965        eI      LDR      r1,[pc,#404] ; [0x8002124] = 0x40010c10
        0x08001f90:    6008        .`      STR      r0,[r1,#0]
;;;248    			for(unsigned int i=0; i<(72*1700/16); i++); // wait 1700us delay to wakeup motor driver
        0x08001f92:    2000        .       MOVS     r0,#0
        0x08001f94:    e000        ..      B        0x8001f98 ; do_fsm_menu + 120
        0x08001f96:    1c40        @.      ADDS     r0,r0,#1
        0x08001f98:    f64151e2    A..Q    MOV      r1,#0x1de2
        0x08001f9c:    4288        .B      CMP      r0,r1
        0x08001f9e:    d3fa        ..      BCC      0x8001f96 ; do_fsm_menu + 118
;;;249    			s->function = z_axis.current_pos > 0 ? do_fsm_sclick_event : do_fsm_main_cut_wait_tacho;
        0x08001fa0:    485f        _H      LDR      r0,[pc,#380] ; [0x8002120] = 0x20000a38
        0x08001fa2:    6800        .h      LDR      r0,[r0,#0]
        0x08001fa4:    b108        ..      CBZ      r0,0x8001faa ; do_fsm_menu + 138
        0x08001fa6:    4860        `H      LDR      r0,[pc,#384] ; [0x8002128] = 0x8002415
        0x08001fa8:    e000        ..      B        0x8001fac ; do_fsm_menu + 140
        0x08001faa:    4860        `H      LDR      r0,[pc,#384] ; [0x800212c] = 0x8001ee9
        0x08001fac:    6020         `      STR      r0,[r4,#0]
        0x08001fae:    e02f        /.      B        0x8002010 ; do_fsm_menu + 240
;;;250    		} else { // controller in initial state, scroll menu
;;;251    			s->function = do_fsm_menu_lps;
        0x08001fb0:    485f        _H      LDR      r0,[pc,#380] ; [0x8002130] = 0x8002151
        0x08001fb2:    6020         `      STR      r0,[r4,#0]
;;;252    			for (int a = Menu_Step+1; a<Menu_size; a++) {
        0x08001fb4:    4956        VI      LDR      r1,[pc,#344] ; [0x8002110] = 0x20000590
        0x08001fb6:    7809        .x      LDRB     r1,[r1,#0]
        0x08001fb8:    1c48        H.      ADDS     r0,r1,#1
        0x08001fba:    e00c        ..      B        0x8001fd6 ; do_fsm_menu + 182
;;;253    				if(Thread_Info[a].level == level) {
        0x08001fbc:    4953        SI      LDR      r1,[pc,#332] ; [0x800210c] = 0x20000170
        0x08001fbe:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x08001fc2:    7c49        I|      LDRB     r1,[r1,#0x11]
        0x08001fc4:    42a9        .B      CMP      r1,r5
        0x08001fc6:    d105        ..      BNE      0x8001fd4 ; do_fsm_menu + 180
;;;254    					Menu_Step = a;
        0x08001fc8:    4a51        QJ      LDR      r2,[pc,#324] ; [0x8002110] = 0x20000590
        0x08001fca:    7010        .p      STRB     r0,[r2,#0]
;;;255    					menu_changed = 1;
        0x08001fcc:    2101        .!      MOVS     r1,#1
        0x08001fce:    4a53        SJ      LDR      r2,[pc,#332] ; [0x800211c] = 0x20000160
        0x08001fd0:    6011        .`      STR      r1,[r2,#0]
;;;256    					break;
        0x08001fd2:    e004        ..      B        0x8001fde ; do_fsm_menu + 190
        0x08001fd4:    1c40        @.      ADDS     r0,r0,#1
        0x08001fd6:    4957        WI      LDR      r1,[pc,#348] ; [0x8002134] = 0x8003dfa
        0x08001fd8:    7809        .x      LDRB     r1,[r1,#0]
        0x08001fda:    4288        .B      CMP      r0,r1
        0x08001fdc:    dbee        ..      BLT      0x8001fbc ; do_fsm_menu + 156
        0x08001fde:    bf00        ..      NOP      
;;;257    				}
;;;258    			}
;;;259    			if(menu_changed != 1) {
        0x08001fe0:    484e        NH      LDR      r0,[pc,#312] ; [0x800211c] = 0x20000160
        0x08001fe2:    6800        .h      LDR      r0,[r0,#0]
        0x08001fe4:    2801        .(      CMP      r0,#1
        0x08001fe6:    d013        ..      BEQ      0x8002010 ; do_fsm_menu + 240
;;;260    				for (int a = 0; a<Menu_Step; a++) {
        0x08001fe8:    2000        .       MOVS     r0,#0
        0x08001fea:    e00c        ..      B        0x8002006 ; do_fsm_menu + 230
;;;261    					if(Thread_Info[a].level == level) {
        0x08001fec:    4947        GI      LDR      r1,[pc,#284] ; [0x800210c] = 0x20000170
        0x08001fee:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x08001ff2:    7c49        I|      LDRB     r1,[r1,#0x11]
        0x08001ff4:    42a9        .B      CMP      r1,r5
        0x08001ff6:    d105        ..      BNE      0x8002004 ; do_fsm_menu + 228
;;;262    						Menu_Step = a;
        0x08001ff8:    4a45        EJ      LDR      r2,[pc,#276] ; [0x8002110] = 0x20000590
        0x08001ffa:    7010        .p      STRB     r0,[r2,#0]
;;;263    						menu_changed = 1;
        0x08001ffc:    2101        .!      MOVS     r1,#1
        0x08001ffe:    4a47        GJ      LDR      r2,[pc,#284] ; [0x800211c] = 0x20000160
        0x08002000:    6011        .`      STR      r1,[r2,#0]
;;;264    						break;
        0x08002002:    e004        ..      B        0x800200e ; do_fsm_menu + 238
        0x08002004:    1c40        @.      ADDS     r0,r0,#1
        0x08002006:    4942        BI      LDR      r1,[pc,#264] ; [0x8002110] = 0x20000590
        0x08002008:    7809        .x      LDRB     r1,[r1,#0]
        0x0800200a:    4288        .B      CMP      r0,r1
        0x0800200c:    dbee        ..      BLT      0x8001fec ; do_fsm_menu + 204
        0x0800200e:    bf00        ..      NOP      
;;;265    					}
;;;266    				}
;;;267    			}
;;;268    		}
;;;269    		break;
        0x08002010:    e079        y.      B        0x8002106 ; do_fsm_menu + 486
;;;270    	}
;;;271    	case double_click_Msk: {
;;;272    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
        0x08002012:    4841        AH      LDR      r0,[pc,#260] ; [0x8002118] = 0x2000015d
        0x08002014:    7800        .x      LDRB     r0,[r0,#0]
        0x08002016:    f0800001    ....    EOR      r0,r0,#1
        0x0800201a:    493f        ?I      LDR      r1,[pc,#252] ; [0x8002118] = 0x2000015d
        0x0800201c:    7008        .p      STRB     r0,[r1,#0]
;;;273    		menu_changed = 1;
        0x0800201e:    2001        .       MOVS     r0,#1
        0x08002020:    493e        >I      LDR      r1,[pc,#248] ; [0x800211c] = 0x20000160
        0x08002022:    6008        .`      STR      r0,[r1,#0]
;;;274    		break;
        0x08002024:    e06f        o.      B        0x8002106 ; do_fsm_menu + 486
        0x08002026:    e002        ..      B        0x800202e ; do_fsm_menu + 270
        0x08002028:    e06a        j.      B        0x8002100 ; do_fsm_menu + 480
        0x0800202a:    e7ff        ..      B        0x800202c ; do_fsm_menu + 268
;;;275    	}
;;;276    	case (long_press_start_Msk | long_press_start_Msk2): { // two buttons long pressed same time
;;;277    		// todo check if it work
;;;278    		break;
        0x0800202c:    e06b        k.      B        0x8002106 ; do_fsm_menu + 486
;;;279    	}
;;;280    	case long_press_start_Msk: {
;;;281    		if(s->function == do_fsm_menu_lps){
        0x0800202e:    4940        @I      LDR      r1,[pc,#256] ; [0x8002130] = 0x8002151
        0x08002030:    6820         h      LDR      r0,[r4,#0]
        0x08002032:    4288        .B      CMP      r0,r1
        0x08002034:    d15d        ].      BNE      0x80020f2 ; do_fsm_menu + 466
;;;282    			if(Thread_Info[Menu_Step].Q824 != 0) { // long press detected, start new thread from current position
        0x08002036:    4835        5H      LDR      r0,[pc,#212] ; [0x800210c] = 0x20000170
        0x08002038:    4935        5I      LDR      r1,[pc,#212] ; [0x8002110] = 0x20000590
        0x0800203a:    7809        .x      LDRB     r1,[r1,#0]
        0x0800203c:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x08002040:    6800        .h      LDR      r0,[r0,#0]
        0x08002042:    b3d8        ..      CBZ      r0,0x80020bc ; do_fsm_menu + 412
;;;283    				//mode 20:
;;;284    				disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
        0x08002044:    2000        .       MOVS     r0,#0
        0x08002046:    493c        <I      LDR      r1,[pc,#240] ; [0x8002138] = 0x42010180
        0x08002048:    6008        .`      STR      r0,[r1,#0]
;;;285    				MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
        0x0800204a:    f2402002    @..     MOV      r0,#0x202
        0x0800204e:    4935        5I      LDR      r1,[pc,#212] ; [0x8002124] = 0x40010c10
        0x08002050:    6008        .`      STR      r0,[r1,#0]
;;;286    				s->main_feed_direction = feed_direction; // save main feed direction, where cut is on
        0x08002052:    4831        1H      LDR      r0,[pc,#196] ; [0x8002118] = 0x2000015d
        0x08002054:    7800        .x      LDRB     r0,[r0,#0]
        0x08002056:    7460        `t      STRB     r0,[r4,#0x11]
;;;287    				s->sync = true;
        0x08002058:    2001        .       MOVS     r0,#1
        0x0800205a:    7420         t      STRB     r0,[r4,#0x10]
;;;288    				if( feed_direction == feed_direction_right )
        0x0800205c:    482e        .H      LDR      r0,[pc,#184] ; [0x8002118] = 0x2000015d
        0x0800205e:    7800        .x      LDRB     r0,[r0,#0]
        0x08002060:    2801        .(      CMP      r0,#1
        0x08002062:    d104        ..      BNE      0x800206e ; do_fsm_menu + 334
;;;289    					MOTOR_Z_Forward();
        0x08002064:    f2480080    H...    MOV      r0,#0x8080
        0x08002068:    4934        4I      LDR      r1,[pc,#208] ; [0x800213c] = 0x40010810
        0x0800206a:    6008        .`      STR      r0,[r1,#0]
        0x0800206c:    e004        ..      B        0x8002078 ; do_fsm_menu + 344
;;;290    				else
;;;291    					MOTOR_Z_Reverse();
        0x0800206e:    f2480080    H...    MOV      r0,#0x8080
        0x08002072:    4932        2I      LDR      r1,[pc,#200] ; [0x800213c] = 0x40010810
        0x08002074:    1d09        ..      ADDS     r1,r1,#4
        0x08002076:    6008        .`      STR      r0,[r1,#0]
;;;292    				
;;;293    				for(unsigned int i=0; i<(72*1700/16); i++); // wait 1700us delay to wakeup motor driver todo dumb method
        0x08002078:    2000        .       MOVS     r0,#0
        0x0800207a:    e000        ..      B        0x800207e ; do_fsm_menu + 350
        0x0800207c:    1c40        @.      ADDS     r0,r0,#1
        0x0800207e:    f64151e2    A..Q    MOV      r1,#0x1de2
        0x08002082:    4288        .B      CMP      r0,r1
        0x08002084:    d3fa        ..      BCC      0x800207c ; do_fsm_menu + 348
;;;294    
;;;295    				z_axis.Q824set = Thread_Info[Menu_Step].Q824;
        0x08002086:    4821        !H      LDR      r0,[pc,#132] ; [0x800210c] = 0x20000170
        0x08002088:    4921        !I      LDR      r1,[pc,#132] ; [0x8002110] = 0x20000590
        0x0800208a:    7809        .x      LDRB     r1,[r1,#0]
        0x0800208c:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x08002090:    6800        .h      LDR      r0,[r0,#0]
        0x08002092:    4923        #I      LDR      r1,[pc,#140] ; [0x8002120] = 0x20000a38
        0x08002094:    60c8        .`      STR      r0,[r1,#0xc]
;;;296    				z_axis.end_pos = z_axis.current_pos = 0;
        0x08002096:    2000        .       MOVS     r0,#0
        0x08002098:    6008        .`      STR      r0,[r1,#0]
        0x0800209a:    6048        H`      STR      r0,[r1,#4]
;;;297    
;;;298    				const uint64_t upl = (uint64_t)3600 << 48; //calculate some constants for prolong mode
        0x0800209c:    bf00        ..      NOP      
;;;299    				z_axis.prolong_addSteps = upl / (fixedptud)z_axis.Q824set;
        0x0800209e:    4608        .F      MOV      r0,r1
        0x080020a0:    68c6        .h      LDR      r6,[r0,#0xc]
        0x080020a2:    4632        2F      MOV      r2,r6
        0x080020a4:    2300        .#      MOVS     r3,#0
        0x080020a6:    4618        .F      MOV      r0,r3
        0x080020a8:    f04f6161    O.aa    MOV      r1,#0xe100000
        0x080020ac:    f7fef83a    ..:.    BL       __aeabi_uldivmod ; 0x8000124
        0x080020b0:    4a1b        .J      LDR      r2,[pc,#108] ; [0x8002120] = 0x20000a38
        0x080020b2:    e9c20106    ....    STRD     r0,r1,[r2,#0x18]
;;;300    
;;;301    				s->function = do_fsm_move_start;//do_fsm_wait_tacho; // go straight to 24 to wait tacho
        0x080020b6:    4822        "H      LDR      r0,[pc,#136] ; [0x8002140] = 0x800225d
        0x080020b8:    6020         `      STR      r0,[r4,#0]
;;;302    //do_fsm_move_start
;;;303    			} else { // goto submenu
        0x080020ba:    e020         .      B        0x80020fe ; do_fsm_menu + 478
        0x080020bc:    e7ff        ..      B        0x80020be ; do_fsm_menu + 414
;;;304    				for (int a = 0; a<Menu_size; a++) {
        0x080020be:    2000        .       MOVS     r0,#0
        0x080020c0:    e012        ..      B        0x80020e8 ; do_fsm_menu + 456
;;;305    					if(Thread_Info[a].level == Thread_Info[Menu_Step].submenu) {
        0x080020c2:    4912        .I      LDR      r1,[pc,#72] ; [0x800210c] = 0x20000170
        0x080020c4:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x080020c8:    7c49        I|      LDRB     r1,[r1,#0x11]
        0x080020ca:    4a10        .J      LDR      r2,[pc,#64] ; [0x800210c] = 0x20000170
        0x080020cc:    4b10        .K      LDR      r3,[pc,#64] ; [0x8002110] = 0x20000590
        0x080020ce:    781b        .x      LDRB     r3,[r3,#0]
        0x080020d0:    eb021243    ..C.    ADD      r2,r2,r3,LSL #5
        0x080020d4:    7912        .y      LDRB     r2,[r2,#4]
        0x080020d6:    4291        .B      CMP      r1,r2
        0x080020d8:    d105        ..      BNE      0x80020e6 ; do_fsm_menu + 454
;;;306    						Menu_Step = a;
        0x080020da:    4a0d        .J      LDR      r2,[pc,#52] ; [0x8002110] = 0x20000590
        0x080020dc:    7010        .p      STRB     r0,[r2,#0]
;;;307    						menu_changed = 1;
        0x080020de:    2101        .!      MOVS     r1,#1
        0x080020e0:    4a0e        .J      LDR      r2,[pc,#56] ; [0x800211c] = 0x20000160
        0x080020e2:    6011        .`      STR      r1,[r2,#0]
;;;308    						break;
        0x080020e4:    e004        ..      B        0x80020f0 ; do_fsm_menu + 464
        0x080020e6:    1c40        @.      ADDS     r0,r0,#1
        0x080020e8:    4912        .I      LDR      r1,[pc,#72] ; [0x8002134] = 0x8003dfa
        0x080020ea:    7809        .x      LDRB     r1,[r1,#0]
        0x080020ec:    4288        .B      CMP      r0,r1
        0x080020ee:    dbe8        ..      BLT      0x80020c2 ; do_fsm_menu + 418
        0x080020f0:    e005        ..      B        0x80020fe ; do_fsm_menu + 478
;;;309    					}
;;;310    				}
;;;311    			}
;;;312    		} else if(s->function == do_fsm_main_cut_back){
        0x080020f2:    4914        .I      LDR      r1,[pc,#80] ; [0x8002144] = 0x8001d35
        0x080020f4:    6820         h      LDR      r0,[r4,#0]
        0x080020f6:    4288        .B      CMP      r0,r1
        0x080020f8:    d101        ..      BNE      0x80020fe ; do_fsm_menu + 478
;;;313    			s->function = do_fsm_main_cut_back_prolong; // go to 48 mode to add threads until long_press end
        0x080020fa:    4813        .H      LDR      r0,[pc,#76] ; [0x8002148] = 0x8001d61
        0x080020fc:    6020         `      STR      r0,[r4,#0]
;;;314    		}
;;;315    		break;
        0x080020fe:    e002        ..      B        0x8002106 ; do_fsm_menu + 486
;;;316    	}
;;;317    	case long_press_end_Msk: {
;;;318    		s->function = do_long_press_end_callback;
        0x08002100:    4812        .H      LDR      r0,[pc,#72] ; [0x800214c] = 0x800245d
        0x08002102:    6020         `      STR      r0,[r4,#0]
;;;319    		break;
        0x08002104:    bf00        ..      NOP      
        0x08002106:    bf00        ..      NOP      
;;;320    /*
;;;321    		if(s->function == do_fsm_first_cut_main_part){
;;;322    			s->function = do_fsm_first_cut_lpe;
;;;323    			break;
;;;324    		}
;;;325    		if(s->function == do_fsm_main_cut_back_prolong){ // end of prolonged mode
;;;326    			s->function = do_fsm_main_cut_back;
;;;327    			break;
;;;328    		}
;;;329    */
;;;330    		/*
;;;331    		switch(z_axis.mode) {
;;;332    		case fsm_first_cut_main_part: {
;;;333    //																					if(auto_mode == true){
;;;334    //																									auto_mode_delay = auto_mode_delay_ms; //engage countdown timer to auto generate click event
;;;335    //																					}
;;;336    //																					Q824count = 0;
;;;337    			s->function = do_fsm_first_cut_lpe;
;;;338    			break;
;;;339    		}
;;;340    		case fsm_main_cut_back_prolong: { // end of prolonged mode
;;;341    			s->function = do_fsm_main_cut_back;
;;;342    			break;
;;;343    		}
;;;344    		}
;;;345    		*/
;;;346    		break;
;;;347    	}
;;;348    	}
;;;349    }
        0x08002108:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x0800210a:    0000        ..      DCW    0
        0x0800210c:    20000170    p..     DCD    536871280
        0x08002110:    20000590    ...     DCD    536872336
        0x08002114:    20004000    .@.     DCD    536887296
        0x08002118:    2000015d    ]..     DCD    536871261
        0x0800211c:    20000160    `..     DCD    536871264
        0x08002120:    20000a38    8..     DCD    536873528
        0x08002124:    40010c10    ...@    DCD    1073810448
        0x08002128:    08002415    .$..    DCD    134226965
        0x0800212c:    08001ee9    ....    DCD    134225641
        0x08002130:    08002151    Q!..    DCD    134226257
        0x08002134:    08003dfa    .=..    DCD    134233594
        0x08002138:    42010180    ...B    DCD    1107362176
        0x0800213c:    40010810    ...@    DCD    1073809424
        0x08002140:    0800225d    ]"..    DCD    134226525
        0x08002144:    08001d35    5...    DCD    134225205
        0x08002148:    08001d61    a...    DCD    134225249
        0x0800214c:    0800245d    ]$..    DCD    134227037
    $t
    i.do_fsm_menu_lps
    do_fsm_menu_lps
;;;350    
;;;351    void do_fsm_menu_lps(state_t* s)
;;;352    {
;;;353    }
        0x08002150:    4770        pG      BX       lr
        0x08002152:    0000        ..      MOVS     r0,r0
    i.do_fsm_move
    do_fsm_move
;;;354    
;;;355    
;;;356    
;;;357    void do_fsm_first_cut_lps(state_t* s)  // not used?
;;;358    {
;;;359    	
;;;360    	disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
;;;361    	MOTOR_Z_Enable();
;;;362    	if(feed_direction)
;;;363    		MOTOR_Z_Forward();
;;;364    	else
;;;365    		MOTOR_Z_Reverse();
;;;366    	s->function = do_fsm_wait_tacho; //intermediate state to wait tacho pulse.
;;;367    }
;;;368    
;;;369    
;;;370    
;;;371    
;;;372    
;;;373    
;;;374    void do_fsm_first_cut_ramp_up(state_t* s)          // direct movement: first pass, thread recording: ramp up: accel by ramp map
;;;375    {
;;;376    	MOTOR_Z_SetPulse();
;;;377    	z_axis.current_pos++;
;;;378    	if(z_axis_ramp_up()) {
;;;379    		s->function = do_fsm_first_cut_main_part;
;;;380    		LED_GPIO_Port->BSRR = LED_Pin; //led off
;;;381    	}
;;;382    }
;;;383    
;;;384    
;;;385    void do_fsm_first_cut_main_part(state_t* s)          // direct movement: first pass, thread recording: main part
;;;386    {
;;;387    	MOTOR_Z_SetPulse();
;;;388    	z_axis.current_pos++;
;;;389    	z_axis_move();
;;;390    }
;;;391    
;;;392    
;;;393    void do_fsm_first_cut_lpe(state_t* s)          // direct movement: first pass, thread recording: post-main part
;;;394    {
;;;395    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;396    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;397    	// не перескакивая на соседние шаги при потере питания.
;;;398    	// поэтому проверяем общее количество на четность(0й бит), если нечетное число делаем еще один шаг,
;;;399    	// иначе начинаем замедляться
;;;400    	MOTOR_Z_SetPulse();
;;;401    	z_axis.current_pos++;
;;;402    	uint32_t all_count = z_axis.ramp_step + z_axis.current_pos - 1;
;;;403    	uint32_t masked_count = all_count & ~(step_divider - 1);
;;;404    	if(masked_count != all_count) {
;;;405    		z_axis_move();
;;;406    	} else {
;;;407    		if(z_axis_ramp_down()) {
;;;408    			z_axis.end_pos = z_axis.current_pos;
;;;409    			z_axis_at_move_end(s);
;;;410    		} else {
;;;411    			s->function = do_fsm_first_cut_ramp_down;
;;;412    		}
;;;413    	}
;;;414    }
;;;415    
;;;416    
;;;417    
;;;418    
;;;419    
;;;420    
;;;421    void do_fsm_first_cut_ramp_down(state_t* s)          // direct movement: ramp down: deccel part + stop
;;;422    {
;;;423    	MOTOR_Z_SetPulse();
;;;424    	z_axis.current_pos++;
;;;425    	if(z_axis_ramp_down()) {
;;;426    		z_axis.end_pos = z_axis.current_pos;
;;;427    		z_axis_at_move_end(s);
;;;428    	}
;;;429    }
;;;430    
;;;431    
;;;432    
;;;433    void do_fsm_sclick_event(state_t* s)   // reverse movement: set direction for motor
;;;434    {
;;;435    	if(feed_direction)
;;;436    		MOTOR_Z_Forward();
;;;437    	else
;;;438    		MOTOR_Z_Reverse();
;;;439    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;440    	s->function = do_fsm_main_cut_back_ramp_up;
;;;441    }
;;;442    
;;;443    
;;;444    
;;;445    
;;;446    
;;;447    void do_fsm_main_cut_back_ramp_up(state_t* s)          // reverse movement: ramp up: accel part
;;;448    {
;;;449    	MOTOR_Z_SetPulse();
;;;450    	--z_axis.current_pos;
;;;451    	if(z_axis_ramp_up())
;;;452    		s->function = do_fsm_main_cut_back;
;;;453    }
;;;454    
;;;455    
;;;456    
;;;457    
;;;458    
;;;459    
;;;460    
;;;461    void do_fsm_main_cut_back(state_t* s)          // reverse movement: main part
;;;462    {
;;;463    	MOTOR_Z_SetPulse();
;;;464    	if( --z_axis.current_pos > z_axis.ramp_step ) {
;;;465    	} else {
;;;466    		s->function = do_fsm_main_cut_back_ramp_down;
;;;467    	}
;;;468    }
;;;469    
;;;470    
;;;471    
;;;472    void do_fsm_main_cut_back_ramp_down(state_t* s)   // reverse movement: ramp down: deccel part + stop
;;;473    {
;;;474    	if (z_axis.current_pos > 0) {
;;;475    		MOTOR_Z_SetPulse();
;;;476    		--z_axis.current_pos;
;;;477    	}
;;;478    	if(z_axis_ramp_down()) {
;;;479    		z_axis_at_move_end(s);
;;;480    	}
;;;481    }
;;;482    
;;;483    
;;;484    
;;;485    
;;;486    
;;;487    
;;;488    
;;;489    
;;;490    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;491    {
;;;492    	MOTOR_Z_SetPulse();
;;;493    	--z_axis.current_pos;
;;;494    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
;;;495    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
;;;496    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
;;;497    		z_axis.current_pos += prolong_fixpart; // add fixed part
;;;498    		z_axis.end_pos += prolong_fixpart;
;;;499    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
;;;500    		// when long_press end, get back to 46 mode to proceed
;;;501    	}
;;;502    }
;;;503    
;;;504    void do_fsm_main_cut_wait_tacho(state_t* s)   // direct movement: set direction for motor
;;;505    {
;;;506    	if(feed_direction)
;;;507    		MOTOR_Z_Forward();
;;;508    	else
;;;509    		MOTOR_Z_Reverse();
;;;510    	s->function = do_fsm_main_cut_ramp_up; // intermediate state to wait tacho pulse
;;;511    	disable_encoder_ticks(); // reset interrupt for encoder ticks, only tacho
;;;512    }
;;;513    
;;;514    void do_fsm_main_cut(state_t* s)   // direct movement: ramp up: accel by ramp map
;;;515    {
;;;516    	MOTOR_Z_SetPulse();
;;;517    	z_axis.current_pos++;
;;;518    	if(z_axis_ramp_up()) {
;;;519    		LED_GPIO_Port->BSRR = LED_Pin;   // led off
;;;520    		s->function = do_fsm_main_cut_infeed;
;;;521    	}
;;;522    }
;;;523    
;;;524    
;;;525    void do_fsm_main_cut_infeed(state_t* s)   // direct movement: main part
;;;526    {
;;;527    	MOTOR_Z_SetPulse();
;;;528    	z_axis.current_pos++;
;;;529    	if( z_axis.current_pos < ( z_axis.end_pos - z_axis.ramp_step ) ) {
;;;530    		z_axis_move();
;;;531    	} else {
;;;532    		s->function = do_fsm_first_cut_ramp_down;
;;;533    	}
;;;534    }
;;;535    
;;;536    
;;;537    void do_fsm_wait_sclick(state_t* s)
;;;538    {
;;;539    	MOTOR_Z_Disable(); //disable motor
;;;540    }
;;;541    
;;;542    void do_fsm_main_cut_ramp_up(state_t* s)
;;;543    {
;;;544    	s->function = do_fsm_main_cut;
;;;545    	//reinit counter
;;;546    //                          TIM4->ARR = fixedpt_toint(Q824set) - 1;
;;;547    	LED_GPIO_Port->BRR = LED_Pin; //led on
;;;548    
;;;549    	if(infeed_step < infeed_steps) {
;;;550    		TIM4->ARR = infeed_map[infeed_step++] + 1; // start stepper motor with shifted position by infeed map
;;;551    	} else {
;;;552    		TIM4->ARR = 1;  // start stepper motor ramp up procedure immediately after tacho event
;;;553    	}
;;;554    	TIM4->EGR |= TIM_EGR_UG;
;;;555    
;;;556    	TIM4->CNT = 0;
;;;557    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;558    }
;;;559    
;;;560    
;;;561    
;;;562    //---------------------------------------------------------------------------------------------
;;;563    void do_fsm_move_start(state_t* s){
;;;564    	if(s->main_feed_direction == feed_direction && s->f_tacho ) { // if tacho event or we going to start back feed to initial position with async clock
;;;565    		if(s->main_feed_direction == feed_direction) {
;;;566    			s->function = do_fsm_ramp_up;
;;;567    			s->sync = true;
;;;568    			s->async_z = 0;
;;;569    			s->syncbase = TIM4; 									// sync with spindle
;;;570    
;;;571    			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
;;;572    			s->syncbase->EGR |= TIM_EGR_UG; // upload ARR value immediately 
;;;573    			s->syncbase->CNT = 0;						// reset counter
;;;574    //			LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH2);
;;;575    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
;;;576    		} else {
;;;577    
;;;578    			s->async_z = 1;
;;;579    //			s->syncbase = &htim2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;580    			s->function = do_fsm_ramp_up_async;
;;;581    
;;;582    		/* Enable counter */
;;;583    		LL_TIM_EnableCounter(TIM2);
;;;584    		/* Force update generation */
;;;585    		LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;586    
;;;587    //			LL_TIM_EnableIT_UPDATE(TIM2);
;;;588    		}
;;;589    
;;;590    	}	
;;;591    }
;;;592    
;;;593    void do_fsm_ramp_up(state_t* s)
;;;594    {
;;;595    	MOTOR_Z_SetPulse();
;;;596    	z_axis.current_pos++;
;;;597    	if(z_axis_ramp_up2(s)) {
;;;598    		s->function = do_fsm_move;
;;;599    	}
;;;600    }
;;;601    
;;;602    void do_fsm_move(state_t* s)
;;;603    {
        0x08002154:    b510        ..      PUSH     {r4,lr}
        0x08002156:    4604        .F      MOV      r4,r0
;;;604    	MOTOR_Z_SetPulse();
        0x08002158:    2001        .       MOVS     r0,#1
        0x0800215a:    4913        .I      LDR      r1,[pc,#76] ; [0x80021a8] = 0x42008000
        0x0800215c:    6008        .`      STR      r0,[r1,#0]
;;;605    //	z_axis.current_pos++;
;;;606    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;607    //	else z_axis.current_pos--;
;;;608    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
        0x0800215e:    4813        .H      LDR      r0,[pc,#76] ; [0x80021ac] = 0x20000a38
        0x08002160:    6840        @h      LDR      r0,[r0,#4]
        0x08002162:    4912        .I      LDR      r1,[pc,#72] ; [0x80021ac] = 0x20000a38
        0x08002164:    f8911028    ..(.    LDRB     r1,[r1,#0x28]
        0x08002168:    1a41        A.      SUBS     r1,r0,r1
        0x0800216a:    4810        .H      LDR      r0,[pc,#64] ; [0x80021ac] = 0x20000a38
        0x0800216c:    6800        .h      LDR      r0,[r0,#0]
        0x0800216e:    1c40        @.      ADDS     r0,r0,#1
        0x08002170:    4a0e        .J      LDR      r2,[pc,#56] ; [0x80021ac] = 0x20000a38
        0x08002172:    6010        .`      STR      r0,[r2,#0]
        0x08002174:    4281        .B      CMP      r1,r0
        0x08002176:    d303        ..      BCC      0x8002180 ; do_fsm_move + 44
;;;609    		z_axis_move2(s);
        0x08002178:    4620         F      MOV      r0,r4
        0x0800217a:    f000fc7f    ....    BL       z_axis_move2 ; 0x8002a7c
        0x0800217e:    e011        ..      B        0x80021a4 ; do_fsm_move + 80
;;;610    	} else {
;;;611    		if(z_axis_ramp_down2(s)) {
        0x08002180:    4620         F      MOV      r0,r4
        0x08002182:    f000fcb9    ....    BL       z_axis_ramp_down2 ; 0x8002af8
        0x08002186:    b158        X.      CBZ      r0,0x80021a0 ; do_fsm_move + 76
;;;612    			if(z_axis.end_pos != z_axis.current_pos) {
        0x08002188:    4808        .H      LDR      r0,[pc,#32] ; [0x80021ac] = 0x20000a38
        0x0800218a:    6840        @h      LDR      r0,[r0,#4]
        0x0800218c:    4907        .I      LDR      r1,[pc,#28] ; [0x80021ac] = 0x20000a38
        0x0800218e:    6809        .h      LDR      r1,[r1,#0]
        0x08002190:    4288        .B      CMP      r0,r1
        0x08002192:    d003        ..      BEQ      0x800219c ; do_fsm_move + 72
;;;613    				z_axis.end_pos = z_axis.current_pos;
        0x08002194:    4805        .H      LDR      r0,[pc,#20] ; [0x80021ac] = 0x20000a38
        0x08002196:    6800        .h      LDR      r0,[r0,#0]
        0x08002198:    4904        .I      LDR      r1,[pc,#16] ; [0x80021ac] = 0x20000a38
        0x0800219a:    6048        H`      STR      r0,[r1,#4]
;;;614    			}
;;;615    			s->function = do_fsm_move_end;
        0x0800219c:    4804        .H      LDR      r0,[pc,#16] ; [0x80021b0] = 0x80021f5
        0x0800219e:    6020         `      STR      r0,[r4,#0]
;;;616    		}
;;;617    		s->function = do_fsm_ramp_down;
        0x080021a0:    4804        .H      LDR      r0,[pc,#16] ; [0x80021b4] = 0x80022e9
        0x080021a2:    6020         `      STR      r0,[r4,#0]
;;;618    	}
;;;619    }
        0x080021a4:    bd10        ..      POP      {r4,pc}
    $d
        0x080021a6:    0000        ..      DCW    0
        0x080021a8:    42008000    ...B    DCD    1107329024
        0x080021ac:    20000a38    8..     DCD    536873528
        0x080021b0:    080021f5    .!..    DCD    134226421
        0x080021b4:    080022e9    ."..    DCD    134226665
    $t
    i.do_fsm_move_async
    do_fsm_move_async
;;;620    
;;;621    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;622    {
;;;623    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;624    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;625    	// не перескакивая на соседние шаги при потере питания.
;;;626    	z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;627    	s->function = do_fsm_move;
;;;628    	do_fsm_move(s);
;;;629    }
;;;630    
;;;631    
;;;632    void do_fsm_ramp_down(state_t* s)
;;;633    {
;;;634    	MOTOR_Z_SetPulse();
;;;635    	if(s->spindle_dir)	z_axis.current_pos++;
;;;636    	else z_axis.current_pos--;
;;;637    	if(z_axis_ramp_down2(s)) {
;;;638    		if(z_axis.end_pos != z_axis.current_pos) {
;;;639    			z_axis.end_pos = z_axis.current_pos;
;;;640    		}
;;;641    		s->function = do_fsm_move_end;
;;;642    	}
;;;643    }
;;;644    
;;;645    void do_fsm_move_end(state_t* s){
;;;646    	s->async_z = 0;
;;;647    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;648    	if (s->sync) {
;;;649    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;650    	} else {
;;;651    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;652    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;653    	}
;;;654      MOTOR_Z_Disable(); 									//disable motor later on next tacho event (or after some ticks count?) to completely process last step
;;;655    	feed_direction = !feed_direction; 					//change feed direction
;;;656    	menu_changed = 1; 													//update menu
;;;657    	s->function = do_fsm_wait_sclick;
;;;658    
;;;659    	z_axis.current_pos = 0;
;;;660    }
;;;661    
;;;662    
;;;663    _Bool z_axis_ramp_up2(state_t* s)
;;;664    {
;;;665    	const fixedptu  set_with_fract = ramp[z_axis.ramp_step];
;;;666    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == ramp_map) { 	// reach desired speed or end of ramp map
;;;667    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;668    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;669    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;670    //		z_axis.end_minus_ramp_delta =
;;;671    		return true;
;;;672    	} else {
;;;673    		z_axis.ramp_step++;
;;;674    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;675    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;676    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;677    	}
;;;678    	return false;
;;;679    }
;;;680    
;;;681    _Bool z_axis_ramp_down2(state_t* s)
;;;682    {
;;;683    	if (z_axis.ramp_step == 0)
;;;684    		return true;
;;;685    	const fixedptu set_with_fract = ramp[--z_axis.ramp_step];
;;;686    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;687    //	s->syncbase->EGR |= TIM_EGR_UG;
;;;688    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;689    	if(z_axis.ramp_step == 0)
;;;690    		return true;
;;;691    	return false;
;;;692    }
;;;693    
;;;694    void z_axis_move2(state_t* s)
;;;695    {
;;;696    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;697    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;698    //	s->syncbase->CNT = 0;
;;;699    //	s->syncbase->EGR |= TIM_EGR_UG;
;;;700    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;701    }
;;;702    
;;;703    
;;;704    
;;;705    
;;;706    
;;;707    //------------------------------------ ASYNC block -----------------------------------
;;;708    //------------------------------------ ASYNC block -----------------------------------
;;;709    //------------------------------------ ASYNC block -----------------------------------
;;;710    void do_fsm_ramp_up_async(state_t* s)
;;;711    {
;;;712    	MOTOR_Z_SetPulse();
;;;713    	z_axis.current_pos++;
;;;714    
;;;715    	const uint8_t z_arr = ramp2[z_axis.ramp_step];
;;;716    	if(z_arr < slew_speed_period) { 	// reach desired speed
;;;717    		s->z_period = slew_speed_period;
;;;718    		s->function = do_fsm_move_async;
;;;719    	} else {
;;;720    		z_axis.ramp_step++;
;;;721    		s->z_period = z_arr;
;;;722    	}
;;;723    }
;;;724    
;;;725    void do_fsm_move_async(state_t* s)
;;;726    {
;;;727    	MOTOR_Z_SetPulse();
        0x080021b8:    2101        .!      MOVS     r1,#1
        0x080021ba:    4a0b        .J      LDR      r2,[pc,#44] ; [0x80021e8] = 0x42008000
        0x080021bc:    6011        .`      STR      r1,[r2,#0]
;;;728    	z_axis.current_pos++;
        0x080021be:    490b        .I      LDR      r1,[pc,#44] ; [0x80021ec] = 0x20000a38
        0x080021c0:    6809        .h      LDR      r1,[r1,#0]
        0x080021c2:    1c49        I.      ADDS     r1,r1,#1
        0x080021c4:    4a09        .J      LDR      r2,[pc,#36] ; [0x80021ec] = 0x20000a38
        0x080021c6:    6011        .`      STR      r1,[r2,#0]
;;;729    
;;;730    	// todo precalculate delta: z_axis.end_pos - z_axis.ramp_step
;;;731    	if( z_axis.current_pos < ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
        0x080021c8:    4611        .F      MOV      r1,r2
        0x080021ca:    6849        Ih      LDR      r1,[r1,#4]
        0x080021cc:    f8922028    ..(     LDRB     r2,[r2,#0x28]
        0x080021d0:    1a89        ..      SUBS     r1,r1,r2
        0x080021d2:    4a06        .J      LDR      r2,[pc,#24] ; [0x80021ec] = 0x20000a38
        0x080021d4:    6812        .h      LDR      r2,[r2,#0]
        0x080021d6:    4291        .B      CMP      r1,r2
        0x080021d8:    d902        ..      BLS      0x80021e0 ; do_fsm_move_async + 40
;;;732    		s->z_period = slew_speed_period;
        0x080021da:    2132        2!      MOVS     r1,#0x32
        0x080021dc:    7301        .s      STRB     r1,[r0,#0xc]
        0x080021de:    e001        ..      B        0x80021e4 ; do_fsm_move_async + 44
;;;733    	} else {
;;;734    		s->function = do_fsm_ramp_down_async;
        0x080021e0:    4903        .I      LDR      r1,[pc,#12] ; [0x80021f0] = 0x800233d
        0x080021e2:    6001        .`      STR      r1,[r0,#0]
;;;735    	}
;;;736    }
        0x080021e4:    4770        pG      BX       lr
    $d
        0x080021e6:    0000        ..      DCW    0
        0x080021e8:    42008000    ...B    DCD    1107329024
        0x080021ec:    20000a38    8..     DCD    536873528
        0x080021f0:    0800233d    =#..    DCD    134226749
    $t
    i.do_fsm_move_end
    do_fsm_move_end
;;; .\..\Src\fsm.c (646)
        0x080021f4:    2100        .!      MOVS     r1,#0
        0x080021f6:    6041        A`      STR      r1,[r0,#4]
;;;647    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
        0x080021f8:    6141        Aa      STR      r1,[r0,#0x14]
;;;648    	if (s->sync) {
        0x080021fa:    7c01        .|      LDRB     r1,[r0,#0x10]
        0x080021fc:    b119        ..      CBZ      r1,0x8002206 ; do_fsm_move_end + 18
;;;649    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
        0x080021fe:    2100        .!      MOVS     r1,#0
        0x08002200:    4a10        .J      LDR      r2,[pc,#64] ; [0x8002244] = 0x42010180
        0x08002202:    6011        .`      STR      r1,[r2,#0]
        0x08002204:    e00a        ..      B        0x800221c ; do_fsm_move_end + 40
;;;650    	} else {
;;;651    		LL_TIM_DisableCounter(TIM2); // pause async timer
        0x08002206:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1038     CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x08002208:    f04f4180    O..A    MOV      r1,#0x40000000
        0x0800220c:    6809        .h      LDR      r1,[r1,#0]
        0x0800220e:    f0210101    !...    BIC      r1,r1,#1
        0x08002212:    f04f4280    O..B    MOV      r2,#0x40000000
        0x08002216:    6011        .`      STR      r1,[r2,#0]
;;;1039   }
        0x08002218:    bf00        ..      NOP      
        0x0800221a:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;654      MOTOR_Z_Disable(); 									//disable motor later on next tacho event (or after some ticks count?) to completely process last step
        0x0800221c:    f2402102    @..!    MOV      r1,#0x202
        0x08002220:    4a09        .J      LDR      r2,[pc,#36] ; [0x8002248] = 0x40010c14
        0x08002222:    6011        .`      STR      r1,[r2,#0]
;;;655    	feed_direction = !feed_direction; 					//change feed direction
        0x08002224:    4909        .I      LDR      r1,[pc,#36] ; [0x800224c] = 0x2000015d
        0x08002226:    7809        .x      LDRB     r1,[r1,#0]
        0x08002228:    f0810101    ....    EOR      r1,r1,#1
        0x0800222c:    4a07        .J      LDR      r2,[pc,#28] ; [0x800224c] = 0x2000015d
        0x0800222e:    7011        .p      STRB     r1,[r2,#0]
;;;656    	menu_changed = 1; 													//update menu
        0x08002230:    2101        .!      MOVS     r1,#1
        0x08002232:    4a07        .J      LDR      r2,[pc,#28] ; [0x8002250] = 0x20000160
        0x08002234:    6011        .`      STR      r1,[r2,#0]
;;;657    	s->function = do_fsm_wait_sclick;
        0x08002236:    4907        .I      LDR      r1,[pc,#28] ; [0x8002254] = 0x800244d
        0x08002238:    6001        .`      STR      r1,[r0,#0]
;;;658    
;;;659    	z_axis.current_pos = 0;
        0x0800223a:    2100        .!      MOVS     r1,#0
        0x0800223c:    4a06        .J      LDR      r2,[pc,#24] ; [0x8002258] = 0x20000a38
        0x0800223e:    6011        .`      STR      r1,[r2,#0]
;;;660    }
        0x08002240:    4770        pG      BX       lr
    $d
        0x08002242:    0000        ..      DCW    0
        0x08002244:    42010180    ...B    DCD    1107362176
        0x08002248:    40010c14    ...@    DCD    1073810452
        0x0800224c:    2000015d    ]..     DCD    536871261
        0x08002250:    20000160    `..     DCD    536871264
        0x08002254:    0800244d    M$..    DCD    134227021
        0x08002258:    20000a38    8..     DCD    536873528
    $t
    i.do_fsm_move_start
    do_fsm_move_start
;;; .\..\Src\fsm.c (564)
        0x0800225c:    7c41        A|      LDRB     r1,[r0,#0x11]
        0x0800225e:    4a1d        .J      LDR      r2,[pc,#116] ; [0x80022d4] = 0x2000015d
        0x08002260:    7812        .x      LDRB     r2,[r2,#0]
        0x08002262:    4291        .B      CMP      r1,r2
        0x08002264:    d134        4.      BNE      0x80022d0 ; do_fsm_move_start + 116
;;; .\..\Src\fsm.c (564)
        0x08002266:    7b81        .{      LDRB     r1,[r0,#0xe]
        0x08002268:    b391        ..      CBZ      r1,0x80022d0 ; do_fsm_move_start + 116
;;;565    		if(s->main_feed_direction == feed_direction) {
        0x0800226a:    7c41        A|      LDRB     r1,[r0,#0x11]
        0x0800226c:    4a19        .J      LDR      r2,[pc,#100] ; [0x80022d4] = 0x2000015d
        0x0800226e:    7812        .x      LDRB     r2,[r2,#0]
        0x08002270:    4291        .B      CMP      r1,r2
        0x08002272:    d117        ..      BNE      0x80022a4 ; do_fsm_move_start + 72
;;;566    			s->function = do_fsm_ramp_up;
        0x08002274:    4918        .I      LDR      r1,[pc,#96] ; [0x80022d8] = 0x8002399
        0x08002276:    6001        .`      STR      r1,[r0,#0]
;;;567    			s->sync = true;
        0x08002278:    2101        .!      MOVS     r1,#1
        0x0800227a:    7401        .t      STRB     r1,[r0,#0x10]
;;;568    			s->async_z = 0;
        0x0800227c:    2100        .!      MOVS     r1,#0
        0x0800227e:    6041        A`      STR      r1,[r0,#4]
;;;569    			s->syncbase = TIM4; 									// sync with spindle
        0x08002280:    4916        .I      LDR      r1,[pc,#88] ; [0x80022dc] = 0x40000800
        0x08002282:    6141        Aa      STR      r1,[r0,#0x14]
;;;570    
;;;571    			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
        0x08002284:    2101        .!      MOVS     r1,#1
        0x08002286:    6942        Bi      LDR      r2,[r0,#0x14]
        0x08002288:    62d1        .b      STR      r1,[r2,#0x2c]
;;;572    			s->syncbase->EGR |= TIM_EGR_UG; // upload ARR value immediately 
        0x0800228a:    6941        Ai      LDR      r1,[r0,#0x14]
        0x0800228c:    6949        Ii      LDR      r1,[r1,#0x14]
        0x0800228e:    f0410101    A...    ORR      r1,r1,#1
        0x08002292:    6942        Bi      LDR      r2,[r0,#0x14]
        0x08002294:    6151        Qa      STR      r1,[r2,#0x14]
;;;573    			s->syncbase->CNT = 0;						// reset counter
        0x08002296:    2100        .!      MOVS     r1,#0
        0x08002298:    6942        Bi      LDR      r2,[r0,#0x14]
        0x0800229a:    6251        Qb      STR      r1,[r2,#0x24]
;;;574    //			LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH2);
;;;575    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
        0x0800229c:    2101        .!      MOVS     r1,#1
        0x0800229e:    4a10        .J      LDR      r2,[pc,#64] ; [0x80022e0] = 0x42010180
        0x080022a0:    6011        .`      STR      r1,[r2,#0]
        0x080022a2:    e015        ..      B        0x80022d0 ; do_fsm_move_start + 116
;;;576    		} else {
;;;577    
;;;578    			s->async_z = 1;
        0x080022a4:    2101        .!      MOVS     r1,#1
        0x080022a6:    6041        A`      STR      r1,[r0,#4]
;;;579    //			s->syncbase = &htim2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;580    			s->function = do_fsm_ramp_up_async;
        0x080022a8:    490e        .I      LDR      r1,[pc,#56] ; [0x80022e4] = 0x80023c9
        0x080022aa:    6001        .`      STR      r1,[r0,#0]
;;;581    
;;;582    		/* Enable counter */
;;;583    		LL_TIM_EnableCounter(TIM2);
        0x080022ac:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1027     SET_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x080022ae:    f04f4180    O..A    MOV      r1,#0x40000000
        0x080022b2:    6809        .h      LDR      r1,[r1,#0]
        0x080022b4:    f0410101    A...    ORR      r1,r1,#1
        0x080022b8:    f04f4280    O..B    MOV      r2,#0x40000000
        0x080022bc:    6011        .`      STR      r1,[r2,#0]
;;;1028   }
        0x080022be:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;585    		LL_TIM_GenerateEvent_UPDATE(TIM2);
        0x080022c0:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3709     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x080022c2:    4611        .F      MOV      r1,r2
        0x080022c4:    6949        Ii      LDR      r1,[r1,#0x14]
        0x080022c6:    f0410101    A...    ORR      r1,r1,#1
        0x080022ca:    6151        Qa      STR      r1,[r2,#0x14]
;;;3710   }
        0x080022cc:    bf00        ..      NOP      
        0x080022ce:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;591    }
        0x080022d0:    4770        pG      BX       lr
    $d
        0x080022d2:    0000        ..      DCW    0
        0x080022d4:    2000015d    ]..     DCD    536871261
        0x080022d8:    08002399    .#..    DCD    134226841
        0x080022dc:    40000800    ...@    DCD    1073743872
        0x080022e0:    42010180    ...B    DCD    1107362176
        0x080022e4:    080023c9    .#..    DCD    134226889
    $t
    i.do_fsm_ramp_down
    do_fsm_ramp_down
;;;592    
;;;593    void do_fsm_ramp_up(state_t* s)
;;;594    {
;;;595    	MOTOR_Z_SetPulse();
;;;596    	z_axis.current_pos++;
;;;597    	if(z_axis_ramp_up2(s)) {
;;;598    		s->function = do_fsm_move;
;;;599    	}
;;;600    }
;;;601    
;;;602    void do_fsm_move(state_t* s)
;;;603    {
;;;604    	MOTOR_Z_SetPulse();
;;;605    //	z_axis.current_pos++;
;;;606    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;607    //	else z_axis.current_pos--;
;;;608    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;609    		z_axis_move2(s);
;;;610    	} else {
;;;611    		if(z_axis_ramp_down2(s)) {
;;;612    			if(z_axis.end_pos != z_axis.current_pos) {
;;;613    				z_axis.end_pos = z_axis.current_pos;
;;;614    			}
;;;615    			s->function = do_fsm_move_end;
;;;616    		}
;;;617    		s->function = do_fsm_ramp_down;
;;;618    	}
;;;619    }
;;;620    
;;;621    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;622    {
;;;623    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;624    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;625    	// не перескакивая на соседние шаги при потере питания.
;;;626    	z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;627    	s->function = do_fsm_move;
;;;628    	do_fsm_move(s);
;;;629    }
;;;630    
;;;631    
;;;632    void do_fsm_ramp_down(state_t* s)
;;;633    {
        0x080022e8:    b510        ..      PUSH     {r4,lr}
        0x080022ea:    4604        .F      MOV      r4,r0
;;;634    	MOTOR_Z_SetPulse();
        0x080022ec:    2001        .       MOVS     r0,#1
        0x080022ee:    4910        .I      LDR      r1,[pc,#64] ; [0x8002330] = 0x42008000
        0x080022f0:    6008        .`      STR      r0,[r1,#0]
;;;635    	if(s->spindle_dir)	z_axis.current_pos++;
        0x080022f2:    7be0        .{      LDRB     r0,[r4,#0xf]
        0x080022f4:    b128        (.      CBZ      r0,0x8002302 ; do_fsm_ramp_down + 26
        0x080022f6:    480f        .H      LDR      r0,[pc,#60] ; [0x8002334] = 0x20000a38
        0x080022f8:    6800        .h      LDR      r0,[r0,#0]
        0x080022fa:    1c40        @.      ADDS     r0,r0,#1
        0x080022fc:    490d        .I      LDR      r1,[pc,#52] ; [0x8002334] = 0x20000a38
        0x080022fe:    6008        .`      STR      r0,[r1,#0]
        0x08002300:    e004        ..      B        0x800230c ; do_fsm_ramp_down + 36
;;;636    	else z_axis.current_pos--;
        0x08002302:    480c        .H      LDR      r0,[pc,#48] ; [0x8002334] = 0x20000a38
        0x08002304:    6800        .h      LDR      r0,[r0,#0]
        0x08002306:    1e40        @.      SUBS     r0,r0,#1
        0x08002308:    490a        .I      LDR      r1,[pc,#40] ; [0x8002334] = 0x20000a38
        0x0800230a:    6008        .`      STR      r0,[r1,#0]
;;;637    	if(z_axis_ramp_down2(s)) {
        0x0800230c:    4620         F      MOV      r0,r4
        0x0800230e:    f000fbf3    ....    BL       z_axis_ramp_down2 ; 0x8002af8
        0x08002312:    b158        X.      CBZ      r0,0x800232c ; do_fsm_ramp_down + 68
;;;638    		if(z_axis.end_pos != z_axis.current_pos) {
        0x08002314:    4807        .H      LDR      r0,[pc,#28] ; [0x8002334] = 0x20000a38
        0x08002316:    6840        @h      LDR      r0,[r0,#4]
        0x08002318:    4906        .I      LDR      r1,[pc,#24] ; [0x8002334] = 0x20000a38
        0x0800231a:    6809        .h      LDR      r1,[r1,#0]
        0x0800231c:    4288        .B      CMP      r0,r1
        0x0800231e:    d003        ..      BEQ      0x8002328 ; do_fsm_ramp_down + 64
;;;639    			z_axis.end_pos = z_axis.current_pos;
        0x08002320:    4804        .H      LDR      r0,[pc,#16] ; [0x8002334] = 0x20000a38
        0x08002322:    6800        .h      LDR      r0,[r0,#0]
        0x08002324:    4903        .I      LDR      r1,[pc,#12] ; [0x8002334] = 0x20000a38
        0x08002326:    6048        H`      STR      r0,[r1,#4]
;;;640    		}
;;;641    		s->function = do_fsm_move_end;
        0x08002328:    4803        .H      LDR      r0,[pc,#12] ; [0x8002338] = 0x80021f5
        0x0800232a:    6020         `      STR      r0,[r4,#0]
;;;642    	}
;;;643    }
        0x0800232c:    bd10        ..      POP      {r4,pc}
    $d
        0x0800232e:    0000        ..      DCW    0
        0x08002330:    42008000    ...B    DCD    1107329024
        0x08002334:    20000a38    8..     DCD    536873528
        0x08002338:    080021f5    .!..    DCD    134226421
    $t
    i.do_fsm_ramp_down_async
    do_fsm_ramp_down_async
;;;644    
;;;645    void do_fsm_move_end(state_t* s){
;;;646    	s->async_z = 0;
;;;647    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;648    	if (s->sync) {
;;;649    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;650    	} else {
;;;651    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;652    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;653    	}
;;;654      MOTOR_Z_Disable(); 									//disable motor later on next tacho event (or after some ticks count?) to completely process last step
;;;655    	feed_direction = !feed_direction; 					//change feed direction
;;;656    	menu_changed = 1; 													//update menu
;;;657    	s->function = do_fsm_wait_sclick;
;;;658    
;;;659    	z_axis.current_pos = 0;
;;;660    }
;;;661    
;;;662    
;;;663    _Bool z_axis_ramp_up2(state_t* s)
;;;664    {
;;;665    	const fixedptu  set_with_fract = ramp[z_axis.ramp_step];
;;;666    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == ramp_map) { 	// reach desired speed or end of ramp map
;;;667    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;668    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;669    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;670    //		z_axis.end_minus_ramp_delta =
;;;671    		return true;
;;;672    	} else {
;;;673    		z_axis.ramp_step++;
;;;674    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;675    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;676    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;677    	}
;;;678    	return false;
;;;679    }
;;;680    
;;;681    _Bool z_axis_ramp_down2(state_t* s)
;;;682    {
;;;683    	if (z_axis.ramp_step == 0)
;;;684    		return true;
;;;685    	const fixedptu set_with_fract = ramp[--z_axis.ramp_step];
;;;686    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;687    //	s->syncbase->EGR |= TIM_EGR_UG;
;;;688    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;689    	if(z_axis.ramp_step == 0)
;;;690    		return true;
;;;691    	return false;
;;;692    }
;;;693    
;;;694    void z_axis_move2(state_t* s)
;;;695    {
;;;696    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;697    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;698    //	s->syncbase->CNT = 0;
;;;699    //	s->syncbase->EGR |= TIM_EGR_UG;
;;;700    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;701    }
;;;702    
;;;703    
;;;704    
;;;705    
;;;706    
;;;707    //------------------------------------ ASYNC block -----------------------------------
;;;708    //------------------------------------ ASYNC block -----------------------------------
;;;709    //------------------------------------ ASYNC block -----------------------------------
;;;710    void do_fsm_ramp_up_async(state_t* s)
;;;711    {
;;;712    	MOTOR_Z_SetPulse();
;;;713    	z_axis.current_pos++;
;;;714    
;;;715    	const uint8_t z_arr = ramp2[z_axis.ramp_step];
;;;716    	if(z_arr < slew_speed_period) { 	// reach desired speed
;;;717    		s->z_period = slew_speed_period;
;;;718    		s->function = do_fsm_move_async;
;;;719    	} else {
;;;720    		z_axis.ramp_step++;
;;;721    		s->z_period = z_arr;
;;;722    	}
;;;723    }
;;;724    
;;;725    void do_fsm_move_async(state_t* s)
;;;726    {
;;;727    	MOTOR_Z_SetPulse();
;;;728    	z_axis.current_pos++;
;;;729    
;;;730    	// todo precalculate delta: z_axis.end_pos - z_axis.ramp_step
;;;731    	if( z_axis.current_pos < ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;732    		s->z_period = slew_speed_period;
;;;733    	} else {
;;;734    		s->function = do_fsm_ramp_down_async;
;;;735    	}
;;;736    }
;;;737    
;;;738    void do_fsm_ramp_down_async(state_t* s)
;;;739    {
;;;740    	MOTOR_Z_SetPulse();
        0x0800233c:    2101        .!      MOVS     r1,#1
        0x0800233e:    4a12        .J      LDR      r2,[pc,#72] ; [0x8002388] = 0x42008000
        0x08002340:    6011        .`      STR      r1,[r2,#0]
;;;741    	z_axis.current_pos++;
        0x08002342:    4912        .I      LDR      r1,[pc,#72] ; [0x800238c] = 0x20000a38
        0x08002344:    6809        .h      LDR      r1,[r1,#0]
        0x08002346:    1c49        I.      ADDS     r1,r1,#1
        0x08002348:    4a10        .J      LDR      r2,[pc,#64] ; [0x800238c] = 0x20000a38
        0x0800234a:    6011        .`      STR      r1,[r2,#0]
;;;742    
;;;743    	if (--z_axis.ramp_step != 0) {
        0x0800234c:    4611        .F      MOV      r1,r2
        0x0800234e:    f8911028    ..(.    LDRB     r1,[r1,#0x28]
        0x08002352:    1e49        I.      SUBS     r1,r1,#1
        0x08002354:    b2c9        ..      UXTB     r1,r1
        0x08002356:    f8821028    ..(.    STRB     r1,[r2,#0x28]
        0x0800235a:    b129        ).      CBZ      r1,0x8002368 ; do_fsm_ramp_down_async + 44
;;;744    		const uint8_t z_arr = ramp2[z_axis.ramp_step];
        0x0800235c:    f8922028    ..(     LDRB     r2,[r2,#0x28]
        0x08002360:    4b0b        .K      LDR      r3,[pc,#44] ; [0x8002390] = 0x20000028
        0x08002362:    5c99        .\      LDRB     r1,[r3,r2]
;;;745    		s->z_period = z_arr;
        0x08002364:    7301        .s      STRB     r1,[r0,#0xc]
;;;746    	} else {
        0x08002366:    e00d        ..      B        0x8002384 ; do_fsm_ramp_down_async + 72
;;;747    // for last step there is no need to wail long, motor can be start to desabled after 145 processor ticks, so with prescaler =145 and more ARR = 1 is enought
;;;748    		s->z_period = 1; 
        0x08002368:    2101        .!      MOVS     r1,#1
        0x0800236a:    7301        .s      STRB     r1,[r0,#0xc]
;;;749    		if(z_axis.end_pos != z_axis.current_pos) {
        0x0800236c:    4907        .I      LDR      r1,[pc,#28] ; [0x800238c] = 0x20000a38
        0x0800236e:    6849        Ih      LDR      r1,[r1,#4]
        0x08002370:    4a06        .J      LDR      r2,[pc,#24] ; [0x800238c] = 0x20000a38
        0x08002372:    6812        .h      LDR      r2,[r2,#0]
        0x08002374:    4291        .B      CMP      r1,r2
        0x08002376:    d003        ..      BEQ      0x8002380 ; do_fsm_ramp_down_async + 68
;;;750    			z_axis.end_pos = z_axis.current_pos;
        0x08002378:    4904        .I      LDR      r1,[pc,#16] ; [0x800238c] = 0x20000a38
        0x0800237a:    6809        .h      LDR      r1,[r1,#0]
        0x0800237c:    4a03        .J      LDR      r2,[pc,#12] ; [0x800238c] = 0x20000a38
        0x0800237e:    6051        Q`      STR      r1,[r2,#4]
;;;751    		}
;;;752    		s->function = do_fsm_move_end;
        0x08002380:    4904        .I      LDR      r1,[pc,#16] ; [0x8002394] = 0x80021f5
        0x08002382:    6001        .`      STR      r1,[r0,#0]
;;;753    	}
;;;754    }
        0x08002384:    4770        pG      BX       lr
    $d
        0x08002386:    0000        ..      DCW    0
        0x08002388:    42008000    ...B    DCD    1107329024
        0x0800238c:    20000a38    8..     DCD    536873528
        0x08002390:    20000028    (..     DCD    536870952
        0x08002394:    080021f5    .!..    DCD    134226421
    $t
    i.do_fsm_ramp_up
    do_fsm_ramp_up
;;; .\..\Src\fsm.c (594)
        0x08002398:    b510        ..      PUSH     {r4,lr}
        0x0800239a:    4604        .F      MOV      r4,r0
;;;595    	MOTOR_Z_SetPulse();
        0x0800239c:    2001        .       MOVS     r0,#1
        0x0800239e:    4907        .I      LDR      r1,[pc,#28] ; [0x80023bc] = 0x42008000
        0x080023a0:    6008        .`      STR      r0,[r1,#0]
;;;596    	z_axis.current_pos++;
        0x080023a2:    4807        .H      LDR      r0,[pc,#28] ; [0x80023c0] = 0x20000a38
        0x080023a4:    6800        .h      LDR      r0,[r0,#0]
        0x080023a6:    1c40        @.      ADDS     r0,r0,#1
        0x080023a8:    4905        .I      LDR      r1,[pc,#20] ; [0x80023c0] = 0x20000a38
        0x080023aa:    6008        .`      STR      r0,[r1,#0]
;;;597    	if(z_axis_ramp_up2(s)) {
        0x080023ac:    4620         F      MOV      r0,r4
        0x080023ae:    f000fc09    ....    BL       z_axis_ramp_up2 ; 0x8002bc4
        0x080023b2:    b108        ..      CBZ      r0,0x80023b8 ; do_fsm_ramp_up + 32
;;;598    		s->function = do_fsm_move;
        0x080023b4:    4803        .H      LDR      r0,[pc,#12] ; [0x80023c4] = 0x8002155
        0x080023b6:    6020         `      STR      r0,[r4,#0]
;;;599    	}
;;;600    }
        0x080023b8:    bd10        ..      POP      {r4,pc}
    $d
        0x080023ba:    0000        ..      DCW    0
        0x080023bc:    42008000    ...B    DCD    1107329024
        0x080023c0:    20000a38    8..     DCD    536873528
        0x080023c4:    08002155    U!..    DCD    134226261
    $t
    i.do_fsm_ramp_up_async
    do_fsm_ramp_up_async
;;;601    
;;;602    void do_fsm_move(state_t* s)
;;;603    {
;;;604    	MOTOR_Z_SetPulse();
;;;605    //	z_axis.current_pos++;
;;;606    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;607    //	else z_axis.current_pos--;
;;;608    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;609    		z_axis_move2(s);
;;;610    	} else {
;;;611    		if(z_axis_ramp_down2(s)) {
;;;612    			if(z_axis.end_pos != z_axis.current_pos) {
;;;613    				z_axis.end_pos = z_axis.current_pos;
;;;614    			}
;;;615    			s->function = do_fsm_move_end;
;;;616    		}
;;;617    		s->function = do_fsm_ramp_down;
;;;618    	}
;;;619    }
;;;620    
;;;621    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;622    {
;;;623    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;624    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;625    	// не перескакивая на соседние шаги при потере питания.
;;;626    	z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;627    	s->function = do_fsm_move;
;;;628    	do_fsm_move(s);
;;;629    }
;;;630    
;;;631    
;;;632    void do_fsm_ramp_down(state_t* s)
;;;633    {
;;;634    	MOTOR_Z_SetPulse();
;;;635    	if(s->spindle_dir)	z_axis.current_pos++;
;;;636    	else z_axis.current_pos--;
;;;637    	if(z_axis_ramp_down2(s)) {
;;;638    		if(z_axis.end_pos != z_axis.current_pos) {
;;;639    			z_axis.end_pos = z_axis.current_pos;
;;;640    		}
;;;641    		s->function = do_fsm_move_end;
;;;642    	}
;;;643    }
;;;644    
;;;645    void do_fsm_move_end(state_t* s){
;;;646    	s->async_z = 0;
;;;647    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;648    	if (s->sync) {
;;;649    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;650    	} else {
;;;651    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;652    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;653    	}
;;;654      MOTOR_Z_Disable(); 									//disable motor later on next tacho event (or after some ticks count?) to completely process last step
;;;655    	feed_direction = !feed_direction; 					//change feed direction
;;;656    	menu_changed = 1; 													//update menu
;;;657    	s->function = do_fsm_wait_sclick;
;;;658    
;;;659    	z_axis.current_pos = 0;
;;;660    }
;;;661    
;;;662    
;;;663    _Bool z_axis_ramp_up2(state_t* s)
;;;664    {
;;;665    	const fixedptu  set_with_fract = ramp[z_axis.ramp_step];
;;;666    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == ramp_map) { 	// reach desired speed or end of ramp map
;;;667    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;668    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;669    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;670    //		z_axis.end_minus_ramp_delta =
;;;671    		return true;
;;;672    	} else {
;;;673    		z_axis.ramp_step++;
;;;674    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;675    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;676    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;677    	}
;;;678    	return false;
;;;679    }
;;;680    
;;;681    _Bool z_axis_ramp_down2(state_t* s)
;;;682    {
;;;683    	if (z_axis.ramp_step == 0)
;;;684    		return true;
;;;685    	const fixedptu set_with_fract = ramp[--z_axis.ramp_step];
;;;686    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;687    //	s->syncbase->EGR |= TIM_EGR_UG;
;;;688    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;689    	if(z_axis.ramp_step == 0)
;;;690    		return true;
;;;691    	return false;
;;;692    }
;;;693    
;;;694    void z_axis_move2(state_t* s)
;;;695    {
;;;696    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;697    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;698    //	s->syncbase->CNT = 0;
;;;699    //	s->syncbase->EGR |= TIM_EGR_UG;
;;;700    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;701    }
;;;702    
;;;703    
;;;704    
;;;705    
;;;706    
;;;707    //------------------------------------ ASYNC block -----------------------------------
;;;708    //------------------------------------ ASYNC block -----------------------------------
;;;709    //------------------------------------ ASYNC block -----------------------------------
;;;710    void do_fsm_ramp_up_async(state_t* s)
;;;711    {
;;;712    	MOTOR_Z_SetPulse();
        0x080023c8:    2201        ."      MOVS     r2,#1
        0x080023ca:    4b0e        .K      LDR      r3,[pc,#56] ; [0x8002404] = 0x42008000
        0x080023cc:    601a        .`      STR      r2,[r3,#0]
;;;713    	z_axis.current_pos++;
        0x080023ce:    4a0e        .J      LDR      r2,[pc,#56] ; [0x8002408] = 0x20000a38
        0x080023d0:    6812        .h      LDR      r2,[r2,#0]
        0x080023d2:    1c52        R.      ADDS     r2,r2,#1
        0x080023d4:    4b0c        .K      LDR      r3,[pc,#48] ; [0x8002408] = 0x20000a38
        0x080023d6:    601a        .`      STR      r2,[r3,#0]
;;;714    
;;;715    	const uint8_t z_arr = ramp2[z_axis.ramp_step];
        0x080023d8:    461a        .F      MOV      r2,r3
        0x080023da:    f8922028    ..(     LDRB     r2,[r2,#0x28]
        0x080023de:    4b0b        .K      LDR      r3,[pc,#44] ; [0x800240c] = 0x20000028
        0x080023e0:    5c99        .\      LDRB     r1,[r3,r2]
;;;716    	if(z_arr < slew_speed_period) { 	// reach desired speed
        0x080023e2:    2932        2)      CMP      r1,#0x32
        0x080023e4:    da04        ..      BGE      0x80023f0 ; do_fsm_ramp_up_async + 40
;;;717    		s->z_period = slew_speed_period;
        0x080023e6:    2232        2"      MOVS     r2,#0x32
        0x080023e8:    7302        .s      STRB     r2,[r0,#0xc]
;;;718    		s->function = do_fsm_move_async;
        0x080023ea:    4a09        .J      LDR      r2,[pc,#36] ; [0x8002410] = 0x80021b9
        0x080023ec:    6002        .`      STR      r2,[r0,#0]
        0x080023ee:    e007        ..      B        0x8002400 ; do_fsm_ramp_up_async + 56
;;;719    	} else {
;;;720    		z_axis.ramp_step++;
        0x080023f0:    4a05        .J      LDR      r2,[pc,#20] ; [0x8002408] = 0x20000a38
        0x080023f2:    f8922028    ..(     LDRB     r2,[r2,#0x28]
        0x080023f6:    1c52        R.      ADDS     r2,r2,#1
        0x080023f8:    4b03        .K      LDR      r3,[pc,#12] ; [0x8002408] = 0x20000a38
        0x080023fa:    f8832028    ..(     STRB     r2,[r3,#0x28]
;;;721    		s->z_period = z_arr;
        0x080023fe:    7301        .s      STRB     r1,[r0,#0xc]
;;;722    	}
;;;723    }
        0x08002400:    4770        pG      BX       lr
    $d
        0x08002402:    0000        ..      DCW    0
        0x08002404:    42008000    ...B    DCD    1107329024
        0x08002408:    20000a38    8..     DCD    536873528
        0x0800240c:    20000028    (..     DCD    536870952
        0x08002410:    080021b9    .!..    DCD    134226361
    $t
    i.do_fsm_sclick_event
    do_fsm_sclick_event
;;; .\..\Src\fsm.c (435)
        0x08002414:    4909        .I      LDR      r1,[pc,#36] ; [0x800243c] = 0x2000015d
        0x08002416:    7809        .x      LDRB     r1,[r1,#0]
        0x08002418:    b121        !.      CBZ      r1,0x8002424 ; do_fsm_sclick_event + 16
;;;436    		MOTOR_Z_Forward();
        0x0800241a:    f2480180    H...    MOV      r1,#0x8080
        0x0800241e:    4a08        .J      LDR      r2,[pc,#32] ; [0x8002440] = 0x40010810
        0x08002420:    6011        .`      STR      r1,[r2,#0]
        0x08002422:    e004        ..      B        0x800242e ; do_fsm_sclick_event + 26
;;;437    	else
;;;438    		MOTOR_Z_Reverse();
        0x08002424:    f2480180    H...    MOV      r1,#0x8080
        0x08002428:    4a05        .J      LDR      r2,[pc,#20] ; [0x8002440] = 0x40010810
        0x0800242a:    1d12        ..      ADDS     r2,r2,#4
        0x0800242c:    6011        .`      STR      r1,[r2,#0]
;;;439    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
        0x0800242e:    2101        .!      MOVS     r1,#1
        0x08002430:    4a04        .J      LDR      r2,[pc,#16] ; [0x8002444] = 0x42010180
        0x08002432:    6011        .`      STR      r1,[r2,#0]
;;;440    	s->function = do_fsm_main_cut_back_ramp_up;
        0x08002434:    4904        .I      LDR      r1,[pc,#16] ; [0x8002448] = 0x8001e05
        0x08002436:    6001        .`      STR      r1,[r0,#0]
;;;441    }
        0x08002438:    4770        pG      BX       lr
    $d
        0x0800243a:    0000        ..      DCW    0
        0x0800243c:    2000015d    ]..     DCD    536871261
        0x08002440:    40010810    ...@    DCD    1073809424
        0x08002444:    42010180    ...B    DCD    1107362176
        0x08002448:    08001e05    ....    DCD    134225413
    $t
    i.do_fsm_wait_sclick
    do_fsm_wait_sclick
;;;442    
;;;443    
;;;444    
;;;445    
;;;446    
;;;447    void do_fsm_main_cut_back_ramp_up(state_t* s)          // reverse movement: ramp up: accel part
;;;448    {
;;;449    	MOTOR_Z_SetPulse();
;;;450    	--z_axis.current_pos;
;;;451    	if(z_axis_ramp_up())
;;;452    		s->function = do_fsm_main_cut_back;
;;;453    }
;;;454    
;;;455    
;;;456    
;;;457    
;;;458    
;;;459    
;;;460    
;;;461    void do_fsm_main_cut_back(state_t* s)          // reverse movement: main part
;;;462    {
;;;463    	MOTOR_Z_SetPulse();
;;;464    	if( --z_axis.current_pos > z_axis.ramp_step ) {
;;;465    	} else {
;;;466    		s->function = do_fsm_main_cut_back_ramp_down;
;;;467    	}
;;;468    }
;;;469    
;;;470    
;;;471    
;;;472    void do_fsm_main_cut_back_ramp_down(state_t* s)   // reverse movement: ramp down: deccel part + stop
;;;473    {
;;;474    	if (z_axis.current_pos > 0) {
;;;475    		MOTOR_Z_SetPulse();
;;;476    		--z_axis.current_pos;
;;;477    	}
;;;478    	if(z_axis_ramp_down()) {
;;;479    		z_axis_at_move_end(s);
;;;480    	}
;;;481    }
;;;482    
;;;483    
;;;484    
;;;485    
;;;486    
;;;487    
;;;488    
;;;489    
;;;490    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;491    {
;;;492    	MOTOR_Z_SetPulse();
;;;493    	--z_axis.current_pos;
;;;494    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
;;;495    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
;;;496    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
;;;497    		z_axis.current_pos += prolong_fixpart; // add fixed part
;;;498    		z_axis.end_pos += prolong_fixpart;
;;;499    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
;;;500    		// when long_press end, get back to 46 mode to proceed
;;;501    	}
;;;502    }
;;;503    
;;;504    void do_fsm_main_cut_wait_tacho(state_t* s)   // direct movement: set direction for motor
;;;505    {
;;;506    	if(feed_direction)
;;;507    		MOTOR_Z_Forward();
;;;508    	else
;;;509    		MOTOR_Z_Reverse();
;;;510    	s->function = do_fsm_main_cut_ramp_up; // intermediate state to wait tacho pulse
;;;511    	disable_encoder_ticks(); // reset interrupt for encoder ticks, only tacho
;;;512    }
;;;513    
;;;514    void do_fsm_main_cut(state_t* s)   // direct movement: ramp up: accel by ramp map
;;;515    {
;;;516    	MOTOR_Z_SetPulse();
;;;517    	z_axis.current_pos++;
;;;518    	if(z_axis_ramp_up()) {
;;;519    		LED_GPIO_Port->BSRR = LED_Pin;   // led off
;;;520    		s->function = do_fsm_main_cut_infeed;
;;;521    	}
;;;522    }
;;;523    
;;;524    
;;;525    void do_fsm_main_cut_infeed(state_t* s)   // direct movement: main part
;;;526    {
;;;527    	MOTOR_Z_SetPulse();
;;;528    	z_axis.current_pos++;
;;;529    	if( z_axis.current_pos < ( z_axis.end_pos - z_axis.ramp_step ) ) {
;;;530    		z_axis_move();
;;;531    	} else {
;;;532    		s->function = do_fsm_first_cut_ramp_down;
;;;533    	}
;;;534    }
;;;535    
;;;536    
;;;537    void do_fsm_wait_sclick(state_t* s)
;;;538    {
;;;539    	MOTOR_Z_Disable(); //disable motor
        0x0800244c:    f2402102    @..!    MOV      r1,#0x202
        0x08002450:    4a01        .J      LDR      r2,[pc,#4] ; [0x8002458] = 0x40010c14
        0x08002452:    6011        .`      STR      r1,[r2,#0]
;;;540    }
        0x08002454:    4770        pG      BX       lr
    $d
        0x08002456:    0000        ..      DCW    0
        0x08002458:    40010c14    ...@    DCD    1073810452
    $t
    i.do_long_press_end_callback
    do_long_press_end_callback
;;;541    
;;;542    void do_fsm_main_cut_ramp_up(state_t* s)
;;;543    {
;;;544    	s->function = do_fsm_main_cut;
;;;545    	//reinit counter
;;;546    //                          TIM4->ARR = fixedpt_toint(Q824set) - 1;
;;;547    	LED_GPIO_Port->BRR = LED_Pin; //led on
;;;548    
;;;549    	if(infeed_step < infeed_steps) {
;;;550    		TIM4->ARR = infeed_map[infeed_step++] + 1; // start stepper motor with shifted position by infeed map
;;;551    	} else {
;;;552    		TIM4->ARR = 1;  // start stepper motor ramp up procedure immediately after tacho event
;;;553    	}
;;;554    	TIM4->EGR |= TIM_EGR_UG;
;;;555    
;;;556    	TIM4->CNT = 0;
;;;557    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;558    }
;;;559    
;;;560    
;;;561    
;;;562    //---------------------------------------------------------------------------------------------
;;;563    void do_fsm_move_start(state_t* s){
;;;564    	if(s->main_feed_direction == feed_direction && s->f_tacho ) { // if tacho event or we going to start back feed to initial position with async clock
;;;565    		if(s->main_feed_direction == feed_direction) {
;;;566    			s->function = do_fsm_ramp_up;
;;;567    			s->sync = true;
;;;568    			s->async_z = 0;
;;;569    			s->syncbase = TIM4; 									// sync with spindle
;;;570    
;;;571    			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
;;;572    			s->syncbase->EGR |= TIM_EGR_UG; // upload ARR value immediately 
;;;573    			s->syncbase->CNT = 0;						// reset counter
;;;574    //			LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH2);
;;;575    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
;;;576    		} else {
;;;577    
;;;578    			s->async_z = 1;
;;;579    //			s->syncbase = &htim2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;580    			s->function = do_fsm_ramp_up_async;
;;;581    
;;;582    		/* Enable counter */
;;;583    		LL_TIM_EnableCounter(TIM2);
;;;584    		/* Force update generation */
;;;585    		LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;586    
;;;587    //			LL_TIM_EnableIT_UPDATE(TIM2);
;;;588    		}
;;;589    
;;;590    	}	
;;;591    }
;;;592    
;;;593    void do_fsm_ramp_up(state_t* s)
;;;594    {
;;;595    	MOTOR_Z_SetPulse();
;;;596    	z_axis.current_pos++;
;;;597    	if(z_axis_ramp_up2(s)) {
;;;598    		s->function = do_fsm_move;
;;;599    	}
;;;600    }
;;;601    
;;;602    void do_fsm_move(state_t* s)
;;;603    {
;;;604    	MOTOR_Z_SetPulse();
;;;605    //	z_axis.current_pos++;
;;;606    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;607    //	else z_axis.current_pos--;
;;;608    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;609    		z_axis_move2(s);
;;;610    	} else {
;;;611    		if(z_axis_ramp_down2(s)) {
;;;612    			if(z_axis.end_pos != z_axis.current_pos) {
;;;613    				z_axis.end_pos = z_axis.current_pos;
;;;614    			}
;;;615    			s->function = do_fsm_move_end;
;;;616    		}
;;;617    		s->function = do_fsm_ramp_down;
;;;618    	}
;;;619    }
;;;620    
;;;621    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;622    {
        0x0800245c:    b510        ..      PUSH     {r4,lr}
        0x0800245e:    4604        .F      MOV      r4,r0
;;;623    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;624    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;625    	// не перескакивая на соседние шаги при потере питания.
;;;626    	z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
        0x08002460:    4807        .H      LDR      r0,[pc,#28] ; [0x8002480] = 0x20000a38
        0x08002462:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002466:    4906        .I      LDR      r1,[pc,#24] ; [0x8002480] = 0x20000a38
        0x08002468:    6809        .h      LDR      r1,[r1,#0]
        0x0800246a:    4408        .D      ADD      r0,r0,r1
        0x0800246c:    f0400001    @...    ORR      r0,r0,#1
        0x08002470:    4903        .I      LDR      r1,[pc,#12] ; [0x8002480] = 0x20000a38
        0x08002472:    6048        H`      STR      r0,[r1,#4]
;;;627    	s->function = do_fsm_move;
        0x08002474:    4803        .H      LDR      r0,[pc,#12] ; [0x8002484] = 0x8002155
        0x08002476:    6020         `      STR      r0,[r4,#0]
;;;628    	do_fsm_move(s);
        0x08002478:    4620         F      MOV      r0,r4
        0x0800247a:    f7fffe6b    ..k.    BL       do_fsm_move ; 0x8002154
;;;629    }
        0x0800247e:    bd10        ..      POP      {r4,pc}
    $d
        0x08002480:    20000a38    8..     DCD    536873528
        0x08002484:    08002155    U!..    DCD    134226261
    $t
    i.init_buttons
    init_buttons
;;; .\..\Src\buttons.c
;;;11     void init_buttons(void){
        0x08002488:    b510        ..      PUSH     {r4,lr}
;;;12     
;;;13     	bt[0].clk_mode = 10;
        0x0800248a:    200a        .       MOVS     r0,#0xa
        0x0800248c:    4906        .I      LDR      r1,[pc,#24] ; [0x80024a8] = 0x20000a14
        0x0800248e:    61c8        .a      STR      r0,[r1,#0x1c]
;;;14     	bt[0].GPIOx = BUTTON_1_GPIO_Port;
        0x08002490:    4806        .H      LDR      r0,[pc,#24] ; [0x80024ac] = 0x40010800
        0x08002492:    6008        .`      STR      r0,[r1,#0]
;;;15     	bt[0].button_pin = BUTTON_1_Pin;
        0x08002494:    4806        .H      LDR      r0,[pc,#24] ; [0x80024b0] = 0x4010001
        0x08002496:    6048        H`      STR      r0,[r1,#4]
;;;16     	bt[0].buttons = bt[0].buttons_mask = LL_GPIO_IsInputPinSet(bt[0].GPIOx,BUTTON_1_Pin); //bt[0].GPIOx->IDR & bt[0].button_pin;
        0x08002498:    6808        .h      LDR      r0,[r1,#0]
        0x0800249a:    4905        .I      LDR      r1,[pc,#20] ; [0x80024b0] = 0x4010001
        0x0800249c:    f7fef8db    ....    BL       LL_GPIO_IsInputPinSet ; 0x8000656
        0x080024a0:    4901        .I      LDR      r1,[pc,#4] ; [0x80024a8] = 0x20000a14
        0x080024a2:    6188        .a      STR      r0,[r1,#0x18]
        0x080024a4:    60c8        .`      STR      r0,[r1,#0xc]
;;;17     	return;
;;;18     	bt[1] = bt[0];
;;;19     	bt[1].clk_mode = 10;
;;;20     	bt[1].GPIOx = BUTTON_2_GPIO_Port;
;;;21     	bt[1].button_pin = BUTTON_2_Pin;
;;;22     	bt[1].buttons = bt[1].buttons_mask = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;23     
;;;24     	if(device_ready == 1){
;;;25     //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);		
;;;26     		reqest_sample_i2c_dma();
;;;27     //		while(ubTransferComplete == 0){
;;;28     //		}
;;;29     	}
;;;30     	bt[2].clk_mode = 10;
;;;31     	bt[2].button_pin = 0x02; // button_c code
;;;32     	bt[2].buttons = bt[2].buttons_mask = dma_data[5]&bt[2].button_pin; // = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;33     	
;;;34     	bt[3].clk_mode = 10;
;;;35     	bt[3].button_pin = 0x01; // button_c code
;;;36     	bt[3].buttons = bt[3].buttons_mask = dma_data[5]&bt[3].button_pin; // = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;37     
;;;38     }
        0x080024a6:    bd10        ..      POP      {r4,pc}
    $d
        0x080024a8:    20000a14    ...     DCD    536873492
        0x080024ac:    40010800    ...@    DCD    1073809408
        0x080024b0:    04010001    ....    DCD    67174401
    $t
    i.init_screen
    init_screen
;;; .\..\Src\screen.c
;;;10     void init_screen(I2C_TypeDef *hi2c){
        0x080024b4:    b510        ..      PUSH     {r4,lr}
        0x080024b6:    4604        .F      MOV      r4,r0
;;;11     	SSD1306_Init(hi2c);
        0x080024b8:    4620         F      MOV      r0,r4
        0x080024ba:    f7fff8f5    ....    BL       SSD1306_Init ; 0x80016a8
;;;12     }
        0x080024be:    bd10        ..      POP      {r4,pc}
    i.main
    main
;;; .\../Src/main.c
;;;340    	rs = 11;
        0x080024c0:    200b        .       MOVS     r0,#0xb
        0x080024c2:    4942        BI      LDR      r1,[pc,#264] ; [0x80025cc] = 0x2000016c
        0x080024c4:    6008        .`      STR      r0,[r1,#0]
;;;341    //	z_axis.end_pos = 50;
;;;342    //	z_axis.Q824set = Thread_Info[Menu_Step].Q824;
;;;343    
;;;344    //	state.main_feed_direction = 1;
;;;345    
;;;346    	//	do_fsm_move_start(&state);
;;;347    	//	do_fsm_wait_tacho(&state);
;;;348    	
;;;349    //	TIM4_IRQHandler();
;;;350      /* USER CODE END 1 */
;;;351    
;;;352      /* MCU Configuration----------------------------------------------------------*/
;;;353    
;;;354      /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
;;;355      LL_Init();
        0x080024c6:    f7fef975    ..u.    BL       LL_Init ; 0x80007b4
;;;356    
;;;357      /* USER CODE BEGIN Init */
;;;358      /* USER CODE END Init */
;;;359    
;;;360      /* Configure the system clock */
;;;361      SystemClock_Config();
        0x080024ca:    f7fffa63    ..c.    BL       SystemClock_Config ; 0x8001994
;;;362    
;;;363      /* USER CODE BEGIN SysInit */
;;;364    	LL_SYSTICK_EnableIT();
        0x080024ce:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;291      SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
        0x080024d0:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x080024d4:    6900        .i      LDR      r0,[r0,#0x10]
        0x080024d6:    f0400002    @...    ORR      r0,r0,#2
        0x080024da:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x080024de:    6108        .a      STR      r0,[r1,#0x10]
;;;292    }
        0x080024e0:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;368      MX_GPIO_Init();
        0x080024e2:    f7fefc33    ..3.    BL       MX_GPIO_Init ; 0x8000d4c
;;;369      MX_DMA_Init();
        0x080024e6:    f7fefc11    ....    BL       MX_DMA_Init ; 0x8000d0c
;;;370      MX_I2C2_Init();
        0x080024ea:    f7fefca5    ....    BL       MX_I2C2_Init ; 0x8000e38
;;;371      MX_TIM1_Init();
        0x080024ee:    f7fefd67    ..g.    BL       MX_TIM1_Init ; 0x8000fc0
;;;372      MX_TIM2_Init();
        0x080024f2:    f7fefdc3    ....    BL       MX_TIM2_Init ; 0x800107c
;;;373      MX_TIM3_Init();
        0x080024f6:    f7fefe11    ....    BL       MX_TIM3_Init ; 0x800111c
;;;374      MX_TIM4_Init();
        0x080024fa:    f7fefe7d    ..}.    BL       MX_TIM4_Init ; 0x80011f8
;;;375      /* USER CODE BEGIN 2 */
;;;376    
;;;377    // инициализация дисплея
;;;378    #ifndef _SIMU
;;;379    	Activate_I2C_Master();
        0x080024fe:    f7fdfeb1    ....    BL       Activate_I2C_Master ; 0x8000264
;;;380    	init_screen(I2C2);
        0x08002502:    4833        3H      LDR      r0,[pc,#204] ; [0x80025d0] = 0x40005800
        0x08002504:    f7ffffd6    ....    BL       init_screen ; 0x80024b4
;;;381    //	update_screen();
;;;382    //	i2c_device_init(I2C2);
;;;383    #endif
;;;384    	LL_mDelay(250);
        0x08002508:    20fa        .       MOVS     r0,#0xfa
        0x0800250a:    f7fefbea    ....    BL       LL_mDelay ; 0x8000ce2
;;;385    	init_buttons();
        0x0800250e:    f7ffffbb    ....    BL       init_buttons ; 0x8002488
;;;386      /* USER CODE END 2 */
;;;387    
;;;388      /* Infinite loop */
;;;389      /* USER CODE BEGIN WHILE */
;;;390    
;;;391    
;;;392    	TIM3->CCER = TIM_CCER_CC1E; /* Enable the Compare output channel 1 */
        0x08002512:    2001        .       MOVS     r0,#1
        0x08002514:    492f        /I      LDR      r1,[pc,#188] ; [0x80025d4] = 0x40000420
        0x08002516:    6008        .`      STR      r0,[r1,#0]
;;;393    //  LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1);
;;;394    
;;;395      LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
        0x08002518:    0200        ..      LSLS     r0,r0,#8
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1490     SET_BIT(TIMx->CCER, Channels);
        0x0800251a:    492f        /I      LDR      r1,[pc,#188] ; [0x80025d8] = 0x40000800
        0x0800251c:    6a09        .j      LDR      r1,[r1,#0x20]
        0x0800251e:    4301        .C      ORRS     r1,r1,r0
        0x08002520:    4a2d        -J      LDR      r2,[pc,#180] ; [0x80025d8] = 0x40000800
        0x08002522:    6211        .b      STR      r1,[r2,#0x20]
;;;1491   }
        0x08002524:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;396      LL_TIM_EnableCounter(TIM4); 												//Enable timer 4
        0x08002526:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1027     SET_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x08002528:    4610        .F      MOV      r0,r2
        0x0800252a:    6800        .h      LDR      r0,[r0,#0]
        0x0800252c:    f0400001    @...    ORR      r0,r0,#1
        0x08002530:    4611        .F      MOV      r1,r2
        0x08002532:    6008        .`      STR      r0,[r1,#0]
;;;1028   }
        0x08002534:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;397      LL_TIM_EnableIT_CC3(TIM4);													// enable interrupts for TACHO events from encoder
        0x08002536:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3299     SET_BIT(TIMx->DIER, TIM_DIER_CC3IE);
        0x08002538:    4608        .F      MOV      r0,r1
        0x0800253a:    68c0        .h      LDR      r0,[r0,#0xc]
        0x0800253c:    f0400008    @...    ORR      r0,r0,#8
        0x08002540:    60c8        .`      STR      r0,[r1,#0xc]
;;;3300   }
        0x08002542:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;399    	TIM4->SR = 0; 																			// reset interrup flags
        0x08002544:    2000        .       MOVS     r0,#0
        0x08002546:    4924        $I      LDR      r1,[pc,#144] ; [0x80025d8] = 0x40000800
        0x08002548:    3110        .1      ADDS     r1,r1,#0x10
        0x0800254a:    6008        .`      STR      r0,[r1,#0]
;;;400    
;;;401    	LL_TIM_EnableIT_UPDATE(TIM1);
        0x0800254c:    4823        #H      LDR      r0,[pc,#140] ; [0x80025dc] = 0x40012c00
        0x0800254e:    f7fefa10    ....    BL       LL_TIM_EnableIT_UPDATE ; 0x8000972
;;;402    	LL_TIM_EnableIT_UPDATE(TIM2);
        0x08002552:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08002556:    f7fefa0c    ....    BL       LL_TIM_EnableIT_UPDATE ; 0x8000972
;;;403    	
;;;404    //	do_fsm_move_start(&state);
;;;405    
;;;406    	
;;;407      /* Enable counter */
;;;408    //  LL_TIM_EnableCounter(TIM2);
;;;409      /* Force update generation */
;;;410    //  LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;411    
;;;412    // init buttons
;;;413    	do_fsm_menu(&state);
        0x0800255a:    4821        !H      LDR      r0,[pc,#132] ; [0x80025e0] = 0x20000134
        0x0800255c:    f7fffce0    ....    BL       do_fsm_menu ; 0x8001f20
;;;414    	LED_GPIO_Port->BSRR = LED_Pin; // led off
        0x08002560:    4820         H      LDR      r0,[pc,#128] ; [0x80025e4] = 0x4200020
        0x08002562:    4921        !I      LDR      r1,[pc,#132] ; [0x80025e8] = 0x40011000
        0x08002564:    6108        .a      STR      r0,[r1,#0x10]
;;;415    	while (1) {
        0x08002566:    e02f        /.      B        0x80025c8 ; main + 264
;;;416      /* USER CODE END WHILE */
;;;417    
;;;418      /* USER CODE BEGIN 3 */
;;;419    #ifndef _SIMU		
;;;420    //		reqest_sample_i2c_dma(); // init reqest to joystick by DMA, when process_button complete i2c done its job
;;;421    #endif		
;;;422    //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);
;;;423    		process_button();
        0x08002568:    f000f846    ..F.    BL       process_button ; 0x80025f8
;;;424    //		process_joystick();
;;;425    //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);
;;;426    
;;;427    
;;;428    //		uint8_t level = Thread_Info[Menu_Step].level;
;;;429    
;;;430    //		if(auto_mode == true) {
;;;431    //			if ( auto_mode_delay == 0 ) {
;;;432    //				buttons_flag_set = single_click_Msk; //
;;;433    //			}
;;;434    //		}
;;;435    
;;;436    		if(buttons_flag_set) {
        0x0800256c:    481f        .H      LDR      r0,[pc,#124] ; [0x80025ec] = 0x20004000
        0x0800256e:    6800        .h      LDR      r0,[r0,#0]
        0x08002570:    b128        (.      CBZ      r0,0x800257e ; main + 190
;;;437    			do_fsm_menu(&state);
        0x08002572:    481b        .H      LDR      r0,[pc,#108] ; [0x80025e0] = 0x20000134
        0x08002574:    f7fffcd4    ....    BL       do_fsm_menu ; 0x8001f20
;;;438    			buttons_flag_set = 0; // reset button flags
        0x08002578:    2000        .       MOVS     r0,#0
        0x0800257a:    491c        .I      LDR      r1,[pc,#112] ; [0x80025ec] = 0x20004000
        0x0800257c:    6008        .`      STR      r0,[r1,#0]
;;;439    		}
;;;440    
;;;441    		if(z_axis.ramp_step != rs) {
        0x0800257e:    481c        .H      LDR      r0,[pc,#112] ; [0x80025f0] = 0x20000a38
        0x08002580:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002584:    4911        .I      LDR      r1,[pc,#68] ; [0x80025cc] = 0x2000016c
        0x08002586:    6809        .h      LDR      r1,[r1,#0]
        0x08002588:    4288        .B      CMP      r0,r1
        0x0800258a:    d007        ..      BEQ      0x800259c ; main + 220
;;;442    			rs = z_axis.ramp_step;
        0x0800258c:    4818        .H      LDR      r0,[pc,#96] ; [0x80025f0] = 0x20000a38
        0x0800258e:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002592:    490e        .I      LDR      r1,[pc,#56] ; [0x80025cc] = 0x2000016c
        0x08002594:    6008        .`      STR      r0,[r1,#0]
;;;443    			menu_changed = 1;
        0x08002596:    2001        .       MOVS     r0,#1
        0x08002598:    4916        .I      LDR      r1,[pc,#88] ; [0x80025f4] = 0x20000160
        0x0800259a:    6008        .`      STR      r0,[r1,#0]
;;;444    		}
;;;445    
;;;446    		if(z_axis.current_pos != rs) {
        0x0800259c:    4814        .H      LDR      r0,[pc,#80] ; [0x80025f0] = 0x20000a38
        0x0800259e:    6800        .h      LDR      r0,[r0,#0]
        0x080025a0:    490a        .I      LDR      r1,[pc,#40] ; [0x80025cc] = 0x2000016c
        0x080025a2:    6809        .h      LDR      r1,[r1,#0]
        0x080025a4:    4288        .B      CMP      r0,r1
        0x080025a6:    d006        ..      BEQ      0x80025b6 ; main + 246
;;;447    			rs = z_axis.current_pos;
        0x080025a8:    4811        .H      LDR      r0,[pc,#68] ; [0x80025f0] = 0x20000a38
        0x080025aa:    6800        .h      LDR      r0,[r0,#0]
        0x080025ac:    4907        .I      LDR      r1,[pc,#28] ; [0x80025cc] = 0x2000016c
        0x080025ae:    6008        .`      STR      r0,[r1,#0]
;;;448    			menu_changed = 1;
        0x080025b0:    2001        .       MOVS     r0,#1
        0x080025b2:    4910        .I      LDR      r1,[pc,#64] ; [0x80025f4] = 0x20000160
        0x080025b4:    6008        .`      STR      r0,[r1,#0]
;;;449    		}
;;;450    
;;;451    // update display info
;;;452    		if(menu_changed == 1){ // haltodo && hi2c2.hdmatx->State == HAL_DMA_STATE_READY) {
        0x080025b6:    480f        .H      LDR      r0,[pc,#60] ; [0x80025f4] = 0x20000160
        0x080025b8:    6800        .h      LDR      r0,[r0,#0]
        0x080025ba:    2801        .(      CMP      r0,#1
        0x080025bc:    d104        ..      BNE      0x80025c8 ; main + 264
;;;453    			menu_changed = 0;
        0x080025be:    2000        .       MOVS     r0,#0
        0x080025c0:    490c        .I      LDR      r1,[pc,#48] ; [0x80025f4] = 0x20000160
        0x080025c2:    6008        .`      STR      r0,[r1,#0]
;;;454    			update_screen();
        0x080025c4:    f000f958    ..X.    BL       update_screen ; 0x8002878
        0x080025c8:    e7ce        ..      B        0x8002568 ; main + 168
    $d
        0x080025ca:    0000        ..      DCW    0
        0x080025cc:    2000016c    l..     DCD    536871276
        0x080025d0:    40005800    .X.@    DCD    1073764352
        0x080025d4:    40000420     ..@    DCD    1073742880
        0x080025d8:    40000800    ...@    DCD    1073743872
        0x080025dc:    40012c00    .,.@    DCD    1073818624
        0x080025e0:    20000134    4..     DCD    536871220
        0x080025e4:    04200020     . .    DCD    69206048
        0x080025e8:    40011000    ...@    DCD    1073811456
        0x080025ec:    20004000    .@.     DCD    536887296
        0x080025f0:    20000a38    8..     DCD    536873528
        0x080025f4:    20000160    `..     DCD    536871264
    $t
    i.process_button
    process_button
;;; .\..\Src\buttons.c
;;;57     {
        0x080025f8:    b570        p.      PUSH     {r4-r6,lr}
;;;58     	for(int a =0; a<BT_TOTAL;a++){
        0x080025fa:    2400        .$      MOVS     r4,#0
        0x080025fc:    e114        ..      B        0x8002828 ; process_button + 560
;;;59     	/*
;;;60     	click Nondeterministic finite automaton(NFA):
;;;61     	10. ждем сигнала с кнопки
;;;62     	20. кнопка нажата, считаем тики. если тиков > 1000 это лонг пресс, идем в 30
;;;63     	30. сигнал long_press_start, идем в 40
;;;64     	40. ждем отпуска кнопки, далее в 50
;;;65     	50. кнопку отпустили, если тиков меньше 200 идем в 70, иначе в 60
;;;66     	60. если тиков < 1000 генерим сигнал CLICK, если тиков больше генерим сигнал long_press_end, идем в 10
;;;67     	70. тиков меньше 200, это может быть дабл-клик, ждем еще 100, если ничего идем в 60, если клик идем в 80
;;;68     	80. ждем отпуска кнопки, далее в 90
;;;69     	90. кнопку отпустили, генерим DOUBLE_CLICK, идем в 10
;;;70     	*/
;;;71      
;;;72     //	#if defined ( _SIMU )
;;;73     //		uint32_t tmp_buttons = bt[a].GPIOx->IDR & bt[a].button_pin;
;;;74     //	#else
;;;75     		uint32_t tmp_buttons;
;;;76     		if(bt[a].GPIOx != 0)
        0x080025fe:    488d        .H      LDR      r0,[pc,#564] ; [0x8002834] = 0x20000a14
        0x08002600:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002604:    6800        .h      LDR      r0,[r0,#0]
        0x08002606:    b158        X.      CBZ      r0,0x8002620 ; process_button + 40
;;;77     			tmp_buttons = LL_GPIO_IsInputPinSet(bt[a].GPIOx,bt[a].button_pin);
        0x08002608:    4a8a        .J      LDR      r2,[pc,#552] ; [0x8002834] = 0x20000a14
        0x0800260a:    eb021244    ..D.    ADD      r2,r2,r4,LSL #5
        0x0800260e:    6851        Qh      LDR      r1,[r2,#4]
        0x08002610:    4a88        .J      LDR      r2,[pc,#544] ; [0x8002834] = 0x20000a14
        0x08002612:    eb021244    ..D.    ADD      r2,r2,r4,LSL #5
        0x08002616:    6810        .h      LDR      r0,[r2,#0]
        0x08002618:    f7fef81d    ....    BL       LL_GPIO_IsInputPinSet ; 0x8000656
        0x0800261c:    4605        .F      MOV      r5,r0
        0x0800261e:    e007        ..      B        0x8002630 ; process_button + 56
;;;78     //			tmp_buttons = bt[a].GPIOx->IDR & bt[a].button_pin; //BUTTON_1_GPIO_Port->IDR & bt[a].button_pin;
;;;79     		else{
;;;80     			
;;;81     //			if(ubTransferComplete == 0)
;;;82     //				continue;
;;;83     			//	dma_delay = 0;
;;;84     //	while(hi2c2->hdmarx->State != HAL_DMA_STATE_READY){
;;;85     //		dma_delay++;
;;;86     //		HAL_Delay(1);
;;;87     //	}
;;;88     //	dma_delay2 = dma_delay;
;;;89     
;;;90     			tmp_buttons = dma_data[5] & bt[a].button_pin;
        0x08002620:    4885        .H      LDR      r0,[pc,#532] ; [0x8002838] = 0x20000021
        0x08002622:    7940        @y      LDRB     r0,[r0,#5]
        0x08002624:    4983        .I      LDR      r1,[pc,#524] ; [0x8002834] = 0x20000a14
        0x08002626:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x0800262a:    6849        Ih      LDR      r1,[r1,#4]
        0x0800262c:    ea000501    ....    AND      r5,r0,r1
;;;91     		}
;;;92     //	#endif
;;;93     
;;;94     //		if(z_axis.current_pos < 20)
;;;95     //			tmp_buttons = 0;
;;;96     		
;;;97     		if( tmp_buttons != bt[a].buttons ) { // start debounce
        0x08002630:    4880        .H      LDR      r0,[pc,#512] ; [0x8002834] = 0x20000a14
        0x08002632:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002636:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002638:    42a8        .B      CMP      r0,r5
        0x0800263a:    d009        ..      BEQ      0x8002650 ; process_button + 88
;;;98     			bt[a].buttons = tmp_buttons;
        0x0800263c:    487d        }H      LDR      r0,[pc,#500] ; [0x8002834] = 0x20000a14
        0x0800263e:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002642:    60c5        .`      STR      r5,[r0,#0xc]
;;;99     			// reset debounce counter and start count every one ms
;;;100    			bt[a].buttons_mstick = 1;
        0x08002644:    2001        .       MOVS     r0,#1
        0x08002646:    497b        {I      LDR      r1,[pc,#492] ; [0x8002834] = 0x20000a14
        0x08002648:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x0800264c:    6108        .a      STR      r0,[r1,#0x10]
        0x0800264e:    bd70        p.      POP      {r4-r6,pc}
;;;101    			return;
;;;102    		}
;;;103    
;;;104    		if( bt[a].buttons_mstick > DEBOUNCE_MS ) {
        0x08002650:    4878        xH      LDR      r0,[pc,#480] ; [0x8002834] = 0x20000a14
        0x08002652:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002656:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002658:    2814        .(      CMP      r0,#0x14
        0x0800265a:    d96f        o.      BLS      0x800273c ; process_button + 324
;;;105    			switch(bt[a].clk_mode) {
        0x0800265c:    4875        uH      LDR      r0,[pc,#468] ; [0x8002834] = 0x20000a14
        0x0800265e:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002662:    69c0        .i      LDR      r0,[r0,#0x1c]
        0x08002664:    2832        2(      CMP      r0,#0x32
        0x08002666:    d061        a.      BEQ      0x800272c ; process_button + 308
        0x08002668:    dc08        ..      BGT      0x800267c ; process_button + 132
        0x0800266a:    280a        .(      CMP      r0,#0xa
        0x0800266c:    d00f        ..      BEQ      0x800268e ; process_button + 150
        0x0800266e:    2814        .(      CMP      r0,#0x14
        0x08002670:    d019        ..      BEQ      0x80026a6 ; process_button + 174
        0x08002672:    281e        .(      CMP      r0,#0x1e
        0x08002674:    d038        8.      BEQ      0x80026e8 ; process_button + 240
        0x08002676:    2828        ((      CMP      r0,#0x28
        0x08002678:    d114        ..      BNE      0x80026a4 ; process_button + 172
        0x0800267a:    e042        B.      B        0x8002702 ; process_button + 266
        0x0800267c:    283c        <(      CMP      r0,#0x3c
        0x0800267e:    d064        d.      BEQ      0x800274a ; process_button + 338
        0x08002680:    2846        F(      CMP      r0,#0x46
        0x08002682:    d071        q.      BEQ      0x8002768 ; process_button + 368
        0x08002684:    2850        P(      CMP      r0,#0x50
        0x08002686:    d070        p.      BEQ      0x800276a ; process_button + 370
        0x08002688:    285a        Z(      CMP      r0,#0x5a
        0x0800268a:    d1f5        ..      BNE      0x8002678 ; process_button + 128
        0x0800268c:    e0b8        ..      B        0x8002800 ; process_button + 520
;;;106    			case 10: {
;;;107    				if ( tmp_buttons & bt[a].button_pin ) {   // released
        0x0800268e:    4869        iH      LDR      r0,[pc,#420] ; [0x8002834] = 0x20000a14
        0x08002690:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002694:    6840        @h      LDR      r0,[r0,#4]
        0x08002696:    4028        (@      ANDS     r0,r0,r5
        0x08002698:    b920         .      CBNZ     r0,0x80026a4 ; process_button + 172
;;;108    				} else { // pressed
;;;109    //					buttons_mstick = 1;
;;;110    					bt[a].clk_mode = 20;
        0x0800269a:    2014        .       MOVS     r0,#0x14
        0x0800269c:    4965        eI      LDR      r1,[pc,#404] ; [0x8002834] = 0x20000a14
        0x0800269e:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x080026a2:    61c8        .a      STR      r0,[r1,#0x1c]
;;;111    				}
;;;112    				break;
        0x080026a4:    e0be        ..      B        0x8002824 ; process_button + 556
;;;113    			}
;;;114    			case 20: {
;;;115    				if ( tmp_buttons & bt[a].button_pin ) { // released
        0x080026a6:    4863        cH      LDR      r0,[pc,#396] ; [0x8002834] = 0x20000a14
        0x080026a8:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x080026ac:    6840        @h      LDR      r0,[r0,#4]
        0x080026ae:    4028        (@      ANDS     r0,r0,r5
        0x080026b0:    b128        (.      CBZ      r0,0x80026be ; process_button + 198
;;;116    					bt[a].clk_mode = 50;
        0x080026b2:    2032        2       MOVS     r0,#0x32
        0x080026b4:    495f        _I      LDR      r1,[pc,#380] ; [0x8002834] = 0x20000a14
        0x080026b6:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x080026ba:    61c8        .a      STR      r0,[r1,#0x1c]
        0x080026bc:    e007        ..      B        0x80026ce ; process_button + 214
;;;117    				} else {
;;;118    					bt[a].downTime = bt[a].buttons_mstick;
        0x080026be:    485d        ]H      LDR      r0,[pc,#372] ; [0x8002834] = 0x20000a14
        0x080026c0:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x080026c4:    6900        .i      LDR      r0,[r0,#0x10]
        0x080026c6:    495b        [I      LDR      r1,[pc,#364] ; [0x8002834] = 0x20000a14
        0x080026c8:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x080026cc:    6088        .`      STR      r0,[r1,#8]
;;;119    				}
;;;120    				if (bt[a].downTime > HOLDTIME_MS ) { // long press detected
        0x080026ce:    4859        YH      LDR      r0,[pc,#356] ; [0x8002834] = 0x20000a14
        0x080026d0:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x080026d4:    6880        .h      LDR      r0,[r0,#8]
        0x080026d6:    f5b07ffa    ....    CMP      r0,#0x1f4
        0x080026da:    d904        ..      BLS      0x80026e6 ; process_button + 238
;;;121    					bt[a].clk_mode = 30;
        0x080026dc:    201e        .       MOVS     r0,#0x1e
        0x080026de:    4955        UI      LDR      r1,[pc,#340] ; [0x8002834] = 0x20000a14
        0x080026e0:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x080026e4:    61c8        .a      STR      r0,[r1,#0x1c]
;;;122    				}
;;;123    				break;
        0x080026e6:    e09d        ..      B        0x8002824 ; process_button + 556
;;;124    			}
;;;125    			case 30: { // long_press_start event
;;;126    				buttons_flag_setbb[(a<<2)+long_press_start_Pos]  = 1; //long_press_start = 1;
        0x080026e8:    2001        .       MOVS     r0,#1
        0x080026ea:    2100        .!      MOVS     r1,#0
        0x080026ec:    eb010184    ....    ADD      r1,r1,r4,LSL #2
        0x080026f0:    4a52        RJ      LDR      r2,[pc,#328] ; [0x800283c] = 0x22080000
        0x080026f2:    f8420021    B.!.    STR      r0,[r2,r1,LSL #2]
;;;127    				bt[a].clk_mode = 40;
        0x080026f6:    2028        (       MOVS     r0,#0x28
        0x080026f8:    494e        NI      LDR      r1,[pc,#312] ; [0x8002834] = 0x20000a14
        0x080026fa:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x080026fe:    61c8        .a      STR      r0,[r1,#0x1c]
;;;128    				break;
        0x08002700:    e090        ..      B        0x8002824 ; process_button + 556
;;;129    			}
;;;130    			case 40: {
;;;131    				if ( tmp_buttons & bt[a].button_pin ) { //released
        0x08002702:    484c        LH      LDR      r0,[pc,#304] ; [0x8002834] = 0x20000a14
        0x08002704:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002708:    6840        @h      LDR      r0,[r0,#4]
        0x0800270a:    4028        (@      ANDS     r0,r0,r5
        0x0800270c:    b128        (.      CBZ      r0,0x800271a ; process_button + 290
;;;132    					bt[a].clk_mode = 50;
        0x0800270e:    2032        2       MOVS     r0,#0x32
        0x08002710:    4948        HI      LDR      r1,[pc,#288] ; [0x8002834] = 0x20000a14
        0x08002712:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002716:    61c8        .a      STR      r0,[r1,#0x1c]
        0x08002718:    e007        ..      B        0x800272a ; process_button + 306
;;;133    				} else {
;;;134    					bt[a].downTime = bt[a].buttons_mstick;
        0x0800271a:    4846        FH      LDR      r0,[pc,#280] ; [0x8002834] = 0x20000a14
        0x0800271c:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002720:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002722:    4944        DI      LDR      r1,[pc,#272] ; [0x8002834] = 0x20000a14
        0x08002724:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002728:    6088        .`      STR      r0,[r1,#8]
;;;135    				}
;;;136    				break;
        0x0800272a:    e07b        {.      B        0x8002824 ; process_button + 556
;;;137    			}
;;;138    			case 50: {
;;;139    				bt[a].clk_mode = bt[a].downTime < CLICKTIME_MS ? 70 : 60;
        0x0800272c:    4841        AH      LDR      r0,[pc,#260] ; [0x8002834] = 0x20000a14
        0x0800272e:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002732:    6880        .h      LDR      r0,[r0,#8]
        0x08002734:    28fa        .(      CMP      r0,#0xfa
        0x08002736:    d202        ..      BCS      0x800273e ; process_button + 326
        0x08002738:    2046        F       MOVS     r0,#0x46
        0x0800273a:    e001        ..      B        0x8002740 ; process_button + 328
        0x0800273c:    e073        s.      B        0x8002826 ; process_button + 558
        0x0800273e:    203c        <       MOVS     r0,#0x3c
        0x08002740:    493c        <I      LDR      r1,[pc,#240] ; [0x8002834] = 0x20000a14
        0x08002742:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002746:    61c8        .a      STR      r0,[r1,#0x1c]
;;;140    				break;
        0x08002748:    e06c        l.      B        0x8002824 ; process_button + 556
;;;141    			}
;;;142    			case 60: {//60 if tick count < 1000 generate CLICK event, else generate long_press_end event, go to 10 state
;;;143    				if(bt[a].downTime < HOLDTIME_MS) { //single CLICK event
        0x0800274a:    483a        :H      LDR      r0,[pc,#232] ; [0x8002834] = 0x20000a14
        0x0800274c:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002750:    6880        .h      LDR      r0,[r0,#8]
        0x08002752:    f5b07ffa    ....    CMP      r0,#0x1f4
        0x08002756:    d209        ..      BCS      0x800276c ; process_button + 372
;;;144    					buttons_flag_setbb[(a<<2)+single_click_Pos]  = 1; //single_click = 1;
        0x08002758:    2001        .       MOVS     r0,#1
        0x0800275a:    2102        .!      MOVS     r1,#2
        0x0800275c:    eb010184    ....    ADD      r1,r1,r4,LSL #2
        0x08002760:    4a36        6J      LDR      r2,[pc,#216] ; [0x800283c] = 0x22080000
        0x08002762:    f8420021    B.!.    STR      r0,[r2,r1,LSL #2]
        0x08002766:    e007        ..      B        0x8002778 ; process_button + 384
        0x08002768:    e015        ..      B        0x8002796 ; process_button + 414
        0x0800276a:    e034        4.      B        0x80027d6 ; process_button + 478
;;;145    				} else { //  long_press_end event
;;;146    					buttons_flag_setbb[(a<<2)+long_press_end_Pos]  = 1; //long_press_end = 1;
        0x0800276c:    2001        .       MOVS     r0,#1
        0x0800276e:    eb000184    ....    ADD      r1,r0,r4,LSL #2
        0x08002772:    4a32        2J      LDR      r2,[pc,#200] ; [0x800283c] = 0x22080000
        0x08002774:    f8420021    B.!.    STR      r0,[r2,r1,LSL #2]
;;;147    				}
;;;148    				bt[a].downTime = bt[a].buttons_mstick = 0;
        0x08002778:    2000        .       MOVS     r0,#0
        0x0800277a:    492e        .I      LDR      r1,[pc,#184] ; [0x8002834] = 0x20000a14
        0x0800277c:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002780:    6108        .a      STR      r0,[r1,#0x10]
        0x08002782:    492c        ,I      LDR      r1,[pc,#176] ; [0x8002834] = 0x20000a14
        0x08002784:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002788:    6088        .`      STR      r0,[r1,#8]
;;;149    				bt[a].clk_mode = 10;
        0x0800278a:    200a        .       MOVS     r0,#0xa
        0x0800278c:    4929        )I      LDR      r1,[pc,#164] ; [0x8002834] = 0x20000a14
        0x0800278e:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002792:    61c8        .a      STR      r0,[r1,#0x1c]
;;;150    				break;
        0x08002794:    e046        F.      B        0x8002824 ; process_button + 556
;;;151    			}
;;;152    			case 70: { //70. тиков меньше 200, это может быть дабл-клик, ждем нажатия еще 100, если ничего идем в 60, если клик идем в 80
;;;153    				if ( tmp_buttons & bt[a].button_pin ) {
        0x08002796:    4827        'H      LDR      r0,[pc,#156] ; [0x8002834] = 0x20000a14
        0x08002798:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x0800279c:    6840        @h      LDR      r0,[r0,#4]
        0x0800279e:    4028        (@      ANDS     r0,r0,r5
        0x080027a0:    b198        ..      CBZ      r0,0x80027ca ; process_button + 466
;;;154    					bt[a].downTime = bt[a].buttons_mstick;
        0x080027a2:    4824        $H      LDR      r0,[pc,#144] ; [0x8002834] = 0x20000a14
        0x080027a4:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x080027a8:    6900        .i      LDR      r0,[r0,#0x10]
        0x080027aa:    4922        "I      LDR      r1,[pc,#136] ; [0x8002834] = 0x20000a14
        0x080027ac:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x080027b0:    6088        .`      STR      r0,[r1,#8]
;;;155    					if( bt[a].downTime > DOUBLECLICK_GAP_MS ) {
        0x080027b2:    4820         H      LDR      r0,[pc,#128] ; [0x8002834] = 0x20000a14
        0x080027b4:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x080027b8:    6880        .h      LDR      r0,[r0,#8]
        0x080027ba:    2896        .(      CMP      r0,#0x96
        0x080027bc:    d90a        ..      BLS      0x80027d4 ; process_button + 476
;;;156    						bt[a].clk_mode = 60;
        0x080027be:    203c        <       MOVS     r0,#0x3c
        0x080027c0:    491c        .I      LDR      r1,[pc,#112] ; [0x8002834] = 0x20000a14
        0x080027c2:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x080027c6:    61c8        .a      STR      r0,[r1,#0x1c]
        0x080027c8:    e004        ..      B        0x80027d4 ; process_button + 476
;;;157    					}
;;;158    				} else {
;;;159    					bt[a].clk_mode = 80;
        0x080027ca:    2050        P       MOVS     r0,#0x50
        0x080027cc:    4919        .I      LDR      r1,[pc,#100] ; [0x8002834] = 0x20000a14
        0x080027ce:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x080027d2:    61c8        .a      STR      r0,[r1,#0x1c]
;;;160    				}
;;;161    				break;
        0x080027d4:    e026        &.      B        0x8002824 ; process_button + 556
;;;162    			}
;;;163    			case 80: {
;;;164    				if ( tmp_buttons & bt[a].button_pin ) { // released
        0x080027d6:    4817        .H      LDR      r0,[pc,#92] ; [0x8002834] = 0x20000a14
        0x080027d8:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x080027dc:    6840        @h      LDR      r0,[r0,#4]
        0x080027de:    4028        (@      ANDS     r0,r0,r5
        0x080027e0:    b128        (.      CBZ      r0,0x80027ee ; process_button + 502
;;;165    					bt[a].clk_mode = 90;
        0x080027e2:    205a        Z       MOVS     r0,#0x5a
        0x080027e4:    4913        .I      LDR      r1,[pc,#76] ; [0x8002834] = 0x20000a14
        0x080027e6:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x080027ea:    61c8        .a      STR      r0,[r1,#0x1c]
        0x080027ec:    e007        ..      B        0x80027fe ; process_button + 518
;;;166    				} else {
;;;167    					bt[a].downTime = bt[a].buttons_mstick;
        0x080027ee:    4811        .H      LDR      r0,[pc,#68] ; [0x8002834] = 0x20000a14
        0x080027f0:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x080027f4:    6900        .i      LDR      r0,[r0,#0x10]
        0x080027f6:    490f        .I      LDR      r1,[pc,#60] ; [0x8002834] = 0x20000a14
        0x080027f8:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x080027fc:    6088        .`      STR      r0,[r1,#8]
;;;168    				}
;;;169    				break;
        0x080027fe:    e011        ..      B        0x8002824 ; process_button + 556
;;;170    			}
;;;171    			case 90: { // сигнал DOUBLE_CLICK
;;;172    				buttons_flag_setbb[(a<<2)+double_click_Pos]  = 1; //double_click = 1;
        0x08002800:    2001        .       MOVS     r0,#1
        0x08002802:    2103        .!      MOVS     r1,#3
        0x08002804:    eb010184    ....    ADD      r1,r1,r4,LSL #2
        0x08002808:    4a0c        .J      LDR      r2,[pc,#48] ; [0x800283c] = 0x22080000
        0x0800280a:    f8420021    B.!.    STR      r0,[r2,r1,LSL #2]
;;;173    				bt[a].clk_mode = 10;
        0x0800280e:    200a        .       MOVS     r0,#0xa
        0x08002810:    4908        .I      LDR      r1,[pc,#32] ; [0x8002834] = 0x20000a14
        0x08002812:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002816:    61c8        .a      STR      r0,[r1,#0x1c]
;;;174    				bt[a].buttons_mstick = 0;
        0x08002818:    2000        .       MOVS     r0,#0
        0x0800281a:    4906        .I      LDR      r1,[pc,#24] ; [0x8002834] = 0x20000a14
        0x0800281c:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002820:    6108        .a      STR      r0,[r1,#0x10]
;;;175    				break;
        0x08002822:    bf00        ..      NOP      
        0x08002824:    bf00        ..      NOP      
        0x08002826:    1c64        d.      ADDS     r4,r4,#1
        0x08002828:    2c01        .,      CMP      r4,#1
        0x0800282a:    f6ffaee8    ....    BLT      0x80025fe ; process_button + 6
;;;176    			}
;;;177    			}
;;;178    		}
;;;179    	}
;;;180    //	ubTransferComplete = 0;
;;;181    }
        0x0800282e:    bf00        ..      NOP      
        0x08002830:    e70d        ..      B        0x800264e ; process_button + 86
    $d
        0x08002832:    0000        ..      DCW    0
        0x08002834:    20000a14    ...     DCD    536873492
        0x08002838:    20000021    !..     DCD    536870945
        0x0800283c:    22080000    ..."    DCD    570949632
    $t
    i.ssd1306_I2C_Init
    ssd1306_I2C_Init
;;; .\..\Src\ssd1306.c
;;;246    	uint32_t p = 250000;
        0x08002840:    4802        .H      LDR      r0,[pc,#8] ; [0x800284c] = 0x3d090
;;;247    	while(p>0)
        0x08002842:    e000        ..      B        0x8002846 ; ssd1306_I2C_Init + 6
        0x08002844:    1e40        @.      SUBS     r0,r0,#1
        0x08002846:    2800        .(      CMP      r0,#0
        0x08002848:    d1fc        ..      BNE      0x8002844 ; ssd1306_I2C_Init + 4
;;;248    		p--;
;;;249    	//HAL_I2C_DeInit(hi2c_screen);
;;;250    	//p = 250000;
;;;251    	//while(p>0)
;;;252    	//	p--;
;;;253    	//MX_I2C1_Init();
;;;254    }
        0x0800284a:    4770        pG      BX       lr
    $d
        0x0800284c:    0003d090    ....    DCD    250000
    $t
    i.ssd1306_I2C_Write
    ssd1306_I2C_Write
;;;255    /*
;;;256    void ssd1306_I2C_WriteMulti(uint8_t address, uint8_t reg, uint8_t* data, uint16_t count) {
;;;257    	uint8_t dt[count + 1];
;;;258    	dt[0] = reg;
;;;259    	uint8_t i;
;;;260    	for(i = 1; i <= count; i++)
;;;261    		dt[i] = data[i-1];
;;;262    //	Handle_I2C_Master(hi2c_screen, address, dt, count, 10);
;;;263    	// haltodo HAL_I2C_Master_Transmit(hi2c_screen, address, dt, count, 10);
;;;264    }
;;;265    
;;;266    
;;;267    void ssd1306_I2C_WriteMulti_DMA(uint8_t address, uint8_t reg, uint8_t* data, uint16_t count) {	
;;;268    	//haltodo HAL_I2C_Master_Transmit(hi2c_screen, address, &reg, 1, 100);
;;;269    	//haltodo HAL_I2C_Master_Transmit_DMA(hi2c_screen, address, data, count);
;;;270    }
;;;271    */
;;;272    
;;;273    void ssd1306_I2C_Write(uint8_t address, uint8_t reg, uint8_t data) {
        0x08002850:    b57c        |.      PUSH     {r2-r6,lr}
        0x08002852:    4604        .F      MOV      r4,r0
        0x08002854:    460e        .F      MOV      r6,r1
        0x08002856:    4615        .F      MOV      r5,r2
;;;274    	uint8_t dt[2] = {reg, data};
        0x08002858:    f88d6004    ...`    STRB     r6,[sp,#4]
        0x0800285c:    f88d5005    ...P    STRB     r5,[sp,#5]
;;;275    //	dt[0] = reg;
;;;276    //	dt[1] = data;
;;;277    	Handle_I2C_MasterDMA_IT(hi2c_screen, address, dt, 2, 10);
        0x08002860:    200a        .       MOVS     r0,#0xa
        0x08002862:    2302        .#      MOVS     r3,#2
        0x08002864:    aa01        ..      ADD      r2,sp,#4
        0x08002866:    4621        !F      MOV      r1,r4
        0x08002868:    9000        ..      STR      r0,[sp,#0]
        0x0800286a:    4802        .H      LDR      r0,[pc,#8] ; [0x8002874] = 0x20000004
        0x0800286c:    6800        .h      LDR      r0,[r0,#0]
        0x0800286e:    f7fdfd2f    ../.    BL       Handle_I2C_MasterDMA_IT ; 0x80002d0
;;;278    //	HAL_I2C_Master_Transmit(hi2c_screen, address, dt, 2, 10);
;;;279    }
        0x08002872:    bd7c        |.      POP      {r2-r6,pc}
    $d
        0x08002874:    20000004    ...     DCD    536870916
    $t
    i.update_screen
    update_screen
;;; .\..\Src\screen.c
;;;28     void update_screen(void){
        0x08002878:    b53e        >.      PUSH     {r1-r5,lr}
;;;29     	if(ubTransferComplete == 0) {
        0x0800287a:    484a        JH      LDR      r0,[pc,#296] ; [0x80029a4] = 0x20000027
        0x0800287c:    7800        .x      LDRB     r0,[r0,#0]
        0x0800287e:    b900        ..      CBNZ     r0,0x8002882 ; update_screen + 10
        0x08002880:    bd3e        >.      POP      {r1-r5,pc}
;;;30     		return;
;;;31     	}
;;;32     	SSD1306_Fill(SSD1306_COLOR_BLACK);
        0x08002882:    2000        .       MOVS     r0,#0
        0x08002884:    f7fefefa    ....    BL       SSD1306_Fill ; 0x800167c
;;;33     // first line
;;;34     	SSD1306_GotoXY(0, 16*0);
        0x08002888:    2100        .!      MOVS     r1,#0
        0x0800288a:    4608        .F      MOV      r0,r1
        0x0800288c:    f7feff06    ....    BL       SSD1306_GotoXY ; 0x800169c
;;;35     	feed_direction == feed_direction_left ? SSD1306_Putc2big(left_arrow, &consolas_18ptFontInfo) : SSD1306_Putc2big(right_arrow, &consolas_18ptFontInfo);
        0x08002890:    4845        EH      LDR      r0,[pc,#276] ; [0x80029a8] = 0x2000015d
        0x08002892:    7800        .x      LDRB     r0,[r0,#0]
        0x08002894:    b920         .      CBNZ     r0,0x80028a0 ; update_screen + 40
        0x08002896:    4945        EI      LDR      r1,[pc,#276] ; [0x80029ac] = 0x8003a3c
        0x08002898:    2001        .       MOVS     r0,#1
        0x0800289a:    f7feffad    ....    BL       SSD1306_Putc2big ; 0x80017f8
        0x0800289e:    e003        ..      B        0x80028a8 ; update_screen + 48
        0x080028a0:    4942        BI      LDR      r1,[pc,#264] ; [0x80029ac] = 0x8003a3c
        0x080028a2:    2002        .       MOVS     r0,#2
        0x080028a4:    f7feffa8    ....    BL       SSD1306_Putc2big ; 0x80017f8
;;;36     	SSD1306_Puts2(Thread_Info[Menu_Step].Unit, &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE);
        0x080028a8:    4941        AI      LDR      r1,[pc,#260] ; [0x80029b0] = 0x20000170
        0x080028aa:    4a42        BJ      LDR      r2,[pc,#264] ; [0x80029b4] = 0x20000590
        0x080028ac:    7812        .x      LDRB     r2,[r2,#0]
        0x080028ae:    eb011142    ..B.    ADD      r1,r1,r2,LSL #5
        0x080028b2:    f101000b    ....    ADD      r0,r1,#0xb
        0x080028b6:    2201        ."      MOVS     r2,#1
        0x080028b8:    493f        ?I      LDR      r1,[pc,#252] ; [0x80029b8] = 0x8003138
        0x080028ba:    f7fff82d    ..-.    BL       SSD1306_Puts2 ; 0x8001918
;;;37     	SSD1306_Puts2(Thread_Info[Menu_Step].infeed_inch, &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE); // infeed recommendation
        0x080028be:    493c        <I      LDR      r1,[pc,#240] ; [0x80029b0] = 0x20000170
        0x080028c0:    4a3c        <J      LDR      r2,[pc,#240] ; [0x80029b4] = 0x20000590
        0x080028c2:    7812        .x      LDRB     r2,[r2,#0]
        0x080028c4:    eb011142    ..B.    ADD      r1,r1,r2,LSL #5
        0x080028c8:    f1010018    ....    ADD      r0,r1,#0x18
        0x080028cc:    2201        ."      MOVS     r2,#1
        0x080028ce:    493a        :I      LDR      r1,[pc,#232] ; [0x80029b8] = 0x8003138
        0x080028d0:    f7fff822    ..".    BL       SSD1306_Puts2 ; 0x8001918
;;;38     
;;;39     	char text_buffer[11];
;;;40     
;;;41     	SSD1306_GotoXY(SSD1306_WIDTH - 16, 0);
        0x080028d4:    2100        .!      MOVS     r1,#0
        0x080028d6:    2070        p       MOVS     r0,#0x70
        0x080028d8:    f7fefee0    ....    BL       SSD1306_GotoXY ; 0x800169c
;;;42     //	SSD1306_Puts2(utoa_builtin_div_1(z_axis.mode, text_buffer), &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE); // DKA mode
;;;43     
;;;44     	SSD1306_GotoXY(SSD1306_WIDTH - 60, 16);
        0x080028dc:    2110        .!      MOVS     r1,#0x10
        0x080028de:    2044        D       MOVS     r0,#0x44
        0x080028e0:    f7fefedc    ....    BL       SSD1306_GotoXY ; 0x800169c
;;;45     	SSD1306_Puts2(utoa_builtin_div_1(z_axis.current_pos, text_buffer), &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE); // DKA mode
        0x080028e4:    4935        5I      LDR      r1,[pc,#212] ; [0x80029bc] = 0x20000a38
        0x080028e6:    6808        .h      LDR      r0,[r1,#0]
        0x080028e8:    4669        iF      MOV      r1,sp
        0x080028ea:    f000f87b    ..{.    BL       utoa_builtin_div_1 ; 0x80029e4
        0x080028ee:    4604        .F      MOV      r4,r0
        0x080028f0:    2201        ."      MOVS     r2,#1
        0x080028f2:    4931        1I      LDR      r1,[pc,#196] ; [0x80029b8] = 0x8003138
        0x080028f4:    f7fff810    ....    BL       SSD1306_Puts2 ; 0x8001918
;;;46     
;;;47     //	SSD1306_GotoXY(SSD1306_WIDTH - 60, 32);
;;;48     //	SSD1306_Puts2(utoa_builtin_div_1(z_axis.ramp_step, text_buffer), &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE); // DKA mode
;;;49     	if(i2c_device_logging.sample[i2c_device_logging.index].button_c > 0){
        0x080028f8:    4831        1H      LDR      r0,[pc,#196] ; [0x80029c0] = 0x2000099a
        0x080028fa:    7800        .x      LDRB     r0,[r0,#0]
        0x080028fc:    eb000140    ..@.    ADD      r1,r0,r0,LSL #1
        0x08002900:    482f        /H      LDR      r0,[pc,#188] ; [0x80029c0] = 0x2000099a
        0x08002902:    1c80        ..      ADDS     r0,r0,#2
        0x08002904:    eb000081    ....    ADD      r0,r0,r1,LSL #2
        0x08002908:    7a80        .z      LDRB     r0,[r0,#0xa]
        0x0800290a:    2800        .(      CMP      r0,#0
        0x0800290c:    dd14        ..      BLE      0x8002938 ; update_screen + 192
;;;50     		SSD1306_GotoXY(SSD1306_WIDTH - 60, 32);
        0x0800290e:    2120         !      MOVS     r1,#0x20
        0x08002910:    2044        D       MOVS     r0,#0x44
        0x08002912:    f7fefec3    ....    BL       SSD1306_GotoXY ; 0x800169c
;;;51     		SSD1306_Puts2(utoa_builtin_div_1(i2c_device_logging.sample[i2c_device_logging.index].button_c, text_buffer), &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE); // DKA mode
        0x08002916:    492a        *I      LDR      r1,[pc,#168] ; [0x80029c0] = 0x2000099a
        0x08002918:    7809        .x      LDRB     r1,[r1,#0]
        0x0800291a:    eb010241    ..A.    ADD      r2,r1,r1,LSL #1
        0x0800291e:    4928        (I      LDR      r1,[pc,#160] ; [0x80029c0] = 0x2000099a
        0x08002920:    1c89        ..      ADDS     r1,r1,#2
        0x08002922:    eb010182    ....    ADD      r1,r1,r2,LSL #2
        0x08002926:    7a88        .z      LDRB     r0,[r1,#0xa]
        0x08002928:    4669        iF      MOV      r1,sp
        0x0800292a:    f000f85b    ..[.    BL       utoa_builtin_div_1 ; 0x80029e4
        0x0800292e:    4604        .F      MOV      r4,r0
        0x08002930:    2201        ."      MOVS     r2,#1
        0x08002932:    4921        !I      LDR      r1,[pc,#132] ; [0x80029b8] = 0x8003138
        0x08002934:    f7fefff0    ....    BL       SSD1306_Puts2 ; 0x8001918
;;;52     	}
;;;53     
;;;54     // second line
;;;55     
;;;56     	SSD1306_GotoXY(0, 16*1); //Устанавливаем курсор в позицию 0;16. Сначала по горизонтали, потом вертикали.
        0x08002938:    2110        .!      MOVS     r1,#0x10
        0x0800293a:    2000        .       MOVS     r0,#0
        0x0800293c:    f7fefeae    ....    BL       SSD1306_GotoXY ; 0x800169c
;;;57     	SSD1306_Puts2(Thread_Info[Menu_Step].Text, &microsoftSansSerif_20ptFontInfo, SSD1306_COLOR_WHITE);
        0x08002940:    491b        .I      LDR      r1,[pc,#108] ; [0x80029b0] = 0x20000170
        0x08002942:    4a1c        .J      LDR      r2,[pc,#112] ; [0x80029b4] = 0x20000590
        0x08002944:    7812        .x      LDRB     r2,[r2,#0]
        0x08002946:    eb011142    ..B.    ADD      r1,r1,r2,LSL #5
        0x0800294a:    1d48        H.      ADDS     r0,r1,#5
        0x0800294c:    2201        ."      MOVS     r2,#1
        0x0800294e:    491d        .I      LDR      r1,[pc,#116] ; [0x80029c4] = 0x8003cdc
        0x08002950:    f7feffe2    ....    BL       SSD1306_Puts2 ; 0x8001918
;;;58     	//			SSD1306_GotoXY(50, 16*1);
;;;59     	//			SSD1306_Puts2(Thread_Info[Menu_Step].infeed_mm, &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE);
;;;60     	//			SSD1306_GotoXY(50, 16*2);
;;;61     	//			SSD1306_Puts2(Thread_Info[Menu_Step].infeed_inch, &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE);
;;;62     
;;;63     	SSD1306_GotoXY(0, 16*3);
        0x08002954:    2130        0!      MOVS     r1,#0x30
        0x08002956:    2000        .       MOVS     r0,#0
        0x08002958:    f7fefea0    ....    BL       SSD1306_GotoXY ; 0x800169c
;;;64     	switch(Thread_Info[Menu_Step].infeed_strategy) {
        0x0800295c:    4814        .H      LDR      r0,[pc,#80] ; [0x80029b0] = 0x20000170
        0x0800295e:    4915        .I      LDR      r1,[pc,#84] ; [0x80029b4] = 0x20000590
        0x08002960:    7809        .x      LDRB     r1,[r1,#0]
        0x08002962:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x08002966:    7f80        ..      LDRB     r0,[r0,#0x1e]
        0x08002968:    b120         .      CBZ      r0,0x8002974 ; update_screen + 252
        0x0800296a:    2801        .(      CMP      r0,#1
        0x0800296c:    d008        ..      BEQ      0x8002980 ; update_screen + 264
        0x0800296e:    2802        .(      CMP      r0,#2
        0x08002970:    d112        ..      BNE      0x8002998 ; update_screen + 288
        0x08002972:    e00b        ..      B        0x800298c ; update_screen + 276
;;;65     	case 0:
;;;66     		SSD1306_Puts2("radial", &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE);
        0x08002974:    2201        ."      MOVS     r2,#1
        0x08002976:    4910        .I      LDR      r1,[pc,#64] ; [0x80029b8] = 0x8003138
        0x08002978:    a013        ..      ADR      r0,{pc}+0x50 ; 0x80029c8
        0x0800297a:    f7feffcd    ....    BL       SSD1306_Puts2 ; 0x8001918
;;;67     		break;
        0x0800297e:    e00b        ..      B        0x8002998 ; update_screen + 288
;;;68     	case 1:
;;;69     		SSD1306_Puts2("flank", &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE);
        0x08002980:    2201        ."      MOVS     r2,#1
        0x08002982:    490d        .I      LDR      r1,[pc,#52] ; [0x80029b8] = 0x8003138
        0x08002984:    a012        ..      ADR      r0,{pc}+0x4c ; 0x80029d0
        0x08002986:    f7feffc7    ....    BL       SSD1306_Puts2 ; 0x8001918
;;;70     		break;
        0x0800298a:    e005        ..      B        0x8002998 ; update_screen + 288
;;;71     	case 2:
;;;72     		SSD1306_Puts2("incremental", &microsoftSansSerif_12ptFontInfo, SSD1306_COLOR_WHITE);
        0x0800298c:    2201        ."      MOVS     r2,#1
        0x0800298e:    490a        .I      LDR      r1,[pc,#40] ; [0x80029b8] = 0x8003138
        0x08002990:    a011        ..      ADR      r0,{pc}+0x48 ; 0x80029d8
        0x08002992:    f7feffc1    ....    BL       SSD1306_Puts2 ; 0x8001918
;;;73     		break;
        0x08002996:    bf00        ..      NOP      
        0x08002998:    bf00        ..      NOP      
;;;74     	}
;;;75     
;;;76     
;;;77     /*
;;;78     	if(auto_mode == true) {
;;;79     		SSD1306_GotoXY(SSD1306_WIDTH - 32, 0);
;;;80     		SSD1306_Putc2big('A', &microsoftSansSerif_12ptFontInfo);
;;;81     //  SSD1306_Putc2big(auto_symbol, &consolas_18ptFontInfo);
;;;82     	}
;;;83     */
;;;84     //#if !defined ( _SIMU )
;;;85     	SSD1306_UpdateScreen();
        0x0800299a:    f7feffd7    ....    BL       SSD1306_UpdateScreen ; 0x800194c
;;;86     //	return 0;
;;;87     //#endif
;;;88     }
        0x0800299e:    bf00        ..      NOP      
        0x080029a0:    e76e        n.      B        0x8002880 ; update_screen + 8
    $d
        0x080029a2:    0000        ..      DCW    0
        0x080029a4:    20000027    '..     DCD    536870951
        0x080029a8:    2000015d    ]..     DCD    536871261
        0x080029ac:    08003a3c    <:..    DCD    134232636
        0x080029b0:    20000170    p..     DCD    536871280
        0x080029b4:    20000590    ...     DCD    536872336
        0x080029b8:    08003138    81..    DCD    134230328
        0x080029bc:    20000a38    8..     DCD    536873528
        0x080029c0:    2000099a    ...     DCD    536873370
        0x080029c4:    08003cdc    .<..    DCD    134233308
        0x080029c8:    69646172    radi    DCD    1768186226
        0x080029cc:    00006c61    al..    DCD    27745
        0x080029d0:    6e616c66    flan    DCD    1851878502
        0x080029d4:    0000006b    k...    DCD    107
        0x080029d8:    72636e69    incr    DCD    1919118953
        0x080029dc:    6e656d65    emen    DCD    1852140901
        0x080029e0:    006c6174    tal.    DCD    7102836
    $t
    i.utoa_builtin_div_1
    utoa_builtin_div_1
;;; .\..\Src\screen.c (16)
        0x080029e4:    4602        .F      MOV      r2,r0
;;;17     	buffer += 11;
        0x080029e6:    310b        .1      ADDS     r1,r1,#0xb
;;;18     // 11 байт достаточно для десятичного представления 32-х байтного числа и завершающего нуля
;;;19     	*--buffer = 0;
        0x080029e8:    2300        .#      MOVS     r3,#0
        0x080029ea:    1e48        H.      SUBS     r0,r1,#1
        0x080029ec:    4601        .F      MOV      r1,r0
        0x080029ee:    7003        .p      STRB     r3,[r0,#0]
;;;20     	do {
        0x080029f0:    bf00        ..      NOP      
;;;21     		*--buffer = value % 10 + '0';
        0x080029f2:    200a        .       MOVS     r0,#0xa
        0x080029f4:    fbb2f3f0    ....    UDIV     r3,r2,r0
        0x080029f8:    fb002013    ...     MLS      r0,r0,r3,r2
        0x080029fc:    3030        00      ADDS     r0,r0,#0x30
        0x080029fe:    1e4b        K.      SUBS     r3,r1,#1
        0x08002a00:    4619        .F      MOV      r1,r3
        0x08002a02:    7018        .p      STRB     r0,[r3,#0]
;;;22     		value /= 10;
        0x08002a04:    200a        .       MOVS     r0,#0xa
        0x08002a06:    fbb2f2f0    ....    UDIV     r2,r2,r0
;;;23     	} while (value != 0);
        0x08002a0a:    2a00        .*      CMP      r2,#0
        0x08002a0c:    d1f1        ..      BNE      0x80029f2 ; utoa_builtin_div_1 + 14
;;;24     	return buffer;
        0x08002a0e:    4608        .F      MOV      r0,r1
;;;25     }
        0x08002a10:    4770        pG      BX       lr
        0x08002a12:    0000        ..      MOVS     r0,r0
    i.z_axis_at_move_end
    z_axis_at_move_end
;;; .\..\Src\fsm.c
;;;202    	disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
        0x08002a14:    2100        .!      MOVS     r1,#0
        0x08002a16:    4a07        .J      LDR      r2,[pc,#28] ; [0x8002a34] = 0x42010180
        0x08002a18:    6011        .`      STR      r1,[r2,#0]
;;;203    	//      MOTOR_Z_Disable(); //disable motor later on next tacho event (or after some ticks count?) to completely process last step
;;;204    //	if(auto_mode == true)    auto_mode_delay = auto_mode_delay_ms; // reengage auto mode
;;;205    	feed_direction = !feed_direction; //change feed direction
        0x08002a1a:    4907        .I      LDR      r1,[pc,#28] ; [0x8002a38] = 0x2000015d
        0x08002a1c:    7809        .x      LDRB     r1,[r1,#0]
        0x08002a1e:    f0810101    ....    EOR      r1,r1,#1
        0x08002a22:    4a05        .J      LDR      r2,[pc,#20] ; [0x8002a38] = 0x2000015d
        0x08002a24:    7011        .p      STRB     r1,[r2,#0]
;;;206    	menu_changed = 1; //update menu
        0x08002a26:    2101        .!      MOVS     r1,#1
        0x08002a28:    4a04        .J      LDR      r2,[pc,#16] ; [0x8002a3c] = 0x20000160
        0x08002a2a:    6011        .`      STR      r1,[r2,#0]
;;;207    	s->function = do_fsm_wait_sclick;
        0x08002a2c:    4904        .I      LDR      r1,[pc,#16] ; [0x8002a40] = 0x800244d
        0x08002a2e:    6001        .`      STR      r1,[r0,#0]
;;;208    //	z_axis.mode = fsm_wait_sclick; // dummy mode
;;;209    }
        0x08002a30:    4770        pG      BX       lr
    $d
        0x08002a32:    0000        ..      DCW    0
        0x08002a34:    42010180    ...B    DCD    1107362176
        0x08002a38:    2000015d    ]..     DCD    536871261
        0x08002a3c:    20000160    `..     DCD    536871264
        0x08002a40:    0800244d    M$..    DCD    134227021
    $t
    i.z_axis_move
    z_axis_move
;;; .\..\Src\fsm.c (193)
        0x08002a44:    490b        .I      LDR      r1,[pc,#44] ; [0x8002a74] = 0x20000a38
        0x08002a46:    68c9        .h      LDR      r1,[r1,#0xc]
        0x08002a48:    4a0a        .J      LDR      r2,[pc,#40] ; [0x8002a74] = 0x20000a38
        0x08002a4a:    6912        .i      LDR      r2,[r2,#0x10]
        0x08002a4c:    1888        ..      ADDS     r0,r1,r2
;;;194    	TIM4->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
        0x08002a4e:    2101        .!      MOVS     r1,#1
        0x08002a50:    ebc16110    ...a    RSB      r1,r1,r0,LSR #24
        0x08002a54:    4a08        .J      LDR      r2,[pc,#32] ; [0x8002a78] = 0x4000082c
        0x08002a56:    6011        .`      STR      r1,[r2,#0]
;;;195    	TIM4->EGR |= TIM_EGR_UG;
        0x08002a58:    4907        .I      LDR      r1,[pc,#28] ; [0x8002a78] = 0x4000082c
        0x08002a5a:    3918        .9      SUBS     r1,r1,#0x18
        0x08002a5c:    6809        .h      LDR      r1,[r1,#0]
        0x08002a5e:    f0410101    A...    ORR      r1,r1,#1
        0x08002a62:    4a05        .J      LDR      r2,[pc,#20] ; [0x8002a78] = 0x4000082c
        0x08002a64:    3a18        .:      SUBS     r2,r2,#0x18
        0x08002a66:    6011        .`      STR      r1,[r2,#0]
;;;196    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
        0x08002a68:    f020417f     ..A    BIC      r1,r0,#0xff000000
        0x08002a6c:    4a01        .J      LDR      r2,[pc,#4] ; [0x8002a74] = 0x20000a38
        0x08002a6e:    6111        .a      STR      r1,[r2,#0x10]
;;;197    }
        0x08002a70:    4770        pG      BX       lr
    $d
        0x08002a72:    0000        ..      DCW    0
        0x08002a74:    20000a38    8..     DCD    536873528
        0x08002a78:    4000082c    ,..@    DCD    1073743916
    $t
    i.z_axis_move2
    z_axis_move2
;;;198    
;;;199    
;;;200    void z_axis_at_move_end(state_t* s)
;;;201    {
;;;202    	disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
;;;203    	//      MOTOR_Z_Disable(); //disable motor later on next tacho event (or after some ticks count?) to completely process last step
;;;204    //	if(auto_mode == true)    auto_mode_delay = auto_mode_delay_ms; // reengage auto mode
;;;205    	feed_direction = !feed_direction; //change feed direction
;;;206    	menu_changed = 1; //update menu
;;;207    	s->function = do_fsm_wait_sclick;
;;;208    //	z_axis.mode = fsm_wait_sclick; // dummy mode
;;;209    }
;;;210    
;;;211    
;;;212    
;;;213    
;;;214    void do_fsm_wait_tacho(state_t* s)
;;;215    {
;;;216    	if(s->f_tacho) { // if tacho event
;;;217    		s->function = do_fsm_first_cut_ramp_up;
;;;218    //		infeed_step = 0; todo
;;;219    		LED_GPIO_Port->BRR = LED_Pin; //led on
;;;220    		TIM4->ARR = 1; // start stepper motor ramp up procedure immediately after tacho event
;;;221    		TIM4->EGR |= TIM_EGR_UG;
;;;222    		TIM4->CNT = 0;
;;;223    		enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;224    	}
;;;225    }
;;;226    
;;;227    void do_fsm_menu(state_t* s)
;;;228    {
;;;229    	uint8_t level = Thread_Info[Menu_Step].level;
;;;230    	buttons_flag_set = long_press_start_Msk;
;;;231    	switch(buttons_flag_set) {
;;;232    	case single_click_Msk3: {
;;;233    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;234    		menu_changed = 1;
;;;235    		break;
;;;236    	}
;;;237    	case single_click_Msk2: {
;;;238    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;239    		menu_changed = 1;
;;;240    		break;
;;;241    	}
;;;242    	case single_click_Msk: {
;;;243    		if(z_axis.end_pos != 0) {
;;;244    
;;;245    			// first pass of thread cut was complete, so just use single click
;;;246    			//	to switch between modes to process all other cuts
;;;247    			MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;248    			for(unsigned int i=0; i<(72*1700/16); i++); // wait 1700us delay to wakeup motor driver
;;;249    			s->function = z_axis.current_pos > 0 ? do_fsm_sclick_event : do_fsm_main_cut_wait_tacho;
;;;250    		} else { // controller in initial state, scroll menu
;;;251    			s->function = do_fsm_menu_lps;
;;;252    			for (int a = Menu_Step+1; a<Menu_size; a++) {
;;;253    				if(Thread_Info[a].level == level) {
;;;254    					Menu_Step = a;
;;;255    					menu_changed = 1;
;;;256    					break;
;;;257    				}
;;;258    			}
;;;259    			if(menu_changed != 1) {
;;;260    				for (int a = 0; a<Menu_Step; a++) {
;;;261    					if(Thread_Info[a].level == level) {
;;;262    						Menu_Step = a;
;;;263    						menu_changed = 1;
;;;264    						break;
;;;265    					}
;;;266    				}
;;;267    			}
;;;268    		}
;;;269    		break;
;;;270    	}
;;;271    	case double_click_Msk: {
;;;272    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;273    		menu_changed = 1;
;;;274    		break;
;;;275    	}
;;;276    	case (long_press_start_Msk | long_press_start_Msk2): { // two buttons long pressed same time
;;;277    		// todo check if it work
;;;278    		break;
;;;279    	}
;;;280    	case long_press_start_Msk: {
;;;281    		if(s->function == do_fsm_menu_lps){
;;;282    			if(Thread_Info[Menu_Step].Q824 != 0) { // long press detected, start new thread from current position
;;;283    				//mode 20:
;;;284    				disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
;;;285    				MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;286    				s->main_feed_direction = feed_direction; // save main feed direction, where cut is on
;;;287    				s->sync = true;
;;;288    				if( feed_direction == feed_direction_right )
;;;289    					MOTOR_Z_Forward();
;;;290    				else
;;;291    					MOTOR_Z_Reverse();
;;;292    				
;;;293    				for(unsigned int i=0; i<(72*1700/16); i++); // wait 1700us delay to wakeup motor driver todo dumb method
;;;294    
;;;295    				z_axis.Q824set = Thread_Info[Menu_Step].Q824;
;;;296    				z_axis.end_pos = z_axis.current_pos = 0;
;;;297    
;;;298    				const uint64_t upl = (uint64_t)3600 << 48; //calculate some constants for prolong mode
;;;299    				z_axis.prolong_addSteps = upl / (fixedptud)z_axis.Q824set;
;;;300    
;;;301    				s->function = do_fsm_move_start;//do_fsm_wait_tacho; // go straight to 24 to wait tacho
;;;302    //do_fsm_move_start
;;;303    			} else { // goto submenu
;;;304    				for (int a = 0; a<Menu_size; a++) {
;;;305    					if(Thread_Info[a].level == Thread_Info[Menu_Step].submenu) {
;;;306    						Menu_Step = a;
;;;307    						menu_changed = 1;
;;;308    						break;
;;;309    					}
;;;310    				}
;;;311    			}
;;;312    		} else if(s->function == do_fsm_main_cut_back){
;;;313    			s->function = do_fsm_main_cut_back_prolong; // go to 48 mode to add threads until long_press end
;;;314    		}
;;;315    		break;
;;;316    	}
;;;317    	case long_press_end_Msk: {
;;;318    		s->function = do_long_press_end_callback;
;;;319    		break;
;;;320    /*
;;;321    		if(s->function == do_fsm_first_cut_main_part){
;;;322    			s->function = do_fsm_first_cut_lpe;
;;;323    			break;
;;;324    		}
;;;325    		if(s->function == do_fsm_main_cut_back_prolong){ // end of prolonged mode
;;;326    			s->function = do_fsm_main_cut_back;
;;;327    			break;
;;;328    		}
;;;329    */
;;;330    		/*
;;;331    		switch(z_axis.mode) {
;;;332    		case fsm_first_cut_main_part: {
;;;333    //																					if(auto_mode == true){
;;;334    //																									auto_mode_delay = auto_mode_delay_ms; //engage countdown timer to auto generate click event
;;;335    //																					}
;;;336    //																					Q824count = 0;
;;;337    			s->function = do_fsm_first_cut_lpe;
;;;338    			break;
;;;339    		}
;;;340    		case fsm_main_cut_back_prolong: { // end of prolonged mode
;;;341    			s->function = do_fsm_main_cut_back;
;;;342    			break;
;;;343    		}
;;;344    		}
;;;345    		*/
;;;346    		break;
;;;347    	}
;;;348    	}
;;;349    }
;;;350    
;;;351    void do_fsm_menu_lps(state_t* s)
;;;352    {
;;;353    }
;;;354    
;;;355    
;;;356    
;;;357    void do_fsm_first_cut_lps(state_t* s)  // not used?
;;;358    {
;;;359    	
;;;360    	disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
;;;361    	MOTOR_Z_Enable();
;;;362    	if(feed_direction)
;;;363    		MOTOR_Z_Forward();
;;;364    	else
;;;365    		MOTOR_Z_Reverse();
;;;366    	s->function = do_fsm_wait_tacho; //intermediate state to wait tacho pulse.
;;;367    }
;;;368    
;;;369    
;;;370    
;;;371    
;;;372    
;;;373    
;;;374    void do_fsm_first_cut_ramp_up(state_t* s)          // direct movement: first pass, thread recording: ramp up: accel by ramp map
;;;375    {
;;;376    	MOTOR_Z_SetPulse();
;;;377    	z_axis.current_pos++;
;;;378    	if(z_axis_ramp_up()) {
;;;379    		s->function = do_fsm_first_cut_main_part;
;;;380    		LED_GPIO_Port->BSRR = LED_Pin; //led off
;;;381    	}
;;;382    }
;;;383    
;;;384    
;;;385    void do_fsm_first_cut_main_part(state_t* s)          // direct movement: first pass, thread recording: main part
;;;386    {
;;;387    	MOTOR_Z_SetPulse();
;;;388    	z_axis.current_pos++;
;;;389    	z_axis_move();
;;;390    }
;;;391    
;;;392    
;;;393    void do_fsm_first_cut_lpe(state_t* s)          // direct movement: first pass, thread recording: post-main part
;;;394    {
;;;395    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;396    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;397    	// не перескакивая на соседние шаги при потере питания.
;;;398    	// поэтому проверяем общее количество на четность(0й бит), если нечетное число делаем еще один шаг,
;;;399    	// иначе начинаем замедляться
;;;400    	MOTOR_Z_SetPulse();
;;;401    	z_axis.current_pos++;
;;;402    	uint32_t all_count = z_axis.ramp_step + z_axis.current_pos - 1;
;;;403    	uint32_t masked_count = all_count & ~(step_divider - 1);
;;;404    	if(masked_count != all_count) {
;;;405    		z_axis_move();
;;;406    	} else {
;;;407    		if(z_axis_ramp_down()) {
;;;408    			z_axis.end_pos = z_axis.current_pos;
;;;409    			z_axis_at_move_end(s);
;;;410    		} else {
;;;411    			s->function = do_fsm_first_cut_ramp_down;
;;;412    		}
;;;413    	}
;;;414    }
;;;415    
;;;416    
;;;417    
;;;418    
;;;419    
;;;420    
;;;421    void do_fsm_first_cut_ramp_down(state_t* s)          // direct movement: ramp down: deccel part + stop
;;;422    {
;;;423    	MOTOR_Z_SetPulse();
;;;424    	z_axis.current_pos++;
;;;425    	if(z_axis_ramp_down()) {
;;;426    		z_axis.end_pos = z_axis.current_pos;
;;;427    		z_axis_at_move_end(s);
;;;428    	}
;;;429    }
;;;430    
;;;431    
;;;432    
;;;433    void do_fsm_sclick_event(state_t* s)   // reverse movement: set direction for motor
;;;434    {
;;;435    	if(feed_direction)
;;;436    		MOTOR_Z_Forward();
;;;437    	else
;;;438    		MOTOR_Z_Reverse();
;;;439    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;440    	s->function = do_fsm_main_cut_back_ramp_up;
;;;441    }
;;;442    
;;;443    
;;;444    
;;;445    
;;;446    
;;;447    void do_fsm_main_cut_back_ramp_up(state_t* s)          // reverse movement: ramp up: accel part
;;;448    {
;;;449    	MOTOR_Z_SetPulse();
;;;450    	--z_axis.current_pos;
;;;451    	if(z_axis_ramp_up())
;;;452    		s->function = do_fsm_main_cut_back;
;;;453    }
;;;454    
;;;455    
;;;456    
;;;457    
;;;458    
;;;459    
;;;460    
;;;461    void do_fsm_main_cut_back(state_t* s)          // reverse movement: main part
;;;462    {
;;;463    	MOTOR_Z_SetPulse();
;;;464    	if( --z_axis.current_pos > z_axis.ramp_step ) {
;;;465    	} else {
;;;466    		s->function = do_fsm_main_cut_back_ramp_down;
;;;467    	}
;;;468    }
;;;469    
;;;470    
;;;471    
;;;472    void do_fsm_main_cut_back_ramp_down(state_t* s)   // reverse movement: ramp down: deccel part + stop
;;;473    {
;;;474    	if (z_axis.current_pos > 0) {
;;;475    		MOTOR_Z_SetPulse();
;;;476    		--z_axis.current_pos;
;;;477    	}
;;;478    	if(z_axis_ramp_down()) {
;;;479    		z_axis_at_move_end(s);
;;;480    	}
;;;481    }
;;;482    
;;;483    
;;;484    
;;;485    
;;;486    
;;;487    
;;;488    
;;;489    
;;;490    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;491    {
;;;492    	MOTOR_Z_SetPulse();
;;;493    	--z_axis.current_pos;
;;;494    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
;;;495    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
;;;496    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
;;;497    		z_axis.current_pos += prolong_fixpart; // add fixed part
;;;498    		z_axis.end_pos += prolong_fixpart;
;;;499    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
;;;500    		// when long_press end, get back to 46 mode to proceed
;;;501    	}
;;;502    }
;;;503    
;;;504    void do_fsm_main_cut_wait_tacho(state_t* s)   // direct movement: set direction for motor
;;;505    {
;;;506    	if(feed_direction)
;;;507    		MOTOR_Z_Forward();
;;;508    	else
;;;509    		MOTOR_Z_Reverse();
;;;510    	s->function = do_fsm_main_cut_ramp_up; // intermediate state to wait tacho pulse
;;;511    	disable_encoder_ticks(); // reset interrupt for encoder ticks, only tacho
;;;512    }
;;;513    
;;;514    void do_fsm_main_cut(state_t* s)   // direct movement: ramp up: accel by ramp map
;;;515    {
;;;516    	MOTOR_Z_SetPulse();
;;;517    	z_axis.current_pos++;
;;;518    	if(z_axis_ramp_up()) {
;;;519    		LED_GPIO_Port->BSRR = LED_Pin;   // led off
;;;520    		s->function = do_fsm_main_cut_infeed;
;;;521    	}
;;;522    }
;;;523    
;;;524    
;;;525    void do_fsm_main_cut_infeed(state_t* s)   // direct movement: main part
;;;526    {
;;;527    	MOTOR_Z_SetPulse();
;;;528    	z_axis.current_pos++;
;;;529    	if( z_axis.current_pos < ( z_axis.end_pos - z_axis.ramp_step ) ) {
;;;530    		z_axis_move();
;;;531    	} else {
;;;532    		s->function = do_fsm_first_cut_ramp_down;
;;;533    	}
;;;534    }
;;;535    
;;;536    
;;;537    void do_fsm_wait_sclick(state_t* s)
;;;538    {
;;;539    	MOTOR_Z_Disable(); //disable motor
;;;540    }
;;;541    
;;;542    void do_fsm_main_cut_ramp_up(state_t* s)
;;;543    {
;;;544    	s->function = do_fsm_main_cut;
;;;545    	//reinit counter
;;;546    //                          TIM4->ARR = fixedpt_toint(Q824set) - 1;
;;;547    	LED_GPIO_Port->BRR = LED_Pin; //led on
;;;548    
;;;549    	if(infeed_step < infeed_steps) {
;;;550    		TIM4->ARR = infeed_map[infeed_step++] + 1; // start stepper motor with shifted position by infeed map
;;;551    	} else {
;;;552    		TIM4->ARR = 1;  // start stepper motor ramp up procedure immediately after tacho event
;;;553    	}
;;;554    	TIM4->EGR |= TIM_EGR_UG;
;;;555    
;;;556    	TIM4->CNT = 0;
;;;557    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;558    }
;;;559    
;;;560    
;;;561    
;;;562    //---------------------------------------------------------------------------------------------
;;;563    void do_fsm_move_start(state_t* s){
;;;564    	if(s->main_feed_direction == feed_direction && s->f_tacho ) { // if tacho event or we going to start back feed to initial position with async clock
;;;565    		if(s->main_feed_direction == feed_direction) {
;;;566    			s->function = do_fsm_ramp_up;
;;;567    			s->sync = true;
;;;568    			s->async_z = 0;
;;;569    			s->syncbase = TIM4; 									// sync with spindle
;;;570    
;;;571    			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
;;;572    			s->syncbase->EGR |= TIM_EGR_UG; // upload ARR value immediately 
;;;573    			s->syncbase->CNT = 0;						// reset counter
;;;574    //			LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH2);
;;;575    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
;;;576    		} else {
;;;577    
;;;578    			s->async_z = 1;
;;;579    //			s->syncbase = &htim2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;580    			s->function = do_fsm_ramp_up_async;
;;;581    
;;;582    		/* Enable counter */
;;;583    		LL_TIM_EnableCounter(TIM2);
;;;584    		/* Force update generation */
;;;585    		LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;586    
;;;587    //			LL_TIM_EnableIT_UPDATE(TIM2);
;;;588    		}
;;;589    
;;;590    	}	
;;;591    }
;;;592    
;;;593    void do_fsm_ramp_up(state_t* s)
;;;594    {
;;;595    	MOTOR_Z_SetPulse();
;;;596    	z_axis.current_pos++;
;;;597    	if(z_axis_ramp_up2(s)) {
;;;598    		s->function = do_fsm_move;
;;;599    	}
;;;600    }
;;;601    
;;;602    void do_fsm_move(state_t* s)
;;;603    {
;;;604    	MOTOR_Z_SetPulse();
;;;605    //	z_axis.current_pos++;
;;;606    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;607    //	else z_axis.current_pos--;
;;;608    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;609    		z_axis_move2(s);
;;;610    	} else {
;;;611    		if(z_axis_ramp_down2(s)) {
;;;612    			if(z_axis.end_pos != z_axis.current_pos) {
;;;613    				z_axis.end_pos = z_axis.current_pos;
;;;614    			}
;;;615    			s->function = do_fsm_move_end;
;;;616    		}
;;;617    		s->function = do_fsm_ramp_down;
;;;618    	}
;;;619    }
;;;620    
;;;621    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;622    {
;;;623    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;624    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;625    	// не перескакивая на соседние шаги при потере питания.
;;;626    	z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;627    	s->function = do_fsm_move;
;;;628    	do_fsm_move(s);
;;;629    }
;;;630    
;;;631    
;;;632    void do_fsm_ramp_down(state_t* s)
;;;633    {
;;;634    	MOTOR_Z_SetPulse();
;;;635    	if(s->spindle_dir)	z_axis.current_pos++;
;;;636    	else z_axis.current_pos--;
;;;637    	if(z_axis_ramp_down2(s)) {
;;;638    		if(z_axis.end_pos != z_axis.current_pos) {
;;;639    			z_axis.end_pos = z_axis.current_pos;
;;;640    		}
;;;641    		s->function = do_fsm_move_end;
;;;642    	}
;;;643    }
;;;644    
;;;645    void do_fsm_move_end(state_t* s){
;;;646    	s->async_z = 0;
;;;647    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;648    	if (s->sync) {
;;;649    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;650    	} else {
;;;651    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;652    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;653    	}
;;;654      MOTOR_Z_Disable(); 									//disable motor later on next tacho event (or after some ticks count?) to completely process last step
;;;655    	feed_direction = !feed_direction; 					//change feed direction
;;;656    	menu_changed = 1; 													//update menu
;;;657    	s->function = do_fsm_wait_sclick;
;;;658    
;;;659    	z_axis.current_pos = 0;
;;;660    }
;;;661    
;;;662    
;;;663    _Bool z_axis_ramp_up2(state_t* s)
;;;664    {
;;;665    	const fixedptu  set_with_fract = ramp[z_axis.ramp_step];
;;;666    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == ramp_map) { 	// reach desired speed or end of ramp map
;;;667    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;668    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;669    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;670    //		z_axis.end_minus_ramp_delta =
;;;671    		return true;
;;;672    	} else {
;;;673    		z_axis.ramp_step++;
;;;674    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;675    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;676    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;677    	}
;;;678    	return false;
;;;679    }
;;;680    
;;;681    _Bool z_axis_ramp_down2(state_t* s)
;;;682    {
;;;683    	if (z_axis.ramp_step == 0)
;;;684    		return true;
;;;685    	const fixedptu set_with_fract = ramp[--z_axis.ramp_step];
;;;686    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;687    //	s->syncbase->EGR |= TIM_EGR_UG;
;;;688    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;689    	if(z_axis.ramp_step == 0)
;;;690    		return true;
;;;691    	return false;
;;;692    }
;;;693    
;;;694    void z_axis_move2(state_t* s)
;;;695    {
        0x08002a7c:    4601        .F      MOV      r1,r0
;;;696    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
        0x08002a7e:    4a07        .J      LDR      r2,[pc,#28] ; [0x8002a9c] = 0x20000a38
        0x08002a80:    68d2        .h      LDR      r2,[r2,#0xc]
        0x08002a82:    4b06        .K      LDR      r3,[pc,#24] ; [0x8002a9c] = 0x20000a38
        0x08002a84:    691b        .i      LDR      r3,[r3,#0x10]
        0x08002a86:    18d0        ..      ADDS     r0,r2,r3
;;;697    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
        0x08002a88:    2201        ."      MOVS     r2,#1
        0x08002a8a:    ebc26210    ...b    RSB      r2,r2,r0,LSR #24
        0x08002a8e:    694b        Ki      LDR      r3,[r1,#0x14]
        0x08002a90:    62da        .b      STR      r2,[r3,#0x2c]
;;;698    //	s->syncbase->CNT = 0;
;;;699    //	s->syncbase->EGR |= TIM_EGR_UG;
;;;700    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
        0x08002a92:    f020427f     ..B    BIC      r2,r0,#0xff000000
        0x08002a96:    4b01        .K      LDR      r3,[pc,#4] ; [0x8002a9c] = 0x20000a38
        0x08002a98:    611a        .a      STR      r2,[r3,#0x10]
;;;701    }
        0x08002a9a:    4770        pG      BX       lr
    $d
        0x08002a9c:    20000a38    8..     DCD    536873528
    $t
    i.z_axis_ramp_down
    z_axis_ramp_down
;;; .\..\Src\fsm.c (180)
        0x08002aa0:    4812        .H      LDR      r0,[pc,#72] ; [0x8002aec] = 0x20000a38
        0x08002aa2:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002aa6:    b908        ..      CBNZ     r0,0x8002aac ; z_axis_ramp_down + 12
;;;181    		return true;
        0x08002aa8:    2001        .       MOVS     r0,#1
        0x08002aaa:    4770        pG      BX       lr
;;;182    	const fixedptu set_with_fract = ramp[--z_axis.ramp_step];
        0x08002aac:    480f        .H      LDR      r0,[pc,#60] ; [0x8002aec] = 0x20000a38
        0x08002aae:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002ab2:    1e40        @.      SUBS     r0,r0,#1
        0x08002ab4:    b2c0        ..      UXTB     r0,r0
        0x08002ab6:    4a0d        .J      LDR      r2,[pc,#52] ; [0x8002aec] = 0x20000a38
        0x08002ab8:    f8820028    ..(.    STRB     r0,[r2,#0x28]
        0x08002abc:    4a0c        .J      LDR      r2,[pc,#48] ; [0x8002af0] = 0x2000004c
        0x08002abe:    f8521020    R. .    LDR      r1,[r2,r0,LSL #2]
;;;183    	TIM4->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
        0x08002ac2:    2001        .       MOVS     r0,#1
        0x08002ac4:    ebc06011    ...`    RSB      r0,r0,r1,LSR #24
        0x08002ac8:    4a0a        .J      LDR      r2,[pc,#40] ; [0x8002af4] = 0x4000082c
        0x08002aca:    6010        .`      STR      r0,[r2,#0]
;;;184    	TIM4->EGR |= TIM_EGR_UG;
        0x08002acc:    4809        .H      LDR      r0,[pc,#36] ; [0x8002af4] = 0x4000082c
        0x08002ace:    3818        .8      SUBS     r0,r0,#0x18
        0x08002ad0:    6800        .h      LDR      r0,[r0,#0]
        0x08002ad2:    f0400001    @...    ORR      r0,r0,#1
        0x08002ad6:    4a07        .J      LDR      r2,[pc,#28] ; [0x8002af4] = 0x4000082c
        0x08002ad8:    3a18        .:      SUBS     r2,r2,#0x18
        0x08002ada:    6010        .`      STR      r0,[r2,#0]
;;;185    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;186    	if(z_axis.ramp_step == 0)
        0x08002adc:    4803        .H      LDR      r0,[pc,#12] ; [0x8002aec] = 0x20000a38
        0x08002ade:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002ae2:    b908        ..      CBNZ     r0,0x8002ae8 ; z_axis_ramp_down + 72
;;;187    		return true;
        0x08002ae4:    2001        .       MOVS     r0,#1
        0x08002ae6:    e7e0        ..      B        0x8002aaa ; z_axis_ramp_down + 10
;;;188    	return false;
        0x08002ae8:    2000        .       MOVS     r0,#0
        0x08002aea:    e7de        ..      B        0x8002aaa ; z_axis_ramp_down + 10
    $d
        0x08002aec:    20000a38    8..     DCD    536873528
        0x08002af0:    2000004c    L..     DCD    536870988
        0x08002af4:    4000082c    ,..@    DCD    1073743916
    $t
    i.z_axis_ramp_down2
    z_axis_ramp_down2
;;;189    }
;;;190    
;;;191    void z_axis_move(void)
;;;192    {
;;;193    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;194    	TIM4->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;195    	TIM4->EGR |= TIM_EGR_UG;
;;;196    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;197    }
;;;198    
;;;199    
;;;200    void z_axis_at_move_end(state_t* s)
;;;201    {
;;;202    	disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
;;;203    	//      MOTOR_Z_Disable(); //disable motor later on next tacho event (or after some ticks count?) to completely process last step
;;;204    //	if(auto_mode == true)    auto_mode_delay = auto_mode_delay_ms; // reengage auto mode
;;;205    	feed_direction = !feed_direction; //change feed direction
;;;206    	menu_changed = 1; //update menu
;;;207    	s->function = do_fsm_wait_sclick;
;;;208    //	z_axis.mode = fsm_wait_sclick; // dummy mode
;;;209    }
;;;210    
;;;211    
;;;212    
;;;213    
;;;214    void do_fsm_wait_tacho(state_t* s)
;;;215    {
;;;216    	if(s->f_tacho) { // if tacho event
;;;217    		s->function = do_fsm_first_cut_ramp_up;
;;;218    //		infeed_step = 0; todo
;;;219    		LED_GPIO_Port->BRR = LED_Pin; //led on
;;;220    		TIM4->ARR = 1; // start stepper motor ramp up procedure immediately after tacho event
;;;221    		TIM4->EGR |= TIM_EGR_UG;
;;;222    		TIM4->CNT = 0;
;;;223    		enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;224    	}
;;;225    }
;;;226    
;;;227    void do_fsm_menu(state_t* s)
;;;228    {
;;;229    	uint8_t level = Thread_Info[Menu_Step].level;
;;;230    	buttons_flag_set = long_press_start_Msk;
;;;231    	switch(buttons_flag_set) {
;;;232    	case single_click_Msk3: {
;;;233    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;234    		menu_changed = 1;
;;;235    		break;
;;;236    	}
;;;237    	case single_click_Msk2: {
;;;238    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;239    		menu_changed = 1;
;;;240    		break;
;;;241    	}
;;;242    	case single_click_Msk: {
;;;243    		if(z_axis.end_pos != 0) {
;;;244    
;;;245    			// first pass of thread cut was complete, so just use single click
;;;246    			//	to switch between modes to process all other cuts
;;;247    			MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;248    			for(unsigned int i=0; i<(72*1700/16); i++); // wait 1700us delay to wakeup motor driver
;;;249    			s->function = z_axis.current_pos > 0 ? do_fsm_sclick_event : do_fsm_main_cut_wait_tacho;
;;;250    		} else { // controller in initial state, scroll menu
;;;251    			s->function = do_fsm_menu_lps;
;;;252    			for (int a = Menu_Step+1; a<Menu_size; a++) {
;;;253    				if(Thread_Info[a].level == level) {
;;;254    					Menu_Step = a;
;;;255    					menu_changed = 1;
;;;256    					break;
;;;257    				}
;;;258    			}
;;;259    			if(menu_changed != 1) {
;;;260    				for (int a = 0; a<Menu_Step; a++) {
;;;261    					if(Thread_Info[a].level == level) {
;;;262    						Menu_Step = a;
;;;263    						menu_changed = 1;
;;;264    						break;
;;;265    					}
;;;266    				}
;;;267    			}
;;;268    		}
;;;269    		break;
;;;270    	}
;;;271    	case double_click_Msk: {
;;;272    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;273    		menu_changed = 1;
;;;274    		break;
;;;275    	}
;;;276    	case (long_press_start_Msk | long_press_start_Msk2): { // two buttons long pressed same time
;;;277    		// todo check if it work
;;;278    		break;
;;;279    	}
;;;280    	case long_press_start_Msk: {
;;;281    		if(s->function == do_fsm_menu_lps){
;;;282    			if(Thread_Info[Menu_Step].Q824 != 0) { // long press detected, start new thread from current position
;;;283    				//mode 20:
;;;284    				disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
;;;285    				MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;286    				s->main_feed_direction = feed_direction; // save main feed direction, where cut is on
;;;287    				s->sync = true;
;;;288    				if( feed_direction == feed_direction_right )
;;;289    					MOTOR_Z_Forward();
;;;290    				else
;;;291    					MOTOR_Z_Reverse();
;;;292    				
;;;293    				for(unsigned int i=0; i<(72*1700/16); i++); // wait 1700us delay to wakeup motor driver todo dumb method
;;;294    
;;;295    				z_axis.Q824set = Thread_Info[Menu_Step].Q824;
;;;296    				z_axis.end_pos = z_axis.current_pos = 0;
;;;297    
;;;298    				const uint64_t upl = (uint64_t)3600 << 48; //calculate some constants for prolong mode
;;;299    				z_axis.prolong_addSteps = upl / (fixedptud)z_axis.Q824set;
;;;300    
;;;301    				s->function = do_fsm_move_start;//do_fsm_wait_tacho; // go straight to 24 to wait tacho
;;;302    //do_fsm_move_start
;;;303    			} else { // goto submenu
;;;304    				for (int a = 0; a<Menu_size; a++) {
;;;305    					if(Thread_Info[a].level == Thread_Info[Menu_Step].submenu) {
;;;306    						Menu_Step = a;
;;;307    						menu_changed = 1;
;;;308    						break;
;;;309    					}
;;;310    				}
;;;311    			}
;;;312    		} else if(s->function == do_fsm_main_cut_back){
;;;313    			s->function = do_fsm_main_cut_back_prolong; // go to 48 mode to add threads until long_press end
;;;314    		}
;;;315    		break;
;;;316    	}
;;;317    	case long_press_end_Msk: {
;;;318    		s->function = do_long_press_end_callback;
;;;319    		break;
;;;320    /*
;;;321    		if(s->function == do_fsm_first_cut_main_part){
;;;322    			s->function = do_fsm_first_cut_lpe;
;;;323    			break;
;;;324    		}
;;;325    		if(s->function == do_fsm_main_cut_back_prolong){ // end of prolonged mode
;;;326    			s->function = do_fsm_main_cut_back;
;;;327    			break;
;;;328    		}
;;;329    */
;;;330    		/*
;;;331    		switch(z_axis.mode) {
;;;332    		case fsm_first_cut_main_part: {
;;;333    //																					if(auto_mode == true){
;;;334    //																									auto_mode_delay = auto_mode_delay_ms; //engage countdown timer to auto generate click event
;;;335    //																					}
;;;336    //																					Q824count = 0;
;;;337    			s->function = do_fsm_first_cut_lpe;
;;;338    			break;
;;;339    		}
;;;340    		case fsm_main_cut_back_prolong: { // end of prolonged mode
;;;341    			s->function = do_fsm_main_cut_back;
;;;342    			break;
;;;343    		}
;;;344    		}
;;;345    		*/
;;;346    		break;
;;;347    	}
;;;348    	}
;;;349    }
;;;350    
;;;351    void do_fsm_menu_lps(state_t* s)
;;;352    {
;;;353    }
;;;354    
;;;355    
;;;356    
;;;357    void do_fsm_first_cut_lps(state_t* s)  // not used?
;;;358    {
;;;359    	
;;;360    	disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
;;;361    	MOTOR_Z_Enable();
;;;362    	if(feed_direction)
;;;363    		MOTOR_Z_Forward();
;;;364    	else
;;;365    		MOTOR_Z_Reverse();
;;;366    	s->function = do_fsm_wait_tacho; //intermediate state to wait tacho pulse.
;;;367    }
;;;368    
;;;369    
;;;370    
;;;371    
;;;372    
;;;373    
;;;374    void do_fsm_first_cut_ramp_up(state_t* s)          // direct movement: first pass, thread recording: ramp up: accel by ramp map
;;;375    {
;;;376    	MOTOR_Z_SetPulse();
;;;377    	z_axis.current_pos++;
;;;378    	if(z_axis_ramp_up()) {
;;;379    		s->function = do_fsm_first_cut_main_part;
;;;380    		LED_GPIO_Port->BSRR = LED_Pin; //led off
;;;381    	}
;;;382    }
;;;383    
;;;384    
;;;385    void do_fsm_first_cut_main_part(state_t* s)          // direct movement: first pass, thread recording: main part
;;;386    {
;;;387    	MOTOR_Z_SetPulse();
;;;388    	z_axis.current_pos++;
;;;389    	z_axis_move();
;;;390    }
;;;391    
;;;392    
;;;393    void do_fsm_first_cut_lpe(state_t* s)          // direct movement: first pass, thread recording: post-main part
;;;394    {
;;;395    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;396    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;397    	// не перескакивая на соседние шаги при потере питания.
;;;398    	// поэтому проверяем общее количество на четность(0й бит), если нечетное число делаем еще один шаг,
;;;399    	// иначе начинаем замедляться
;;;400    	MOTOR_Z_SetPulse();
;;;401    	z_axis.current_pos++;
;;;402    	uint32_t all_count = z_axis.ramp_step + z_axis.current_pos - 1;
;;;403    	uint32_t masked_count = all_count & ~(step_divider - 1);
;;;404    	if(masked_count != all_count) {
;;;405    		z_axis_move();
;;;406    	} else {
;;;407    		if(z_axis_ramp_down()) {
;;;408    			z_axis.end_pos = z_axis.current_pos;
;;;409    			z_axis_at_move_end(s);
;;;410    		} else {
;;;411    			s->function = do_fsm_first_cut_ramp_down;
;;;412    		}
;;;413    	}
;;;414    }
;;;415    
;;;416    
;;;417    
;;;418    
;;;419    
;;;420    
;;;421    void do_fsm_first_cut_ramp_down(state_t* s)          // direct movement: ramp down: deccel part + stop
;;;422    {
;;;423    	MOTOR_Z_SetPulse();
;;;424    	z_axis.current_pos++;
;;;425    	if(z_axis_ramp_down()) {
;;;426    		z_axis.end_pos = z_axis.current_pos;
;;;427    		z_axis_at_move_end(s);
;;;428    	}
;;;429    }
;;;430    
;;;431    
;;;432    
;;;433    void do_fsm_sclick_event(state_t* s)   // reverse movement: set direction for motor
;;;434    {
;;;435    	if(feed_direction)
;;;436    		MOTOR_Z_Forward();
;;;437    	else
;;;438    		MOTOR_Z_Reverse();
;;;439    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;440    	s->function = do_fsm_main_cut_back_ramp_up;
;;;441    }
;;;442    
;;;443    
;;;444    
;;;445    
;;;446    
;;;447    void do_fsm_main_cut_back_ramp_up(state_t* s)          // reverse movement: ramp up: accel part
;;;448    {
;;;449    	MOTOR_Z_SetPulse();
;;;450    	--z_axis.current_pos;
;;;451    	if(z_axis_ramp_up())
;;;452    		s->function = do_fsm_main_cut_back;
;;;453    }
;;;454    
;;;455    
;;;456    
;;;457    
;;;458    
;;;459    
;;;460    
;;;461    void do_fsm_main_cut_back(state_t* s)          // reverse movement: main part
;;;462    {
;;;463    	MOTOR_Z_SetPulse();
;;;464    	if( --z_axis.current_pos > z_axis.ramp_step ) {
;;;465    	} else {
;;;466    		s->function = do_fsm_main_cut_back_ramp_down;
;;;467    	}
;;;468    }
;;;469    
;;;470    
;;;471    
;;;472    void do_fsm_main_cut_back_ramp_down(state_t* s)   // reverse movement: ramp down: deccel part + stop
;;;473    {
;;;474    	if (z_axis.current_pos > 0) {
;;;475    		MOTOR_Z_SetPulse();
;;;476    		--z_axis.current_pos;
;;;477    	}
;;;478    	if(z_axis_ramp_down()) {
;;;479    		z_axis_at_move_end(s);
;;;480    	}
;;;481    }
;;;482    
;;;483    
;;;484    
;;;485    
;;;486    
;;;487    
;;;488    
;;;489    
;;;490    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;491    {
;;;492    	MOTOR_Z_SetPulse();
;;;493    	--z_axis.current_pos;
;;;494    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
;;;495    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
;;;496    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
;;;497    		z_axis.current_pos += prolong_fixpart; // add fixed part
;;;498    		z_axis.end_pos += prolong_fixpart;
;;;499    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
;;;500    		// when long_press end, get back to 46 mode to proceed
;;;501    	}
;;;502    }
;;;503    
;;;504    void do_fsm_main_cut_wait_tacho(state_t* s)   // direct movement: set direction for motor
;;;505    {
;;;506    	if(feed_direction)
;;;507    		MOTOR_Z_Forward();
;;;508    	else
;;;509    		MOTOR_Z_Reverse();
;;;510    	s->function = do_fsm_main_cut_ramp_up; // intermediate state to wait tacho pulse
;;;511    	disable_encoder_ticks(); // reset interrupt for encoder ticks, only tacho
;;;512    }
;;;513    
;;;514    void do_fsm_main_cut(state_t* s)   // direct movement: ramp up: accel by ramp map
;;;515    {
;;;516    	MOTOR_Z_SetPulse();
;;;517    	z_axis.current_pos++;
;;;518    	if(z_axis_ramp_up()) {
;;;519    		LED_GPIO_Port->BSRR = LED_Pin;   // led off
;;;520    		s->function = do_fsm_main_cut_infeed;
;;;521    	}
;;;522    }
;;;523    
;;;524    
;;;525    void do_fsm_main_cut_infeed(state_t* s)   // direct movement: main part
;;;526    {
;;;527    	MOTOR_Z_SetPulse();
;;;528    	z_axis.current_pos++;
;;;529    	if( z_axis.current_pos < ( z_axis.end_pos - z_axis.ramp_step ) ) {
;;;530    		z_axis_move();
;;;531    	} else {
;;;532    		s->function = do_fsm_first_cut_ramp_down;
;;;533    	}
;;;534    }
;;;535    
;;;536    
;;;537    void do_fsm_wait_sclick(state_t* s)
;;;538    {
;;;539    	MOTOR_Z_Disable(); //disable motor
;;;540    }
;;;541    
;;;542    void do_fsm_main_cut_ramp_up(state_t* s)
;;;543    {
;;;544    	s->function = do_fsm_main_cut;
;;;545    	//reinit counter
;;;546    //                          TIM4->ARR = fixedpt_toint(Q824set) - 1;
;;;547    	LED_GPIO_Port->BRR = LED_Pin; //led on
;;;548    
;;;549    	if(infeed_step < infeed_steps) {
;;;550    		TIM4->ARR = infeed_map[infeed_step++] + 1; // start stepper motor with shifted position by infeed map
;;;551    	} else {
;;;552    		TIM4->ARR = 1;  // start stepper motor ramp up procedure immediately after tacho event
;;;553    	}
;;;554    	TIM4->EGR |= TIM_EGR_UG;
;;;555    
;;;556    	TIM4->CNT = 0;
;;;557    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;558    }
;;;559    
;;;560    
;;;561    
;;;562    //---------------------------------------------------------------------------------------------
;;;563    void do_fsm_move_start(state_t* s){
;;;564    	if(s->main_feed_direction == feed_direction && s->f_tacho ) { // if tacho event or we going to start back feed to initial position with async clock
;;;565    		if(s->main_feed_direction == feed_direction) {
;;;566    			s->function = do_fsm_ramp_up;
;;;567    			s->sync = true;
;;;568    			s->async_z = 0;
;;;569    			s->syncbase = TIM4; 									// sync with spindle
;;;570    
;;;571    			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
;;;572    			s->syncbase->EGR |= TIM_EGR_UG; // upload ARR value immediately 
;;;573    			s->syncbase->CNT = 0;						// reset counter
;;;574    //			LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH2);
;;;575    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
;;;576    		} else {
;;;577    
;;;578    			s->async_z = 1;
;;;579    //			s->syncbase = &htim2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;580    			s->function = do_fsm_ramp_up_async;
;;;581    
;;;582    		/* Enable counter */
;;;583    		LL_TIM_EnableCounter(TIM2);
;;;584    		/* Force update generation */
;;;585    		LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;586    
;;;587    //			LL_TIM_EnableIT_UPDATE(TIM2);
;;;588    		}
;;;589    
;;;590    	}	
;;;591    }
;;;592    
;;;593    void do_fsm_ramp_up(state_t* s)
;;;594    {
;;;595    	MOTOR_Z_SetPulse();
;;;596    	z_axis.current_pos++;
;;;597    	if(z_axis_ramp_up2(s)) {
;;;598    		s->function = do_fsm_move;
;;;599    	}
;;;600    }
;;;601    
;;;602    void do_fsm_move(state_t* s)
;;;603    {
;;;604    	MOTOR_Z_SetPulse();
;;;605    //	z_axis.current_pos++;
;;;606    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;607    //	else z_axis.current_pos--;
;;;608    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;609    		z_axis_move2(s);
;;;610    	} else {
;;;611    		if(z_axis_ramp_down2(s)) {
;;;612    			if(z_axis.end_pos != z_axis.current_pos) {
;;;613    				z_axis.end_pos = z_axis.current_pos;
;;;614    			}
;;;615    			s->function = do_fsm_move_end;
;;;616    		}
;;;617    		s->function = do_fsm_ramp_down;
;;;618    	}
;;;619    }
;;;620    
;;;621    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;622    {
;;;623    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;624    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;625    	// не перескакивая на соседние шаги при потере питания.
;;;626    	z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;627    	s->function = do_fsm_move;
;;;628    	do_fsm_move(s);
;;;629    }
;;;630    
;;;631    
;;;632    void do_fsm_ramp_down(state_t* s)
;;;633    {
;;;634    	MOTOR_Z_SetPulse();
;;;635    	if(s->spindle_dir)	z_axis.current_pos++;
;;;636    	else z_axis.current_pos--;
;;;637    	if(z_axis_ramp_down2(s)) {
;;;638    		if(z_axis.end_pos != z_axis.current_pos) {
;;;639    			z_axis.end_pos = z_axis.current_pos;
;;;640    		}
;;;641    		s->function = do_fsm_move_end;
;;;642    	}
;;;643    }
;;;644    
;;;645    void do_fsm_move_end(state_t* s){
;;;646    	s->async_z = 0;
;;;647    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;648    	if (s->sync) {
;;;649    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;650    	} else {
;;;651    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;652    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;653    	}
;;;654      MOTOR_Z_Disable(); 									//disable motor later on next tacho event (or after some ticks count?) to completely process last step
;;;655    	feed_direction = !feed_direction; 					//change feed direction
;;;656    	menu_changed = 1; 													//update menu
;;;657    	s->function = do_fsm_wait_sclick;
;;;658    
;;;659    	z_axis.current_pos = 0;
;;;660    }
;;;661    
;;;662    
;;;663    _Bool z_axis_ramp_up2(state_t* s)
;;;664    {
;;;665    	const fixedptu  set_with_fract = ramp[z_axis.ramp_step];
;;;666    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == ramp_map) { 	// reach desired speed or end of ramp map
;;;667    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;668    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;669    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;670    //		z_axis.end_minus_ramp_delta =
;;;671    		return true;
;;;672    	} else {
;;;673    		z_axis.ramp_step++;
;;;674    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;675    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;676    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;677    	}
;;;678    	return false;
;;;679    }
;;;680    
;;;681    _Bool z_axis_ramp_down2(state_t* s)
;;;682    {
        0x08002af8:    4601        .F      MOV      r1,r0
;;;683    	if (z_axis.ramp_step == 0)
        0x08002afa:    480f        .H      LDR      r0,[pc,#60] ; [0x8002b38] = 0x20000a38
        0x08002afc:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002b00:    b908        ..      CBNZ     r0,0x8002b06 ; z_axis_ramp_down2 + 14
;;;684    		return true;
        0x08002b02:    2001        .       MOVS     r0,#1
        0x08002b04:    4770        pG      BX       lr
;;;685    	const fixedptu set_with_fract = ramp[--z_axis.ramp_step];
        0x08002b06:    480c        .H      LDR      r0,[pc,#48] ; [0x8002b38] = 0x20000a38
        0x08002b08:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002b0c:    1e40        @.      SUBS     r0,r0,#1
        0x08002b0e:    b2c0        ..      UXTB     r0,r0
        0x08002b10:    4b09        .K      LDR      r3,[pc,#36] ; [0x8002b38] = 0x20000a38
        0x08002b12:    f8830028    ..(.    STRB     r0,[r3,#0x28]
        0x08002b16:    4b09        .K      LDR      r3,[pc,#36] ; [0x8002b3c] = 0x2000004c
        0x08002b18:    f8532020    S.      LDR      r2,[r3,r0,LSL #2]
;;;686    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
        0x08002b1c:    2001        .       MOVS     r0,#1
        0x08002b1e:    ebc06012    ...`    RSB      r0,r0,r2,LSR #24
        0x08002b22:    694b        Ki      LDR      r3,[r1,#0x14]
        0x08002b24:    62d8        .b      STR      r0,[r3,#0x2c]
;;;687    //	s->syncbase->EGR |= TIM_EGR_UG;
;;;688    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;689    	if(z_axis.ramp_step == 0)
        0x08002b26:    4804        .H      LDR      r0,[pc,#16] ; [0x8002b38] = 0x20000a38
        0x08002b28:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002b2c:    b908        ..      CBNZ     r0,0x8002b32 ; z_axis_ramp_down2 + 58
;;;690    		return true;
        0x08002b2e:    2001        .       MOVS     r0,#1
        0x08002b30:    e7e8        ..      B        0x8002b04 ; z_axis_ramp_down2 + 12
;;;691    	return false;
        0x08002b32:    2000        .       MOVS     r0,#0
        0x08002b34:    e7e6        ..      B        0x8002b04 ; z_axis_ramp_down2 + 12
    $d
        0x08002b36:    0000        ..      DCW    0
        0x08002b38:    20000a38    8..     DCD    536873528
        0x08002b3c:    2000004c    L..     DCD    536870988
    $t
    i.z_axis_ramp_up
    z_axis_ramp_up
;;; .\..\Src\fsm.c (163)
        0x08002b40:    481d        .H      LDR      r0,[pc,#116] ; [0x8002bb8] = 0x20000a38
        0x08002b42:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002b46:    4a1d        .J      LDR      r2,[pc,#116] ; [0x8002bbc] = 0x2000004c
        0x08002b48:    f8521020    R. .    LDR      r1,[r2,r0,LSL #2]
;;;164    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == ramp_map ) { // reach desired speed or end of ramp map
        0x08002b4c:    481a        .H      LDR      r0,[pc,#104] ; [0x8002bb8] = 0x20000a38
        0x08002b4e:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002b50:    4288        .B      CMP      r0,r1
        0x08002b52:    d804        ..      BHI      0x8002b5e ; z_axis_ramp_up + 30
        0x08002b54:    4818        .H      LDR      r0,[pc,#96] ; [0x8002bb8] = 0x20000a38
        0x08002b56:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002b5a:    2805        .(      CMP      r0,#5
        0x08002b5c:    d116        ..      BNE      0x8002b8c ; z_axis_ramp_up + 76
;;;165    		TIM4->ARR = fixedpt_toint(z_axis.Q824set) - 1; // update register ARR
        0x08002b5e:    4816        .H      LDR      r0,[pc,#88] ; [0x8002bb8] = 0x20000a38
        0x08002b60:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002b62:    2201        ."      MOVS     r2,#1
        0x08002b64:    ebc26010    ...`    RSB      r0,r2,r0,LSR #24
        0x08002b68:    4a15        .J      LDR      r2,[pc,#84] ; [0x8002bc0] = 0x4000082c
        0x08002b6a:    6010        .`      STR      r0,[r2,#0]
;;;166    		TIM4->EGR |= TIM_EGR_UG;
        0x08002b6c:    4814        .H      LDR      r0,[pc,#80] ; [0x8002bc0] = 0x4000082c
        0x08002b6e:    3818        .8      SUBS     r0,r0,#0x18
        0x08002b70:    6800        .h      LDR      r0,[r0,#0]
        0x08002b72:    f0400001    @...    ORR      r0,r0,#1
        0x08002b76:    4a12        .J      LDR      r2,[pc,#72] ; [0x8002bc0] = 0x4000082c
        0x08002b78:    3a18        .:      SUBS     r2,r2,#0x18
        0x08002b7a:    6010        .`      STR      r0,[r2,#0]
;;;167    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); // save fract part for future use on next step
        0x08002b7c:    480e        .H      LDR      r0,[pc,#56] ; [0x8002bb8] = 0x20000a38
        0x08002b7e:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002b80:    f020407f     ..@    BIC      r0,r0,#0xff000000
        0x08002b84:    4a0c        .J      LDR      r2,[pc,#48] ; [0x8002bb8] = 0x20000a38
        0x08002b86:    6110        .a      STR      r0,[r2,#0x10]
;;;168    		return true;
        0x08002b88:    2001        .       MOVS     r0,#1
        0x08002b8a:    4770        pG      BX       lr
;;;169    	} else {
;;;170    		z_axis.ramp_step++;
        0x08002b8c:    480a        .H      LDR      r0,[pc,#40] ; [0x8002bb8] = 0x20000a38
        0x08002b8e:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002b92:    1c40        @.      ADDS     r0,r0,#1
        0x08002b94:    4a08        .J      LDR      r2,[pc,#32] ; [0x8002bb8] = 0x20000a38
        0x08002b96:    f8820028    ..(.    STRB     r0,[r2,#0x28]
;;;171    		TIM4->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
        0x08002b9a:    2001        .       MOVS     r0,#1
        0x08002b9c:    ebc06011    ...`    RSB      r0,r0,r1,LSR #24
        0x08002ba0:    4a07        .J      LDR      r2,[pc,#28] ; [0x8002bc0] = 0x4000082c
        0x08002ba2:    6010        .`      STR      r0,[r2,#0]
;;;172    		TIM4->EGR |= TIM_EGR_UG;
        0x08002ba4:    4806        .H      LDR      r0,[pc,#24] ; [0x8002bc0] = 0x4000082c
        0x08002ba6:    3818        .8      SUBS     r0,r0,#0x18
        0x08002ba8:    6800        .h      LDR      r0,[r0,#0]
        0x08002baa:    f0400001    @...    ORR      r0,r0,#1
        0x08002bae:    4a04        .J      LDR      r2,[pc,#16] ; [0x8002bc0] = 0x4000082c
        0x08002bb0:    3a18        .:      SUBS     r2,r2,#0x18
        0x08002bb2:    6010        .`      STR      r0,[r2,#0]
;;;173    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;174    	}
;;;175    	return false;
        0x08002bb4:    2000        .       MOVS     r0,#0
        0x08002bb6:    e7e8        ..      B        0x8002b8a ; z_axis_ramp_up + 74
    $d
        0x08002bb8:    20000a38    8..     DCD    536873528
        0x08002bbc:    2000004c    L..     DCD    536870988
        0x08002bc0:    4000082c    ,..@    DCD    1073743916
    $t
    i.z_axis_ramp_up2
    z_axis_ramp_up2
;;;176    }
;;;177    
;;;178    _Bool z_axis_ramp_down(void)
;;;179    {
;;;180    	if (z_axis.ramp_step == 0)
;;;181    		return true;
;;;182    	const fixedptu set_with_fract = ramp[--z_axis.ramp_step];
;;;183    	TIM4->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;184    	TIM4->EGR |= TIM_EGR_UG;
;;;185    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;186    	if(z_axis.ramp_step == 0)
;;;187    		return true;
;;;188    	return false;
;;;189    }
;;;190    
;;;191    void z_axis_move(void)
;;;192    {
;;;193    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;194    	TIM4->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;195    	TIM4->EGR |= TIM_EGR_UG;
;;;196    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;197    }
;;;198    
;;;199    
;;;200    void z_axis_at_move_end(state_t* s)
;;;201    {
;;;202    	disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
;;;203    	//      MOTOR_Z_Disable(); //disable motor later on next tacho event (or after some ticks count?) to completely process last step
;;;204    //	if(auto_mode == true)    auto_mode_delay = auto_mode_delay_ms; // reengage auto mode
;;;205    	feed_direction = !feed_direction; //change feed direction
;;;206    	menu_changed = 1; //update menu
;;;207    	s->function = do_fsm_wait_sclick;
;;;208    //	z_axis.mode = fsm_wait_sclick; // dummy mode
;;;209    }
;;;210    
;;;211    
;;;212    
;;;213    
;;;214    void do_fsm_wait_tacho(state_t* s)
;;;215    {
;;;216    	if(s->f_tacho) { // if tacho event
;;;217    		s->function = do_fsm_first_cut_ramp_up;
;;;218    //		infeed_step = 0; todo
;;;219    		LED_GPIO_Port->BRR = LED_Pin; //led on
;;;220    		TIM4->ARR = 1; // start stepper motor ramp up procedure immediately after tacho event
;;;221    		TIM4->EGR |= TIM_EGR_UG;
;;;222    		TIM4->CNT = 0;
;;;223    		enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;224    	}
;;;225    }
;;;226    
;;;227    void do_fsm_menu(state_t* s)
;;;228    {
;;;229    	uint8_t level = Thread_Info[Menu_Step].level;
;;;230    	buttons_flag_set = long_press_start_Msk;
;;;231    	switch(buttons_flag_set) {
;;;232    	case single_click_Msk3: {
;;;233    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;234    		menu_changed = 1;
;;;235    		break;
;;;236    	}
;;;237    	case single_click_Msk2: {
;;;238    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;239    		menu_changed = 1;
;;;240    		break;
;;;241    	}
;;;242    	case single_click_Msk: {
;;;243    		if(z_axis.end_pos != 0) {
;;;244    
;;;245    			// first pass of thread cut was complete, so just use single click
;;;246    			//	to switch between modes to process all other cuts
;;;247    			MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;248    			for(unsigned int i=0; i<(72*1700/16); i++); // wait 1700us delay to wakeup motor driver
;;;249    			s->function = z_axis.current_pos > 0 ? do_fsm_sclick_event : do_fsm_main_cut_wait_tacho;
;;;250    		} else { // controller in initial state, scroll menu
;;;251    			s->function = do_fsm_menu_lps;
;;;252    			for (int a = Menu_Step+1; a<Menu_size; a++) {
;;;253    				if(Thread_Info[a].level == level) {
;;;254    					Menu_Step = a;
;;;255    					menu_changed = 1;
;;;256    					break;
;;;257    				}
;;;258    			}
;;;259    			if(menu_changed != 1) {
;;;260    				for (int a = 0; a<Menu_Step; a++) {
;;;261    					if(Thread_Info[a].level == level) {
;;;262    						Menu_Step = a;
;;;263    						menu_changed = 1;
;;;264    						break;
;;;265    					}
;;;266    				}
;;;267    			}
;;;268    		}
;;;269    		break;
;;;270    	}
;;;271    	case double_click_Msk: {
;;;272    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;273    		menu_changed = 1;
;;;274    		break;
;;;275    	}
;;;276    	case (long_press_start_Msk | long_press_start_Msk2): { // two buttons long pressed same time
;;;277    		// todo check if it work
;;;278    		break;
;;;279    	}
;;;280    	case long_press_start_Msk: {
;;;281    		if(s->function == do_fsm_menu_lps){
;;;282    			if(Thread_Info[Menu_Step].Q824 != 0) { // long press detected, start new thread from current position
;;;283    				//mode 20:
;;;284    				disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
;;;285    				MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;286    				s->main_feed_direction = feed_direction; // save main feed direction, where cut is on
;;;287    				s->sync = true;
;;;288    				if( feed_direction == feed_direction_right )
;;;289    					MOTOR_Z_Forward();
;;;290    				else
;;;291    					MOTOR_Z_Reverse();
;;;292    				
;;;293    				for(unsigned int i=0; i<(72*1700/16); i++); // wait 1700us delay to wakeup motor driver todo dumb method
;;;294    
;;;295    				z_axis.Q824set = Thread_Info[Menu_Step].Q824;
;;;296    				z_axis.end_pos = z_axis.current_pos = 0;
;;;297    
;;;298    				const uint64_t upl = (uint64_t)3600 << 48; //calculate some constants for prolong mode
;;;299    				z_axis.prolong_addSteps = upl / (fixedptud)z_axis.Q824set;
;;;300    
;;;301    				s->function = do_fsm_move_start;//do_fsm_wait_tacho; // go straight to 24 to wait tacho
;;;302    //do_fsm_move_start
;;;303    			} else { // goto submenu
;;;304    				for (int a = 0; a<Menu_size; a++) {
;;;305    					if(Thread_Info[a].level == Thread_Info[Menu_Step].submenu) {
;;;306    						Menu_Step = a;
;;;307    						menu_changed = 1;
;;;308    						break;
;;;309    					}
;;;310    				}
;;;311    			}
;;;312    		} else if(s->function == do_fsm_main_cut_back){
;;;313    			s->function = do_fsm_main_cut_back_prolong; // go to 48 mode to add threads until long_press end
;;;314    		}
;;;315    		break;
;;;316    	}
;;;317    	case long_press_end_Msk: {
;;;318    		s->function = do_long_press_end_callback;
;;;319    		break;
;;;320    /*
;;;321    		if(s->function == do_fsm_first_cut_main_part){
;;;322    			s->function = do_fsm_first_cut_lpe;
;;;323    			break;
;;;324    		}
;;;325    		if(s->function == do_fsm_main_cut_back_prolong){ // end of prolonged mode
;;;326    			s->function = do_fsm_main_cut_back;
;;;327    			break;
;;;328    		}
;;;329    */
;;;330    		/*
;;;331    		switch(z_axis.mode) {
;;;332    		case fsm_first_cut_main_part: {
;;;333    //																					if(auto_mode == true){
;;;334    //																									auto_mode_delay = auto_mode_delay_ms; //engage countdown timer to auto generate click event
;;;335    //																					}
;;;336    //																					Q824count = 0;
;;;337    			s->function = do_fsm_first_cut_lpe;
;;;338    			break;
;;;339    		}
;;;340    		case fsm_main_cut_back_prolong: { // end of prolonged mode
;;;341    			s->function = do_fsm_main_cut_back;
;;;342    			break;
;;;343    		}
;;;344    		}
;;;345    		*/
;;;346    		break;
;;;347    	}
;;;348    	}
;;;349    }
;;;350    
;;;351    void do_fsm_menu_lps(state_t* s)
;;;352    {
;;;353    }
;;;354    
;;;355    
;;;356    
;;;357    void do_fsm_first_cut_lps(state_t* s)  // not used?
;;;358    {
;;;359    	
;;;360    	disable_encoder_ticks(); //reset interrupt for encoder ticks, only tacho
;;;361    	MOTOR_Z_Enable();
;;;362    	if(feed_direction)
;;;363    		MOTOR_Z_Forward();
;;;364    	else
;;;365    		MOTOR_Z_Reverse();
;;;366    	s->function = do_fsm_wait_tacho; //intermediate state to wait tacho pulse.
;;;367    }
;;;368    
;;;369    
;;;370    
;;;371    
;;;372    
;;;373    
;;;374    void do_fsm_first_cut_ramp_up(state_t* s)          // direct movement: first pass, thread recording: ramp up: accel by ramp map
;;;375    {
;;;376    	MOTOR_Z_SetPulse();
;;;377    	z_axis.current_pos++;
;;;378    	if(z_axis_ramp_up()) {
;;;379    		s->function = do_fsm_first_cut_main_part;
;;;380    		LED_GPIO_Port->BSRR = LED_Pin; //led off
;;;381    	}
;;;382    }
;;;383    
;;;384    
;;;385    void do_fsm_first_cut_main_part(state_t* s)          // direct movement: first pass, thread recording: main part
;;;386    {
;;;387    	MOTOR_Z_SetPulse();
;;;388    	z_axis.current_pos++;
;;;389    	z_axis_move();
;;;390    }
;;;391    
;;;392    
;;;393    void do_fsm_first_cut_lpe(state_t* s)          // direct movement: first pass, thread recording: post-main part
;;;394    {
;;;395    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;396    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;397    	// не перескакивая на соседние шаги при потере питания.
;;;398    	// поэтому проверяем общее количество на четность(0й бит), если нечетное число делаем еще один шаг,
;;;399    	// иначе начинаем замедляться
;;;400    	MOTOR_Z_SetPulse();
;;;401    	z_axis.current_pos++;
;;;402    	uint32_t all_count = z_axis.ramp_step + z_axis.current_pos - 1;
;;;403    	uint32_t masked_count = all_count & ~(step_divider - 1);
;;;404    	if(masked_count != all_count) {
;;;405    		z_axis_move();
;;;406    	} else {
;;;407    		if(z_axis_ramp_down()) {
;;;408    			z_axis.end_pos = z_axis.current_pos;
;;;409    			z_axis_at_move_end(s);
;;;410    		} else {
;;;411    			s->function = do_fsm_first_cut_ramp_down;
;;;412    		}
;;;413    	}
;;;414    }
;;;415    
;;;416    
;;;417    
;;;418    
;;;419    
;;;420    
;;;421    void do_fsm_first_cut_ramp_down(state_t* s)          // direct movement: ramp down: deccel part + stop
;;;422    {
;;;423    	MOTOR_Z_SetPulse();
;;;424    	z_axis.current_pos++;
;;;425    	if(z_axis_ramp_down()) {
;;;426    		z_axis.end_pos = z_axis.current_pos;
;;;427    		z_axis_at_move_end(s);
;;;428    	}
;;;429    }
;;;430    
;;;431    
;;;432    
;;;433    void do_fsm_sclick_event(state_t* s)   // reverse movement: set direction for motor
;;;434    {
;;;435    	if(feed_direction)
;;;436    		MOTOR_Z_Forward();
;;;437    	else
;;;438    		MOTOR_Z_Reverse();
;;;439    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;440    	s->function = do_fsm_main_cut_back_ramp_up;
;;;441    }
;;;442    
;;;443    
;;;444    
;;;445    
;;;446    
;;;447    void do_fsm_main_cut_back_ramp_up(state_t* s)          // reverse movement: ramp up: accel part
;;;448    {
;;;449    	MOTOR_Z_SetPulse();
;;;450    	--z_axis.current_pos;
;;;451    	if(z_axis_ramp_up())
;;;452    		s->function = do_fsm_main_cut_back;
;;;453    }
;;;454    
;;;455    
;;;456    
;;;457    
;;;458    
;;;459    
;;;460    
;;;461    void do_fsm_main_cut_back(state_t* s)          // reverse movement: main part
;;;462    {
;;;463    	MOTOR_Z_SetPulse();
;;;464    	if( --z_axis.current_pos > z_axis.ramp_step ) {
;;;465    	} else {
;;;466    		s->function = do_fsm_main_cut_back_ramp_down;
;;;467    	}
;;;468    }
;;;469    
;;;470    
;;;471    
;;;472    void do_fsm_main_cut_back_ramp_down(state_t* s)   // reverse movement: ramp down: deccel part + stop
;;;473    {
;;;474    	if (z_axis.current_pos > 0) {
;;;475    		MOTOR_Z_SetPulse();
;;;476    		--z_axis.current_pos;
;;;477    	}
;;;478    	if(z_axis_ramp_down()) {
;;;479    		z_axis_at_move_end(s);
;;;480    	}
;;;481    }
;;;482    
;;;483    
;;;484    
;;;485    
;;;486    
;;;487    
;;;488    
;;;489    
;;;490    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;491    {
;;;492    	MOTOR_Z_SetPulse();
;;;493    	--z_axis.current_pos;
;;;494    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
;;;495    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
;;;496    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
;;;497    		z_axis.current_pos += prolong_fixpart; // add fixed part
;;;498    		z_axis.end_pos += prolong_fixpart;
;;;499    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
;;;500    		// when long_press end, get back to 46 mode to proceed
;;;501    	}
;;;502    }
;;;503    
;;;504    void do_fsm_main_cut_wait_tacho(state_t* s)   // direct movement: set direction for motor
;;;505    {
;;;506    	if(feed_direction)
;;;507    		MOTOR_Z_Forward();
;;;508    	else
;;;509    		MOTOR_Z_Reverse();
;;;510    	s->function = do_fsm_main_cut_ramp_up; // intermediate state to wait tacho pulse
;;;511    	disable_encoder_ticks(); // reset interrupt for encoder ticks, only tacho
;;;512    }
;;;513    
;;;514    void do_fsm_main_cut(state_t* s)   // direct movement: ramp up: accel by ramp map
;;;515    {
;;;516    	MOTOR_Z_SetPulse();
;;;517    	z_axis.current_pos++;
;;;518    	if(z_axis_ramp_up()) {
;;;519    		LED_GPIO_Port->BSRR = LED_Pin;   // led off
;;;520    		s->function = do_fsm_main_cut_infeed;
;;;521    	}
;;;522    }
;;;523    
;;;524    
;;;525    void do_fsm_main_cut_infeed(state_t* s)   // direct movement: main part
;;;526    {
;;;527    	MOTOR_Z_SetPulse();
;;;528    	z_axis.current_pos++;
;;;529    	if( z_axis.current_pos < ( z_axis.end_pos - z_axis.ramp_step ) ) {
;;;530    		z_axis_move();
;;;531    	} else {
;;;532    		s->function = do_fsm_first_cut_ramp_down;
;;;533    	}
;;;534    }
;;;535    
;;;536    
;;;537    void do_fsm_wait_sclick(state_t* s)
;;;538    {
;;;539    	MOTOR_Z_Disable(); //disable motor
;;;540    }
;;;541    
;;;542    void do_fsm_main_cut_ramp_up(state_t* s)
;;;543    {
;;;544    	s->function = do_fsm_main_cut;
;;;545    	//reinit counter
;;;546    //                          TIM4->ARR = fixedpt_toint(Q824set) - 1;
;;;547    	LED_GPIO_Port->BRR = LED_Pin; //led on
;;;548    
;;;549    	if(infeed_step < infeed_steps) {
;;;550    		TIM4->ARR = infeed_map[infeed_step++] + 1; // start stepper motor with shifted position by infeed map
;;;551    	} else {
;;;552    		TIM4->ARR = 1;  // start stepper motor ramp up procedure immediately after tacho event
;;;553    	}
;;;554    	TIM4->EGR |= TIM_EGR_UG;
;;;555    
;;;556    	TIM4->CNT = 0;
;;;557    	enable_encoder_ticks(); // enable thread specific interrupt controlled by Q824set
;;;558    }
;;;559    
;;;560    
;;;561    
;;;562    //---------------------------------------------------------------------------------------------
;;;563    void do_fsm_move_start(state_t* s){
;;;564    	if(s->main_feed_direction == feed_direction && s->f_tacho ) { // if tacho event or we going to start back feed to initial position with async clock
;;;565    		if(s->main_feed_direction == feed_direction) {
;;;566    			s->function = do_fsm_ramp_up;
;;;567    			s->sync = true;
;;;568    			s->async_z = 0;
;;;569    			s->syncbase = TIM4; 									// sync with spindle
;;;570    
;;;571    			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
;;;572    			s->syncbase->EGR |= TIM_EGR_UG; // upload ARR value immediately 
;;;573    			s->syncbase->CNT = 0;						// reset counter
;;;574    //			LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH2);
;;;575    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
;;;576    		} else {
;;;577    
;;;578    			s->async_z = 1;
;;;579    //			s->syncbase = &htim2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;580    			s->function = do_fsm_ramp_up_async;
;;;581    
;;;582    		/* Enable counter */
;;;583    		LL_TIM_EnableCounter(TIM2);
;;;584    		/* Force update generation */
;;;585    		LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;586    
;;;587    //			LL_TIM_EnableIT_UPDATE(TIM2);
;;;588    		}
;;;589    
;;;590    	}	
;;;591    }
;;;592    
;;;593    void do_fsm_ramp_up(state_t* s)
;;;594    {
;;;595    	MOTOR_Z_SetPulse();
;;;596    	z_axis.current_pos++;
;;;597    	if(z_axis_ramp_up2(s)) {
;;;598    		s->function = do_fsm_move;
;;;599    	}
;;;600    }
;;;601    
;;;602    void do_fsm_move(state_t* s)
;;;603    {
;;;604    	MOTOR_Z_SetPulse();
;;;605    //	z_axis.current_pos++;
;;;606    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;607    //	else z_axis.current_pos--;
;;;608    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;609    		z_axis_move2(s);
;;;610    	} else {
;;;611    		if(z_axis_ramp_down2(s)) {
;;;612    			if(z_axis.end_pos != z_axis.current_pos) {
;;;613    				z_axis.end_pos = z_axis.current_pos;
;;;614    			}
;;;615    			s->function = do_fsm_move_end;
;;;616    		}
;;;617    		s->function = do_fsm_ramp_down;
;;;618    	}
;;;619    }
;;;620    
;;;621    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;622    {
;;;623    	// для 1/2 микрошага нужно что бы общее количество шагов в цикле резьбы было кратно 2,(для 1/4 кратно 4 и тп).
;;;624    	// это нужно для того что бы в конце шаговый мотор остановился на одном из двухсот устойчивых шагов,
;;;625    	// не перескакивая на соседние шаги при потере питания.
;;;626    	z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;627    	s->function = do_fsm_move;
;;;628    	do_fsm_move(s);
;;;629    }
;;;630    
;;;631    
;;;632    void do_fsm_ramp_down(state_t* s)
;;;633    {
;;;634    	MOTOR_Z_SetPulse();
;;;635    	if(s->spindle_dir)	z_axis.current_pos++;
;;;636    	else z_axis.current_pos--;
;;;637    	if(z_axis_ramp_down2(s)) {
;;;638    		if(z_axis.end_pos != z_axis.current_pos) {
;;;639    			z_axis.end_pos = z_axis.current_pos;
;;;640    		}
;;;641    		s->function = do_fsm_move_end;
;;;642    	}
;;;643    }
;;;644    
;;;645    void do_fsm_move_end(state_t* s){
;;;646    	s->async_z = 0;
;;;647    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;648    	if (s->sync) {
;;;649    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;650    	} else {
;;;651    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;652    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;653    	}
;;;654      MOTOR_Z_Disable(); 									//disable motor later on next tacho event (or after some ticks count?) to completely process last step
;;;655    	feed_direction = !feed_direction; 					//change feed direction
;;;656    	menu_changed = 1; 													//update menu
;;;657    	s->function = do_fsm_wait_sclick;
;;;658    
;;;659    	z_axis.current_pos = 0;
;;;660    }
;;;661    
;;;662    
;;;663    _Bool z_axis_ramp_up2(state_t* s)
;;;664    {
        0x08002bc4:    4601        .F      MOV      r1,r0
;;;665    	const fixedptu  set_with_fract = ramp[z_axis.ramp_step];
        0x08002bc6:    4816        .H      LDR      r0,[pc,#88] ; [0x8002c20] = 0x20000a38
        0x08002bc8:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002bcc:    4b15        .K      LDR      r3,[pc,#84] ; [0x8002c24] = 0x2000004c
        0x08002bce:    f8532020    S.      LDR      r2,[r3,r0,LSL #2]
;;;666    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == ramp_map) { 	// reach desired speed or end of ramp map
        0x08002bd2:    4813        .H      LDR      r0,[pc,#76] ; [0x8002c20] = 0x20000a38
        0x08002bd4:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002bd6:    4290        .B      CMP      r0,r2
        0x08002bd8:    d804        ..      BHI      0x8002be4 ; z_axis_ramp_up2 + 32
        0x08002bda:    4811        .H      LDR      r0,[pc,#68] ; [0x8002c20] = 0x20000a38
        0x08002bdc:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002be0:    2805        .(      CMP      r0,#5
        0x08002be2:    d10e        ..      BNE      0x8002c02 ; z_axis_ramp_up2 + 62
;;;667    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
        0x08002be4:    480e        .H      LDR      r0,[pc,#56] ; [0x8002c20] = 0x20000a38
        0x08002be6:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002be8:    2301        .#      MOVS     r3,#1
        0x08002bea:    ebc36010    ...`    RSB      r0,r3,r0,LSR #24
        0x08002bee:    694b        Ki      LDR      r3,[r1,#0x14]
        0x08002bf0:    62d8        .b      STR      r0,[r3,#0x2c]
;;;668    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;669    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
        0x08002bf2:    480b        .H      LDR      r0,[pc,#44] ; [0x8002c20] = 0x20000a38
        0x08002bf4:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002bf6:    f020407f     ..@    BIC      r0,r0,#0xff000000
        0x08002bfa:    4b09        .K      LDR      r3,[pc,#36] ; [0x8002c20] = 0x20000a38
        0x08002bfc:    6118        .a      STR      r0,[r3,#0x10]
;;;670    //		z_axis.end_minus_ramp_delta =
;;;671    		return true;
        0x08002bfe:    2001        .       MOVS     r0,#1
        0x08002c00:    4770        pG      BX       lr
;;;672    	} else {
;;;673    		z_axis.ramp_step++;
        0x08002c02:    4807        .H      LDR      r0,[pc,#28] ; [0x8002c20] = 0x20000a38
        0x08002c04:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002c08:    1c40        @.      ADDS     r0,r0,#1
        0x08002c0a:    4b05        .K      LDR      r3,[pc,#20] ; [0x8002c20] = 0x20000a38
        0x08002c0c:    f8830028    ..(.    STRB     r0,[r3,#0x28]
;;;674    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
        0x08002c10:    2001        .       MOVS     r0,#1
        0x08002c12:    ebc06012    ...`    RSB      r0,r0,r2,LSR #24
        0x08002c16:    694b        Ki      LDR      r3,[r1,#0x14]
        0x08002c18:    62d8        .b      STR      r0,[r3,#0x2c]
;;;675    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;676    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;677    	}
;;;678    	return false;
        0x08002c1a:    2000        .       MOVS     r0,#0
        0x08002c1c:    e7f0        ..      B        0x8002c00 ; z_axis_ramp_up2 + 60
    $d
        0x08002c1e:    0000        ..      DCW    0
        0x08002c20:    20000a38    8..     DCD    536873528
        0x08002c24:    2000004c    L..     DCD    536870988
    $d.realdata
    .constdata
    AHBPrescTable
        0x08002c28:    00000000    ....    DCD    0
        0x08002c2c:    00000000    ....    DCD    0
        0x08002c30:    04030201    ....    DCD    67305985
        0x08002c34:    09080706    ....    DCD    151521030
    APBPrescTable
        0x08002c38:    00000000    ....    DCD    0
        0x08002c3c:    04030201    ....    DCD    67305985
    .constdata
    CHANNEL_OFFSET_TAB
        0x08002c40:    44301c08    ..0D    DCD    1144003592
        0x08002c44:    6c58        Xl      DCW    27736
        0x08002c46:    80          .       DCB    128
    OFFSET_TAB_CCMRx
        0x08002c47:    00          .       DCB    0
        0x08002c48:    04000000    ....    DCD    67108864
        0x08002c4c:    0404        ..      DCW    1028
    SHIFT_TAB_OCxx
        0x08002c4e:    0000        ..      DCW    0
        0x08002c50:    00000008    ....    DCD    8
        0x08002c54:    08          .       DCB    8
    SHIFT_TAB_ICxx
        0x08002c55:    000008      ...     DCB    0,0,8
        0x08002c58:    08000000    ....    DCD    134217728
    SHIFT_TAB_CCxP
        0x08002c5c:    06040200    ....    DCD    100925952
        0x08002c60:    0a08        ..      DCW    2568
        0x08002c62:    0c          .       DCB    12
    SHIFT_TAB_OISx
        0x08002c63:    00          .       DCB    0
        0x08002c64:    04030201    ....    DCD    67305985
        0x08002c68:    0605        ..      DCW    1541
    microsoftSansSerif_12ptBitmaps
        0x08002c6a:    0800        ..      DCW    2048
        0x08002c6c:    010106f8    ....    DCD    16844536
        0x08002c70:    01f80601    ....    DCD    33031681
        0x08002c74:    08080806    ....    DCD    134744070
        0x08002c78:    02020106    ....    DCD    33685766
        0x08002c7c:    0f0000ff    ....    DCD    251658495
        0x08002c80:    81010204    ....    DCD    2164326916
        0x08002c84:    0c1c2241    A"..    DCD    203170369
        0x08002c88:    0808090a    ....    DCD    134744330
        0x08002c8c:    02040808    ....    DCD    33818632
        0x08002c90:    52212101    .!!R    DCD    1377902849
        0x08002c94:    0804028c    ....    DCD    134480524
        0x08002c98:    03040808    ....    DCD    50595848
        0x08002c9c:    08304080    .@0.    DCD    137379968
        0x08002ca0:    0100ff06    ....    DCD    16842502
        0x08002ca4:    01010101    ....    DCD    16843009
        0x08002ca8:    213f010f    ..?!    DCD    557777167
        0x08002cac:    21111111    ...!    DCD    554766609
        0x08002cb0:    080402c1    ....    DCD    134480577
        0x08002cb4:    03040808    ....    DCD    50595848
        0x08002cb8:    111122fc    ."..    DCD    286335740
        0x08002cbc:    03c42211    ."..    DCD    63185425
        0x08002cc0:    08080804    ....    DCD    134744068
        0x08002cc4:    01010304    ....    DCD    16843524
        0x08002cc8:    39c10101    ...9    DCD    968950017
        0x08002ccc:    00000007    ....    DCD    7
        0x08002cd0:    0000010e    ....    DCD    270
        0x08002cd4:    2121528c    .R!!    DCD    555831948
        0x08002cd8:    038c5221    !R..    DCD    59527713
        0x08002cdc:    08080804    ....    DCD    134744068
        0x08002ce0:    423c0304    ..<B    DCD    1111229188
        0x08002ce4:    42818181    ...B    DCD    1115783553
        0x08002ce8:    080402fc    ....    DCD    134480636
        0x08002cec:    03040808    ....    DCD    50595848
        0x08002cf0:    b0c00000    ....    DCD    2965372928
        0x08002cf4:    b08c838c    ....    DCD    2961998732
        0x08002cf8:    0c0000c0    ....    DCD    201326784
        0x08002cfc:    00000003    ....    DCD    3
        0x08002d00:    00000000    ....    DCD    0
        0x08002d04:    21ff0c03    ...!    DCD    570362883
        0x08002d08:    21212121    !!!!    DCD    555819297
        0x08002d0c:    080f8c52    R...    DCD    135236690
        0x08002d10:    08080808    ....    DCD    134744072
        0x08002d14:    06f80304    ....    DCD    116916996
        0x08002d18:    01010102    ....    DCD    16843010
        0x08002d1c:    08060201    ....    DCD    134611457
        0x08002d20:    08040601    ....    DCD    134481409
        0x08002d24:    04080808    ....    DCD    67635208
        0x08002d28:    01ff0106    ....    DCD    33489158
        0x08002d2c:    01010101    ....    DCD    16843009
        0x08002d30:    0ff80602    ....    DCD    267912706
        0x08002d34:    08080808    ....    DCD    134744072
        0x08002d38:    01060408    ....    DCD    17171464
        0x08002d3c:    212121ff    .!!!    DCD    555819519
        0x08002d40:    01212121    !!!.    DCD    18948385
        0x08002d44:    0808080f    ....    DCD    134744079
        0x08002d48:    08080808    ....    DCD    134744072
        0x08002d4c:    212121ff    .!!!    DCD    555819519
        0x08002d50:    01212121    !!!.    DCD    18948385
        0x08002d54:    0000000f    ....    DCD    15
        0x08002d58:    00000000    ....    DCD    0
        0x08002d5c:    010206f8    ....    DCD    16910072
        0x08002d60:    42410101    ..AB    DCD    1111556353
        0x08002d64:    0601c846    F...    DCD    100780102
        0x08002d68:    08080804    ....    DCD    134744068
        0x08002d6c:    0f060408    ....    DCD    252052488
        0x08002d70:    202020ff    .       DCD    538976511
        0x08002d74:    ff202020       .    DCD    4280295456
        0x08002d78:    0000000f    ....    DCD    15
        0x08002d7c:    0f000000    ....    DCD    251658240
        0x08002d80:    00000fff    ....    DCD    4095
        0x08002d84:    ff000000    ....    DCD    4278190080
        0x08002d88:    08080807    ....    DCD    134744071
        0x08002d8c:    20ff0708    ...     DCD    553584392
        0x08002d90:    02048850    P...    DCD    33851472
        0x08002d94:    000f0001    ....    DCD    983041
        0x08002d98:    02010000    ....    DCD    33619968
        0x08002d9c:    00ff0804    ....    DCD    16713732
        0x08002da0:    00000000    ....    DCD    0
        0x08002da4:    08080f00    ....    DCD    134745856
        0x08002da8:    08080808    ....    DCD    134744072
        0x08002dac:    c0300cff    ..0.    DCD    3224374527
        0x08002db0:    0c30c000    ..0.    DCD    204521472
        0x08002db4:    00000fff    ....    DCD    4095
        0x08002db8:    00000300    ....    DCD    768
        0x08002dbc:    06ff0f00    ....    DCD    117378816
        0x08002dc0:    00806018    .`..    DCD    8413208
        0x08002dc4:    00000fff    ....    DCD    4095
        0x08002dc8:    0f060100    ....    DCD    252051712
        0x08002dcc:    010206f8    ....    DCD    16910072
        0x08002dd0:    02010101    ....    DCD    33620225
        0x08002dd4:    0601f806    ....    DCD    100792326
        0x08002dd8:    08080804    ....    DCD    134744068
        0x08002ddc:    01060408    ....    DCD    17171464
        0x08002de0:    414141ff    .AAA    DCD    1094795775
        0x08002de4:    1c224141    AA".    DCD    472006977
        0x08002de8:    0000000f    ....    DCD    15
        0x08002dec:    00000000    ....    DCD    0
        0x08002df0:    010206f8    ....    DCD    16910072
        0x08002df4:    02010101    ....    DCD    33620225
        0x08002df8:    0601f806    ....    DCD    100792326
        0x08002dfc:    09080804    ....    DCD    151521284
        0x08002e00:    110e040a    ....    DCD    286131210
        0x08002e04:    414141ff    .AAA    DCD    1094795775
        0x08002e08:    1ca24141    AA..    DCD    480395585
        0x08002e0c:    00000f00    ....    DCD    3840
        0x08002e10:    00000000    ....    DCD    0
        0x08002e14:    120c0807    ....    DCD    302778375
        0x08002e18:    21212121    !!!!    DCD    555819297
        0x08002e1c:    02844221    !B..    DCD    42222113
        0x08002e20:    08080804    ....    DCD    134744068
        0x08002e24:    03040808    ....    DCD    50595848
        0x08002e28:    01010101    ....    DCD    16843009
        0x08002e2c:    010101ff    ....    DCD    16843263
        0x08002e30:    00000001    ....    DCD    1
        0x08002e34:    00000f00    ....    DCD    3840
        0x08002e38:    00ff0000    ....    DCD    16711680
        0x08002e3c:    00000000    ....    DCD    0
        0x08002e40:    0403ff00    ....    DCD    67370752
        0x08002e44:    08080808    ....    DCD    134744072
        0x08002e48:    0c030304    ....    DCD    201523972
        0x08002e4c:    0000c030    0...    DCD    49200
        0x08002e50:    0c30c000    ..0.    DCD    204521472
        0x08002e54:    00000003    ....    DCD    3
        0x08002e58:    030c0300    ....    DCD    51118848
        0x08002e5c:    00000000    ....    DCD    0
        0x08002e60:    80601c03    ..`.    DCD    2153782275
        0x08002e64:    0e708000    ..p.    DCD    242253824
        0x08002e68:    80008070    p...    DCD    2147516528
        0x08002e6c:    00031c60    `...    DCD    203872
        0x08002e70:    0e010000    ....    DCD    234946560
        0x08002e74:    00000001    ....    DCD    1
        0x08002e78:    00010e01    ....    DCD    69121
        0x08002e7c:    02010000    ....    DCD    33619968
        0x08002e80:    60900804    ...`    DCD    1620051972
        0x08002e84:    02040890    ....    DCD    33818768
        0x08002e88:    02040801    ....    DCD    33818625
        0x08002e8c:    00000001    ....    DCD    1
        0x08002e90:    08040201    ....    DCD    134480385
        0x08002e94:    08040201    ....    DCD    134480385
        0x08002e98:    0810e010    ....    DCD    135323664
        0x08002e9c:    00010204    ....    DCD    66052
        0x08002ea0:    00000000    ....    DCD    0
        0x08002ea4:    0000000f    ....    DCD    15
        0x08002ea8:    01010000    ....    DCD    16842752
        0x08002eac:    19214181    .A!.    DCD    421609857
        0x08002eb0:    0a0c0305    ....    DCD    168559365
        0x08002eb4:    08080809    ....    DCD    134744073
        0x08002eb8:    88100808    ....    DCD    2282752008
        0x08002ebc:    88888888    ....    DCD    2290649224
        0x08002ec0:    080700f0    ....    DCD    134676720
        0x08002ec4:    08080808    ....    DCD    134744072
        0x08002ec8:    10ff0807    ....    DCD    285149191
        0x08002ecc:    10080808    ....    DCD    268961800
        0x08002ed0:    08040fe0    ....    DCD    134483936
        0x08002ed4:    03040808    ....    DCD    50595848
        0x08002ed8:    080810e0    ....    DCD    134746336
        0x08002edc:    03201008    .. .    DCD    52432904
        0x08002ee0:    08080804    ....    DCD    134744068
        0x08002ee4:    10e00204    ....    DCD    283116036
        0x08002ee8:    10080808    ....    DCD    268961800
        0x08002eec:    080403ff    ....    DCD    134480895
        0x08002ef0:    0f040808    ....    DCD    251922440
        0x08002ef4:    888890e0    ....    DCD    2290651360
        0x08002ef8:    03e09088    ....    DCD    65048712
        0x08002efc:    08080804    ....    DCD    134744068
        0x08002f00:    08080204    ....    DCD    134742532
        0x08002f04:    000909fe    ....    DCD    592382
        0x08002f08:    00000f00    ....    DCD    3840
        0x08002f0c:    080810e0    ....    DCD    134746336
        0x08002f10:    03f81008    ....    DCD    66588680
        0x08002f14:    88888884    ....    DCD    2290649220
        0x08002f18:    10ff3f44    D?..    DCD    285163332
        0x08002f1c:    10080808    ....    DCD    268961800
        0x08002f20:    00000fe0    ....    DCD    4064
        0x08002f24:    0f000000    ....    DCD    251658240
        0x08002f28:    f9000ff9    ....    DCD    4177530873
        0x08002f2c:    80ff7f80    ....    DCD    2164227968
        0x08002f30:    081020c0    . ..    DCD    135274688
        0x08002f34:    00000f00    ....    DCD    3840
        0x08002f38:    08040201    ....    DCD    134480385
        0x08002f3c:    10f80fff    ....    DCD    284692479
        0x08002f40:    e0100808    ....    DCD    3759147016
        0x08002f44:    10080810    ....    DCD    268961808
        0x08002f48:    00000fe0    ....    DCD    4064
        0x08002f4c:    000f0000    ....    DCD    983040
        0x08002f50:    0f000000    ....    DCD    251658240
        0x08002f54:    080810f8    ....    DCD    134746360
        0x08002f58:    0fe01008    ....    DCD    266342408
        0x08002f5c:    00000000    ....    DCD    0
        0x08002f60:    10e00f00    ....    DCD    283119360
        0x08002f64:    10080808    ....    DCD    268961800
        0x08002f68:    080403e0    ....    DCD    134480864
        0x08002f6c:    03040808    ....    DCD    50595848
        0x08002f70:    080810f8    ....    DCD    134746360
        0x08002f74:    ffe01008    ....    DCD    4292874248
        0x08002f78:    08080804    ....    DCD    134744068
        0x08002f7c:    10e00304    ....    DCD    283116292
        0x08002f80:    10080808    ....    DCD    268961800
        0x08002f84:    080403f8    ....    DCD    134480888
        0x08002f88:    ff040808    ....    DCD    4278454280
        0x08002f8c:    080810f8    ....    DCD    134746360
        0x08002f90:    0000000f    ....    DCD    15
        0x08002f94:    88888870    p...    DCD    2290649200
        0x08002f98:    08041088    ....    DCD    134484104
        0x08002f9c:    07080808    ....    DCD    117966856
        0x08002fa0:    08ff0808    ....    DCD    150931464
        0x08002fa4:    07000008    ....    DCD    117440520
        0x08002fa8:    00f80008    ....    DCD    16252936
        0x08002fac:    00000000    ....    DCD    0
        0x08002fb0:    080403f8    ....    DCD    134480888
        0x08002fb4:    0f040808    ....    DCD    251922440
        0x08002fb8:    00806018    .`..    DCD    8413208
        0x08002fbc:    00186080    .`..    DCD    1597568
        0x08002fc0:    010e0100    ....    DCD    17694976
        0x08002fc4:    c0380000    ..8.    DCD    3224895488
        0x08002fc8:    38c00000    ...8    DCD    952107008
        0x08002fcc:    c00000c0    ....    DCD    3221225664
        0x08002fd0:    0e010038    8...    DCD    234946616
        0x08002fd4:    00000003    ....    DCD    3
        0x08002fd8:    00010e03    ....    DCD    69123
        0x08002fdc:    80403008    .0@.    DCD    2151690248
        0x08002fe0:    08083040    @0..    DCD    134754368
        0x08002fe4:    01000106    ....    DCD    16777478
        0x08002fe8:    60180806    ...`    DCD    1612187654
        0x08002fec:    60800080    ...`    DCD    1619001472
        0x08002ff0:    71808018    ...q    DCD    1904246808
        0x08002ff4:    0000010e    ....    DCD    270
        0x08002ff8:    48880808    ...H    DCD    1216874504
        0x08002ffc:    0a0c1828    (...    DCD    168564776
        0x08003000:    08080809    ....    DCD    134744073
    microsoftSansSerif_12ptDescriptors
        0x08003004:    00001001    ....    DCD    4097
        0x08003008:    00000000    ....    DCD    0
        0x0800300c:    00021007    ....    DCD    135175
        0x08003010:    00101003    ....    DCD    1052675
        0x08003014:    00161007    ....    DCD    1445895
        0x08003018:    00241007    ..$.    DCD    2363399
        0x0800301c:    00321007    ..2.    DCD    3280903
        0x08003020:    00401007    ..@.    DCD    4198407
        0x08003024:    004e1007    ..N.    DCD    5115911
        0x08003028:    005c1007    ..\.    DCD    6033415
        0x0800302c:    006a1007    ..j.    DCD    6950919
        0x08003030:    00781007    ..x.    DCD    7868423
        0x08003034:    00000000    ....    DCD    0
        0x08003038:    00000000    ....    DCD    0
        0x0800303c:    00000000    ....    DCD    0
        0x08003040:    00000000    ....    DCD    0
        0x08003044:    00000000    ....    DCD    0
        0x08003048:    00000000    ....    DCD    0
        0x0800304c:    00000000    ....    DCD    0
        0x08003050:    0086100b    ....    DCD    8785931
        0x08003054:    009c1008    ....    DCD    10227720
        0x08003058:    00ac100a    ....    DCD    11276298
        0x0800305c:    00c01009    ....    DCD    12587017
        0x08003060:    00d21008    ....    DCD    13766664
        0x08003064:    00e21008    ....    DCD    14815240
        0x08003068:    00f2100a    ....    DCD    15863818
        0x0800306c:    01061008    ....    DCD    17174536
        0x08003070:    01161001    ....    DCD    18223105
        0x08003074:    01181006    ....    DCD    18354182
        0x08003078:    01241008    ..$.    DCD    19140616
        0x0800307c:    01341007    ..4.    DCD    20189191
        0x08003080:    01421009    ..B.    DCD    21106697
        0x08003084:    01541007    ..T.    DCD    22286343
        0x08003088:    0162100a    ..b.    DCD    23203850
        0x0800308c:    01761008    ..v.    DCD    24514568
        0x08003090:    0186100a    ....    DCD    25563146
        0x08003094:    019a1009    ....    DCD    26873865
        0x08003098:    01ac1009    ....    DCD    28053513
        0x0800309c:    01be1009    ....    DCD    29233161
        0x080030a0:    01d01008    ....    DCD    30412808
        0x080030a4:    01e0100b    ....    DCD    31461387
        0x080030a8:    01f6100f    ....    DCD    32903183
        0x080030ac:    0214100b    ....    DCD    34869259
        0x080030b0:    022a100b    ..*.    DCD    36311051
        0x080030b4:    02401008    ..@.    DCD    37752840
        0x080030b8:    00000000    ....    DCD    0
        0x080030bc:    00000000    ....    DCD    0
        0x080030c0:    00000000    ....    DCD    0
        0x080030c4:    00000000    ....    DCD    0
        0x080030c8:    00000000    ....    DCD    0
        0x080030cc:    00000000    ....    DCD    0
        0x080030d0:    02501008    ..P.    DCD    38801416
        0x080030d4:    02601007    ..`.    DCD    39849991
        0x080030d8:    026e1007    ..n.    DCD    40767495
        0x080030dc:    027c1007    ..|.    DCD    41684999
        0x080030e0:    028a1007    ....    DCD    42602503
        0x080030e4:    02981005    ....    DCD    43520005
        0x080030e8:    02a21007    ....    DCD    44175367
        0x080030ec:    02b01007    ....    DCD    45092871
        0x080030f0:    02be1001    ....    DCD    46010369
        0x080030f4:    02c01002    ....    DCD    46141442
        0x080030f8:    02c41007    ....    DCD    46403591
        0x080030fc:    02d21001    ....    DCD    47321089
        0x08003100:    02d4100b    ....    DCD    47452171
        0x08003104:    02ea1007    ....    DCD    48893959
        0x08003108:    02f81007    ....    DCD    49811463
        0x0800310c:    03061007    ....    DCD    50728967
        0x08003110:    03141007    ....    DCD    51646471
        0x08003114:    03221004    ..".    DCD    52563972
        0x08003118:    032a1006    ..*.    DCD    53088262
        0x0800311c:    03361005    ..6.    DCD    53874693
        0x08003120:    03401007    ..@.    DCD    54530055
        0x08003124:    034e1007    ..N.    DCD    55447559
        0x08003128:    035c100b    ..\.    DCD    56365067
        0x0800312c:    03721007    ..r.    DCD    57806855
        0x08003130:    03801007    ....    DCD    58724359
        0x08003134:    038e1006    ....    DCD    59641862
    microsoftSansSerif_12ptFontInfo
        0x08003138:    027a2e02    ..z.    DCD    41561602
        0x0800313c:    08003004    .0..    DCD    134230020
        0x08003140:    08002c6a    j,..    DCD    134229098
    microsoftSansSerif_46ptBitmaps
        0x08003144:    00000000    ....    DCD    0
        0x08003148:    00000000    ....    DCD    0
        0x0800314c:    00000000    ....    DCD    0
        0x08003150:    00000000    ....    DCD    0
        0x08003154:    00000000    ....    DCD    0
        0x08003158:    00000000    ....    DCD    0
        0x0800315c:    80808080    ....    DCD    2155905152
        0x08003160:    1f1f8080    ....    DCD    522158208
        0x08003164:    1f1f1f1f    ....    DCD    522133279
        0x08003168:    c0000000    ....    DCD    3221225472
        0x0800316c:    fcfcf8f0    ....    DCD    4244437232
        0x08003170:    1f3f7efe    .~?.    DCD    524254974
        0x08003174:    1f1f1f1f    ....    DCD    522133279
        0x08003178:    fe7e3f1f    .?~.    DCD    4269686559
        0x0800317c:    f0f8fcfc    ....    DCD    4042849532
        0x08003180:    000000c0    ....    DCD    192
        0x08003184:    fffffc80    ....    DCD    4294966400
        0x08003188:    037fffff    ....    DCD    58720255
        0x0800318c:    00000000    ....    DCD    0
        0x08003190:    00000000    ....    DCD    0
        0x08003194:    00000000    ....    DCD    0
        0x08003198:    ffff7f03    ....    DCD    4294934275
        0x0800319c:    80fcffff    ....    DCD    2164064255
        0x080031a0:    ffffffff    ....    DCD    4294967295
        0x080031a4:    0000ffff    ....    DCD    65535
        0x080031a8:    00000000    ....    DCD    0
        0x080031ac:    00000000    ....    DCD    0
        0x080031b0:    00000000    ....    DCD    0
        0x080031b4:    ffff0000    ....    DCD    4294901760
        0x080031b8:    ffffffff    ....    DCD    4294967295
        0x080031bc:    ffffff7f    ....    DCD    4294967167
        0x080031c0:    0080ffff    ....    DCD    8454143
        0x080031c4:    00000000    ....    DCD    0
        0x080031c8:    00000000    ....    DCD    0
        0x080031cc:    00000000    ....    DCD    0
        0x080031d0:    ffff0000    ....    DCD    4294901760
        0x080031d4:    7fffffff    ....    DCD    2147483647
        0x080031d8:    ff3f0f00    ..?.    DCD    4282322688
        0x080031dc:    f0ffffff    ....    DCD    4043309055
        0x080031e0:    000080c0    ....    DCD    32960
        0x080031e4:    00000000    ....    DCD    0
        0x080031e8:    c0800000    ....    DCD    3229614080
        0x080031ec:    fffffff0    ....    DCD    4294967280
        0x080031f0:    000f3fff    .?..    DCD    999423
        0x080031f4:    00000000    ....    DCD    0
        0x080031f8:    0f0f0703    ....    DCD    252643075
        0x080031fc:    3e3f1f1f    ..?>    DCD    1044324127
        0x08003200:    3e3e3e3e    >>>>    DCD    1044266558
        0x08003204:    1f1f3f3e    >?..    DCD    522141502
        0x08003208:    03070f0f    ....    DCD    50794255
        0x0800320c:    00000000    ....    DCD    0
        0x08003210:    00000000    ....    DCD    0
        0x08003214:    c0808080    ....    DCD    3229646976
        0x08003218:    fff8f0e0    ....    DCD    4294504672
        0x0800321c:    ffffffff    ....    DCD    4294967295
        0x08003220:    1f1f1f1f    ....    DCD    522133279
        0x08003224:    0f0f0f1f    ....    DCD    252645151
        0x08003228:    ffff070f    ....    DCD    4294903567
        0x0800322c:    ffffffff    ....    DCD    4294967295
        0x08003230:    00000000    ....    DCD    0
        0x08003234:    00000000    ....    DCD    0
        0x08003238:    ffff0000    ....    DCD    4294901760
        0x0800323c:    ffffffff    ....    DCD    4294967295
        0x08003240:    00000000    ....    DCD    0
        0x08003244:    00000000    ....    DCD    0
        0x08003248:    ffff0000    ....    DCD    4294901760
        0x0800324c:    ffffffff    ....    DCD    4294967295
        0x08003250:    00000000    ....    DCD    0
        0x08003254:    00000000    ....    DCD    0
        0x08003258:    ffff0000    ....    DCD    4294901760
        0x0800325c:    ffffffff    ....    DCD    4294967295
        0x08003260:    00000000    ....    DCD    0
        0x08003264:    00000000    ....    DCD    0
        0x08003268:    1f1f0000    ....    DCD    522125312
        0x0800326c:    1f1f1f1f    ....    DCD    522133279
        0x08003270:    c0800000    ....    DCD    3229614080
        0x08003274:    fcf8f8f0    ....    DCD    4244175088
        0x08003278:    3f3e7efe    .~>?    DCD    1061060350
        0x0800327c:    1f1f1f1f    ....    DCD    522133279
        0x08003280:    3f3f1f1f    ..??    DCD    1061101343
        0x08003284:    fcfefe7e    ~...    DCD    4244569726
        0x08003288:    c0e0f0f8    ....    DCD    3235967224
        0x0800328c:    1f1c0000    ....    DCD    521928704
        0x08003290:    1f1f1f1f    ....    DCD    522133279
        0x08003294:    00000003    ....    DCD    3
        0x08003298:    00000000    ....    DCD    0
        0x0800329c:    00000000    ....    DCD    0
        0x080032a0:    03000000    ....    DCD    50331648
        0x080032a4:    ffffffff    ....    DCD    4294967295
        0x080032a8:    0000feff    ....    DCD    65279
        0x080032ac:    00000000    ....    DCD    0
        0x080032b0:    00000000    ....    DCD    0
        0x080032b4:    00000000    ....    DCD    0
        0x080032b8:    80000000    ....    DCD    2147483648
        0x080032bc:    f8f0e0c0    ....    DCD    4176535744
        0x080032c0:    3f7fffff    ...?    DCD    1065353215
        0x080032c4:    0001071f    ....    DCD    67359
        0x080032c8:    00000000    ....    DCD    0
        0x080032cc:    80000000    ....    DCD    2147483648
        0x080032d0:    f0f0e0c0    ....    DCD    4042318016
        0x080032d4:    7ffefcf8    ....    DCD    2147417336
        0x080032d8:    070f1f3f    ?...    DCD    118431551
        0x080032dc:    00000103    ....    DCD    259
        0x080032e0:    00000000    ....    DCD    0
        0x080032e4:    f0e08000    ....    DCD    4041244672
        0x080032e8:    fffefcf8    ....    DCD    4294900984
        0x080032ec:    070f1f7f    ....    DCD    118431615
        0x080032f0:    00010303    ....    DCD    66307
        0x080032f4:    00000000    ....    DCD    0
        0x080032f8:    00000000    ....    DCD    0
        0x080032fc:    00000000    ....    DCD    0
        0x08003300:    1f1f1e00    ....    DCD    522132992
        0x08003304:    1f1f1f1f    ....    DCD    522133279
        0x08003308:    1f1f1f1f    ....    DCD    522133279
        0x0800330c:    1f1f1f1f    ....    DCD    522133279
        0x08003310:    1f1f1f1f    ....    DCD    522133279
        0x08003314:    1f1f1f1f    ....    DCD    522133279
        0x08003318:    1f1f1f1f    ....    DCD    522133279
        0x0800331c:    00001f1f    ....    DCD    7967
        0x08003320:    fcf8f0c0    ....    DCD    4244172992
        0x08003324:    3e7efefc    ..~>    DCD    1048510204
        0x08003328:    1f1f1f3f    ?...    DCD    522133311
        0x0800332c:    3f1f1f1f    ...?    DCD    1059004191
        0x08003330:    fcfcfe7e    ~...    DCD    4244438654
        0x08003334:    00c0f0f8    ....    DCD    12644600
        0x08003338:    07000000    ....    DCD    117440512
        0x0800333c:    07070707    ....    DCD    117901063
        0x08003340:    00000107    ....    DCD    263
        0x08003344:    00000000    ....    DCD    0
        0x08003348:    00000000    ....    DCD    0
        0x0800334c:    ffff8100    ....    DCD    4294934784
        0x08003350:    7fffffff    ....    DCD    2147483647
        0x08003354:    00000000    ....    DCD    0
        0x08003358:    00000000    ....    DCD    0
        0x0800335c:    00000000    ....    DCD    0
        0x08003360:    f8f8f800    ....    DCD    4177065984
        0x08003364:    fcfcf8f8    ....    DCD    4244437240
        0x08003368:    effffffe    ....    DCD    4026531838
        0x0800336c:    008183c7    ....    DCD    8487879
        0x08003370:    00000000    ....    DCD    0
        0x08003374:    00000000    ....    DCD    0
        0x08003378:    00000000    ....    DCD    0
        0x0800337c:    00000000    ....    DCD    0
        0x08003380:    01000000    ....    DCD    16777216
        0x08003384:    1f070301    ....    DCD    520553217
        0x08003388:    ffffffff    ....    DCD    4294967295
        0x0800338c:    fc1cf0fc    ....    DCD    4229755132
        0x08003390:    fcfcfcfc    ....    DCD    4244438268
        0x08003394:    0080c0e0    ....    DCD    8437984
        0x08003398:    00000000    ....    DCD    0
        0x0800339c:    00000000    ....    DCD    0
        0x080033a0:    f0c08000    ....    DCD    4039147520
        0x080033a4:    ffffffff    ....    DCD    4294967295
        0x080033a8:    00000f7f    ....    DCD    3967
        0x080033ac:    0f070301    ....    DCD    252117761
        0x080033b0:    1f1f1f0f    ....    DCD    522133263
        0x080033b4:    3e3e3e3f    ?>>>    DCD    1044266559
        0x080033b8:    3f3e3e3e    >>>?    DCD    1061043774
        0x080033bc:    0f1f1f1f    ....    DCD    253697823
        0x080033c0:    00030707    ....    DCD    198407
        0x080033c4:    00000000    ....    DCD    0
        0x080033c8:    00000000    ....    DCD    0
        0x080033cc:    00000000    ....    DCD    0
        0x080033d0:    00000000    ....    DCD    0
        0x080033d4:    f8f0c080    ....    DCD    4176527488
        0x080033d8:    fffffffe    ....    DCD    4294967294
        0x080033dc:    0000ffff    ....    DCD    65535
        0x080033e0:    00000000    ....    DCD    0
        0x080033e4:    00000000    ....    DCD    0
        0x080033e8:    00000000    ....    DCD    0
        0x080033ec:    f0e08000    ....    DCD    4041244672
        0x080033f0:    1f3ffefc    ..?.    DCD    524287740
        0x080033f4:    ffff0307    ....    DCD    4294902535
        0x080033f8:    ffffffff    ....    DCD    4294967295
        0x080033fc:    00000000    ....    DCD    0
        0x08003400:    00000000    ....    DCD    0
        0x08003404:    e0c00000    ....    DCD    3770679296
        0x08003408:    3f7ffcf8    ...?    DCD    1065352440
        0x0800340c:    0001070f    ....    DCD    67343
        0x08003410:    00000000    ....    DCD    0
        0x08003414:    ffffffff    ....    DCD    4294967295
        0x08003418:    0000ffff    ....    DCD    65535
        0x0800341c:    00000000    ....    DCD    0
        0x08003420:    fffef8f0    ....    DCD    4294899952
        0x08003424:    e1e3efff    ....    DCD    3789811711
        0x08003428:    e0e0e0e0    ....    DCD    3772834016
        0x0800342c:    e0e0e0e0    ....    DCD    3772834016
        0x08003430:    ffffe0e0    ....    DCD    4294959328
        0x08003434:    ffffffff    ....    DCD    4294967295
        0x08003438:    e0e0e0e0    ....    DCD    3772834016
        0x0800343c:    0303e0e0    ....    DCD    50585824
        0x08003440:    03030303    ....    DCD    50529027
        0x08003444:    03030303    ....    DCD    50529027
        0x08003448:    03030303    ....    DCD    50529027
        0x0800344c:    03030303    ....    DCD    50529027
        0x08003450:    ffffffff    ....    DCD    4294967295
        0x08003454:    0303ffff    ....    DCD    50593791
        0x08003458:    03030303    ....    DCD    50529027
        0x0800345c:    00000000    ....    DCD    0
        0x08003460:    00000000    ....    DCD    0
        0x08003464:    00000000    ....    DCD    0
        0x08003468:    00000000    ....    DCD    0
        0x0800346c:    1f1f0000    ....    DCD    522125312
        0x08003470:    1f1f1f1f    ....    DCD    522133279
        0x08003474:    00000000    ....    DCD    0
        0x08003478:    00000000    ....    DCD    0
        0x0800347c:    fefe8000    ....    DCD    4278091776
        0x08003480:    3e7efefe    ..~>    DCD    1048510206
        0x08003484:    3e3e3e3e    >>>>    DCD    1044266558
        0x08003488:    3e3e3e3e    >>>>    DCD    1044266558
        0x0800348c:    3e3e3e3e    >>>>    DCD    1044266558
        0x08003490:    3e3e3e3e    >>>>    DCD    1044266558
        0x08003494:    00000000    ....    DCD    0
        0x08003498:    ffffff00    ....    DCD    4294967040
        0x0800349c:    0000ffff    ....    DCD    65535
        0x080034a0:    00000000    ....    DCD    0
        0x080034a4:    00000000    ....    DCD    0
        0x080034a8:    00000000    ....    DCD    0
        0x080034ac:    00000000    ....    DCD    0
        0x080034b0:    00000000    ....    DCD    0
        0x080034b4:    fffffffc    ....    DCD    4294967292
        0x080034b8:    3e3c7bff    .{<>    DCD    1044151295
        0x080034bc:    1f1f1e1e    ....    DCD    522133022
        0x080034c0:    3f1f1f1f    ...?    DCD    1059004191
        0x080034c4:    fcfe7e7f    .~..    DCD    4244536959
        0x080034c8:    e0f0f8fc    ....    DCD    3773888764
        0x080034cc:    00000080    ....    DCD    128
        0x080034d0:    00000000    ....    DCD    0
        0x080034d4:    00000000    ....    DCD    0
        0x080034d8:    00000000    ....    DCD    0
        0x080034dc:    00000000    ....    DCD    0
        0x080034e0:    07010000    ....    DCD    117506048
        0x080034e4:    ffffffff    ....    DCD    4294967295
        0x080034e8:    7c1cfcff    ...|    DCD    2082274559
        0x080034ec:    fcfcfcfc    ....    DCD    4244438268
        0x080034f0:    0080c0f0    ....    DCD    8438000
        0x080034f4:    00000000    ....    DCD    0
        0x080034f8:    00000000    ....    DCD    0
        0x080034fc:    fce0c080    ....    DCD    4242587776
        0x08003500:    ffffffff    ....    DCD    4294967295
        0x08003504:    0000073f    ?...    DCD    1855
        0x08003508:    0f070301    ....    DCD    252117761
        0x0800350c:    3f1f1f0f    ...?    DCD    1059004175
        0x08003510:    3e3e3e3f    ?>>>    DCD    1044266559
        0x08003514:    3f3f3e3e    >>??    DCD    1061109310
        0x08003518:    0f0f1f1f    ....    DCD    252649247
        0x0800351c:    00010307    ....    DCD    66311
        0x08003520:    00000000    ....    DCD    0
        0x08003524:    f0e08000    ....    DCD    4041244672
        0x08003528:    fefefcf8    ....    DCD    4278123768
        0x0800352c:    1f1f3f7e    ~?..    DCD    522141566
        0x08003530:    1f1f1f1f    ....    DCD    522133279
        0x08003534:    fcfe7e3f    ?~..    DCD    4244536895
        0x08003538:    c0f0f8fc    ....    DCD    3237017852
        0x0800353c:    f8000000    ....    DCD    4160749568
        0x08003540:    fffffffe    ....    DCD    4294967294
        0x08003544:    00030fff    ....    DCD    200703
        0x08003548:    00000000    ....    DCD    0
        0x0800354c:    00000000    ....    DCD    0
        0x08003550:    07010000    ....    DCD    117506048
        0x08003554:    07070707    ....    DCD    117901063
        0x08003558:    ffff0006    ....    DCD    4294901766
        0x0800355c:    ffffffff    ....    DCD    4294967295
        0x08003560:    7c78f8f0    ..x|    DCD    2088302832
        0x08003564:    1f1f3e3e    >>..    DCD    522141246
        0x08003568:    3f1f1f1f    ...?    DCD    1059004191
        0x0800356c:    fcfe7e3f    ?~..    DCD    4244536895
        0x08003570:    c0f0f8fc    ....    DCD    3237017852
        0x08003574:    ff7f0080    ....    DCD    4286513280
        0x08003578:    ffffffff    ....    DCD    4294967295
        0x0800357c:    00000081    ....    DCD    129
        0x08003580:    00000000    ....    DCD    0
        0x08003584:    00000000    ....    DCD    0
        0x08003588:    07010000    ....    DCD    117506048
        0x0800358c:    ffffffff    ....    DCD    4294967295
        0x08003590:    0f00fcff    ....    DCD    251723007
        0x08003594:    ffffff3f    ?...    DCD    4294967103
        0x08003598:    80e0f8ff    ....    DCD    2162227455
        0x0800359c:    00000000    ....    DCD    0
        0x080035a0:    00000000    ....    DCD    0
        0x080035a4:    f8e08000    ....    DCD    4175462400
        0x080035a8:    ffffffff    ....    DCD    4294967295
        0x080035ac:    0000073f    ?...    DCD    1855
        0x080035b0:    03010000    ....    DCD    50397184
        0x080035b4:    1f1f0f07    ....    DCD    522129159
        0x080035b8:    3e3e3f1f    .?>>    DCD    1044266783
        0x080035bc:    3f3e3e3e    >>>?    DCD    1061043774
        0x080035c0:    0f1f1f1f    ....    DCD    253697823
        0x080035c4:    00010307    ....    DCD    66311
        0x080035c8:    3e3e0000    ..>>    DCD    1044250624
        0x080035cc:    3e3e3e3e    >>>>    DCD    1044266558
        0x080035d0:    3e3e3e3e    >>>>    DCD    1044266558
        0x080035d4:    3e3e3e3e    >>>>    DCD    1044266558
        0x080035d8:    3e3e3e3e    >>>>    DCD    1044266558
        0x080035dc:    3e3e3e3e    >>>>    DCD    1044266558
        0x080035e0:    fefefefe    ....    DCD    4278124286
        0x080035e4:    00003efe    .>..    DCD    16126
        0x080035e8:    00000000    ....    DCD    0
        0x080035ec:    00000000    ....    DCD    0
        0x080035f0:    00000000    ....    DCD    0
        0x080035f4:    00000000    ....    DCD    0
        0x080035f8:    fffcf080    ....    DCD    4294766720
        0x080035fc:    071fffff    ....    DCD    119537663
        0x08003600:    00000000    ....    DCD    0
        0x08003604:    00000000    ....    DCD    0
        0x08003608:    00000000    ....    DCD    0
        0x0800360c:    00000000    ....    DCD    0
        0x08003610:    fef0c000    ....    DCD    4277190656
        0x08003614:    0f7fffff    ....    DCD    260046847
        0x08003618:    00000003    ....    DCD    3
        0x0800361c:    00000000    ....    DCD    0
        0x08003620:    00000000    ....    DCD    0
        0x08003624:    00000000    ....    DCD    0
        0x08003628:    f8e00000    ....    DCD    4175429632
        0x0800362c:    3ffffffe    ...?    DCD    1073741822
        0x08003630:    0000010f    ....    DCD    271
        0x08003634:    00000000    ....    DCD    0
        0x08003638:    00000000    ....    DCD    0
        0x0800363c:    00000000    ....    DCD    0
        0x08003640:    e0800000    ....    DCD    3766484992
        0x08003644:    fffffffc    ....    DCD    4294967292
        0x08003648:    0001071f    ....    DCD    67359
        0x0800364c:    00000000    ....    DCD    0
        0x08003650:    00000000    ....    DCD    0
        0x08003654:    00000000    ....    DCD    0
        0x08003658:    00000000    ....    DCD    0
        0x0800365c:    1f1f1e10    ....    DCD    522133008
        0x08003660:    00031f1f    ....    DCD    204575
        0x08003664:    00000000    ....    DCD    0
        0x08003668:    00000000    ....    DCD    0
        0x0800366c:    00000000    ....    DCD    0
        0x08003670:    00000000    ....    DCD    0
        0x08003674:    f8f0e000    ....    DCD    4176535552
        0x08003678:    7efefcfc    ...~    DCD    2130640124
        0x0800367c:    1f1f1f3f    ?...    DCD    522133311
        0x08003680:    3f1f1f1f    ...?    DCD    1059004191
        0x08003684:    fcfcfe7e    ~...    DCD    4244438654
        0x08003688:    00e0f0f8    ....    DCD    14741752
        0x0800368c:    00000000    ....    DCD    0
        0x08003690:    ffffff7f    ....    DCD    4294967167
        0x08003694:    00c1ffff    ....    DCD    12713983
        0x08003698:    00000000    ....    DCD    0
        0x0800369c:    00000000    ....    DCD    0
        0x080036a0:    ffffc100    ....    DCD    4294951168
        0x080036a4:    7fffffff    ....    DCD    2147483647
        0x080036a8:    00000000    ....    DCD    0
        0x080036ac:    0f070100    ....    DCD    252117248
        0x080036b0:    ffbfbf1f    ....    DCD    4290756383
        0x080036b4:    f0f8fcfe    ....    DCD    4042849534
        0x080036b8:    fefcf8f0    ....    DCD    4277991664
        0x080036bc:    1fbfbfff    ....    DCD    532660223
        0x080036c0:    0001070f    ....    DCD    67343
        0x080036c4:    f0800000    ....    DCD    4034920448
        0x080036c8:    fffefcf8    ....    DCD    4294900984
        0x080036cc:    0f0f1f7f    ....    DCD    252649343
        0x080036d0:    01030307    ....    DCD    16974599
        0x080036d4:    07030301    ....    DCD    117637889
        0x080036d8:    7f1f0f07    ....    DCD    2132741895
        0x080036dc:    f8fcfeff    ....    DCD    4177329919
        0x080036e0:    ff1f80f0    ....    DCD    4280254704
        0x080036e4:    ffffffff    ....    DCD    4294967295
        0x080036e8:    0080c0f0    ....    DCD    8438000
        0x080036ec:    00000000    ....    DCD    0
        0x080036f0:    00000000    ....    DCD    0
        0x080036f4:    f0c08000    ....    DCD    4039147520
        0x080036f8:    ffffffff    ....    DCD    4294967295
        0x080036fc:    00001fff    ....    DCD    8191
        0x08003700:    0f070301    ....    DCD    252117761
        0x08003704:    1f1f1f0f    ....    DCD    522133263
        0x08003708:    3e3e3e3f    ?>>>    DCD    1044266559
        0x0800370c:    3f3e3e3e    >>>?    DCD    1061043774
        0x08003710:    0f1f1f1f    ....    DCD    253697823
        0x08003714:    0103070f    ....    DCD    16975631
        0x08003718:    00000000    ....    DCD    0
        0x0800371c:    f8f0e0c0    ....    DCD    4176535744
        0x08003720:    3e7efefc    ..~>    DCD    1048510204
        0x08003724:    1f1f1f3f    ?...    DCD    522133311
        0x08003728:    3e3f1f1f    ..?>    DCD    1044324127
        0x0800372c:    f8fcfe7e    ~...    DCD    4177329790
        0x08003730:    00c0e0f0    ....    DCD    12640496
        0x08003734:    fff80000    ....    DCD    4294443008
        0x08003738:    ffffffff    ....    DCD    4294967295
        0x0800373c:    00000107    ....    DCD    263
        0x08003740:    00000000    ....    DCD    0
        0x08003744:    00000000    ....    DCD    0
        0x08003748:    7f070100    ....    DCD    2131165440
        0x0800374c:    ffffffff    ....    DCD    4294967295
        0x08003750:    7f0f80fc    ....    DCD    2131722492
        0x08003754:    ffffffff    ....    DCD    4294967295
        0x08003758:    0080e0f8    ....    DCD    8446200
        0x0800375c:    00000000    ....    DCD    0
        0x08003760:    00000000    ....    DCD    0
        0x08003764:    e0c08080    ....    DCD    3770712192
        0x08003768:    ffffffff    ....    DCD    4294967295
        0x0800376c:    0000ffff    ....    DCD    65535
        0x08003770:    0f070300    ....    DCD    252117760
        0x08003774:    3f1f1f0f    ...?    DCD    1059004175
        0x08003778:    3e3e3e3f    ?>>>    DCD    1044266559
        0x0800377c:    1f1f3e3e    >>..    DCD    522141246
        0x08003780:    e307070f    ....    DCD    3808888591
        0x08003784:    ffffffff    ....    DCD    4294967295
        0x08003788:    38003fff    .?.8    DCD    939540479
        0x0800378c:    f8f8f8f8    ....    DCD    4177066232
        0x08003790:    0080e0f8    ....    DCD    8446200
        0x08003794:    00000000    ....    DCD    0
        0x08003798:    80000000    ....    DCD    2147483648
        0x0800379c:    fffcf0c0    ....    DCD    4294766784
        0x080037a0:    1f7fffff    ....    DCD    528482303
        0x080037a4:    00000007    ....    DCD    7
        0x080037a8:    0f070300    ....    DCD    252117760
        0x080037ac:    3f1f1f0f    ...?    DCD    1059004175
        0x080037b0:    3e3e3e3e    >>>>    DCD    1044266558
        0x080037b4:    1f3f3e3e    >>?.    DCD    524238398
        0x080037b8:    070f1f1f    ....    DCD    118431519
        0x080037bc:    00000103    ....    DCD    259
        0x080037c0:    fefe0000    ....    DCD    4278059008
        0x080037c4:    fefefefe    ....    DCD    4278124286
        0x080037c8:    3e3e3e3e    >>>>    DCD    1044266558
        0x080037cc:    3e3e3e3e    >>>>    DCD    1044266558
        0x080037d0:    3e3e3e3e    >>>>    DCD    1044266558
        0x080037d4:    3e3e3e3e    >>>>    DCD    1044266558
        0x080037d8:    3e3e3e3e    >>>>    DCD    1044266558
        0x080037dc:    ff3e3e3e    >>>.    DCD    4282269246
        0x080037e0:    ffffffff    ....    DCD    4294967295
        0x080037e4:    000000ff    ....    DCD    255
        0x080037e8:    00000000    ....    DCD    0
        0x080037ec:    00000000    ....    DCD    0
        0x080037f0:    00000000    ....    DCD    0
        0x080037f4:    00000000    ....    DCD    0
        0x080037f8:    00000000    ....    DCD    0
        0x080037fc:    ffffffff    ....    DCD    4294967295
        0x08003800:    f0f0ffff    ....    DCD    4042326015
        0x08003804:    f0f0f0f0    ....    DCD    4042322160
        0x08003808:    f0f0f0f0    ....    DCD    4042322160
        0x0800380c:    f0f0f0f0    ....    DCD    4042322160
        0x08003810:    f0f0f0f0    ....    DCD    4042322160
        0x08003814:    0000f0f0    ....    DCD    61680
        0x08003818:    ffffff00    ....    DCD    4294967040
        0x0800381c:    01ffffff    ....    DCD    33554431
        0x08003820:    01010101    ....    DCD    16843009
        0x08003824:    01010101    ....    DCD    16843009
        0x08003828:    01010101    ....    DCD    16843009
        0x0800382c:    01010101    ....    DCD    16843009
        0x08003830:    00010101    ....    DCD    65793
        0x08003834:    ffff0000    ....    DCD    4294901760
        0x08003838:    ffffffff    ....    DCD    4294967295
        0x0800383c:    00000000    ....    DCD    0
        0x08003840:    00000000    ....    DCD    0
        0x08003844:    00000000    ....    DCD    0
        0x08003848:    00000000    ....    DCD    0
        0x0800384c:    00000000    ....    DCD    0
        0x08003850:    1f000000    ....    DCD    520093696
        0x08003854:    1f1f1f1f    ....    DCD    522133279
        0x08003858:    0000001f    ....    DCD    31
        0x0800385c:    00000000    ....    DCD    0
        0x08003860:    00000000    ....    DCD    0
        0x08003864:    00000000    ....    DCD    0
        0x08003868:    00000000    ....    DCD    0
        0x0800386c:    00000000    ....    DCD    0
        0x08003870:    3e3e3e3e    >>>>    DCD    1044266558
        0x08003874:    3e3e3e3e    >>>>    DCD    1044266558
        0x08003878:    3e3e3e3e    >>>>    DCD    1044266558
        0x0800387c:    fefe3e3e    >>..    DCD    4278074942
        0x08003880:    fefefefe    ....    DCD    4278124286
        0x08003884:    3e3e3e3e    >>>>    DCD    1044266558
        0x08003888:    3e3e3e3e    >>>>    DCD    1044266558
        0x0800388c:    3e3e3e3e    >>>>    DCD    1044266558
        0x08003890:    00003e3e    >>..    DCD    15934
        0x08003894:    00000000    ....    DCD    0
        0x08003898:    00000000    ....    DCD    0
        0x0800389c:    00000000    ....    DCD    0
        0x080038a0:    ffffffff    ....    DCD    4294967295
        0x080038a4:    0000ffff    ....    DCD    65535
        0x080038a8:    00000000    ....    DCD    0
        0x080038ac:    00000000    ....    DCD    0
        0x080038b0:    00000000    ....    DCD    0
        0x080038b4:    00000000    ....    DCD    0
        0x080038b8:    00000000    ....    DCD    0
        0x080038bc:    00000000    ....    DCD    0
        0x080038c0:    ffff0000    ....    DCD    4294901760
        0x080038c4:    ffffffff    ....    DCD    4294967295
        0x080038c8:    00000000    ....    DCD    0
        0x080038cc:    00000000    ....    DCD    0
        0x080038d0:    00000000    ....    DCD    0
        0x080038d4:    00000000    ....    DCD    0
        0x080038d8:    00000000    ....    DCD    0
        0x080038dc:    00000000    ....    DCD    0
        0x080038e0:    00000000    ....    DCD    0
        0x080038e4:    ffffffff    ....    DCD    4294967295
        0x080038e8:    0000ffff    ....    DCD    65535
        0x080038ec:    00000000    ....    DCD    0
        0x080038f0:    00000000    ....    DCD    0
        0x080038f4:    00000000    ....    DCD    0
        0x080038f8:    00000000    ....    DCD    0
        0x080038fc:    00000000    ....    DCD    0
        0x08003900:    00000000    ....    DCD    0
        0x08003904:    ffff0000    ....    DCD    4294901760
        0x08003908:    ffffffff    ....    DCD    4294967295
        0x0800390c:    00000000    ....    DCD    0
        0x08003910:    00000000    ....    DCD    0
        0x08003914:    00000000    ....    DCD    0
        0x08003918:    00000000    ....    DCD    0
        0x0800391c:    00000000    ....    DCD    0
        0x08003920:    00000000    ....    DCD    0
        0x08003924:    00000000    ....    DCD    0
        0x08003928:    1f1f1f1f    ....    DCD    522133279
        0x0800392c:    00001f1f    ....    DCD    7967
        0x08003930:    00000000    ....    DCD    0
        0x08003934:    00000000    ....    DCD    0
        0x08003938:    00000000    ....    DCD    0
    microsoftSansSerif_46ptDescriptors
        0x0800393c:    00002e06    ....    DCD    11782
        0x08003940:    00000000    ....    DCD    0
        0x08003944:    00242e1c    ..$.    DCD    2371100
        0x08003948:    00cc2e10    ....    DCD    13381136
        0x0800394c:    012c2e1d    ..,.    DCD    19672605
        0x08003950:    01da2e1c    ....    DCD    31075868
        0x08003954:    02822e1e    ....    DCD    42085918
        0x08003958:    03362e1c    ..6.    DCD    53882396
        0x0800395c:    03de2e1c    ....    DCD    64892444
        0x08003960:    04862e1c    ....    DCD    75902492
        0x08003964:    052e2e1c    ....    DCD    86912540
        0x08003968:    05d62e1c    ....    DCD    97922588
        0x0800396c:    00000000    ....    DCD    0
        0x08003970:    00000000    ....    DCD    0
        0x08003974:    00000000    ....    DCD    0
        0x08003978:    00000000    ....    DCD    0
        0x0800397c:    00000000    ....    DCD    0
        0x08003980:    00000000    ....    DCD    0
        0x08003984:    00000000    ....    DCD    0
        0x08003988:    00000000    ....    DCD    0
        0x0800398c:    00000000    ....    DCD    0
        0x08003990:    00000000    ....    DCD    0
        0x08003994:    00000000    ....    DCD    0
        0x08003998:    00000000    ....    DCD    0
        0x0800399c:    067e2e1d    ..~.    DCD    108932637
        0x080039a0:    00000000    ....    DCD    0
        0x080039a4:    00000000    ....    DCD    0
        0x080039a8:    00000000    ....    DCD    0
        0x080039ac:    00000000    ....    DCD    0
        0x080039b0:    00000000    ....    DCD    0
        0x080039b4:    00000000    ....    DCD    0
        0x080039b8:    00000000    ....    DCD    0
        0x080039bc:    00000000    ....    DCD    0
        0x080039c0:    00000000    ....    DCD    0
        0x080039c4:    00000000    ....    DCD    0
        0x080039c8:    00000000    ....    DCD    0
        0x080039cc:    00000000    ....    DCD    0
        0x080039d0:    00000000    ....    DCD    0
        0x080039d4:    072c2e22    ".,.    DCD    120335906
    microsoftSansSerif_46ptFontInfo
        0x080039d8:    02542e06    ..T.    DCD    39071238
        0x080039dc:    0800393c    <9..    DCD    134232380
        0x080039e0:    08003144    D1..    DCD    134230340
    consolas_18ptBitmaps
        0x080039e4:    fff00000    ....    DCD    4293918720
        0x080039e8:    ff1f033f    ?...    DCD    4280222527
        0x080039ec:    0000c0f8    ....    DCD    49400
        0x080039f0:    0f3f7f78    x.?.    DCD    255819640
        0x080039f4:    0f0e0e0e    ....    DCD    252579342
        0x080039f8:    707e7f0f    ..~p    DCD    1887338255
        0x080039fc:    f0e0c080    ....    DCD    4041261184
        0x08003a00:    808090b8    ....    DCD    2155909304
        0x08003a04:    80808080    ....    DCD    2155905152
        0x08003a08:    07030180    ....    DCD    117637504
        0x08003a0c:    01091d0f    ....    DCD    17374479
        0x08003a10:    01010101    ....    DCD    16843009
        0x08003a14:    80800101    ....    DCD    2155872513
        0x08003a18:    80808080    ....    DCD    2155905152
        0x08003a1c:    f0b89080    ....    DCD    4038627456
        0x08003a20:    0180c0e0    ....    DCD    25215200
        0x08003a24:    01010101    ....    DCD    16843009
        0x08003a28:    1d090101    ....    DCD    487129345
        0x08003a2c:    0103070f    ....    DCD    16975631
    consolas_18ptDescriptors
        0x08003a30:    00000f0c    ....    DCD    3852
        0x08003a34:    00180f0d    ....    DCD    1576717
        0x08003a38:    00320f0d    ..2.    DCD    3280653
    consolas_18ptFontInfo
        0x08003a3c:    02020002    ....    DCD    33685506
        0x08003a40:    08003a30    0:..    DCD    134232624
        0x08003a44:    080039e4    .9..    DCD    134232548
    microsoftSansSerif_20ptBitmaps
        0x08003a48:    00000000    ....    DCD    0
        0x08003a4c:    07070000    ....    DCD    117899264
        0x08003a50:    fef8e007    ....    DCD    4277723143
        0x08003a54:    0303071e    ....    DCD    50530078
        0x08003a58:    1e070303    ....    DCD    503776003
        0x08003a5c:    3fe0f8fe    ...?    DCD    1071708414
        0x08003a60:    00c0ffff    ....    DCD    12648447
        0x08003a64:    00000000    ....    DCD    0
        0x08003a68:    ffffc000    ....    DCD    4294950912
        0x08003a6c:    0300003f    ?...    DCD    50331711
        0x08003a70:    06060703    ....    DCD    101058307
        0x08003a74:    03070606    ....    DCD    50791942
        0x08003a78:    30000003    ...0    DCD    805306371
        0x08003a7c:    3c383030    008<    DCD    1010315312
        0x08003a80:    00ffffff    ....    DCD    16777215
        0x08003a84:    00000000    ....    DCD    0
        0x08003a88:    00ffffff    ....    DCD    16777215
        0x08003a8c:    00000000    ....    DCD    0
        0x08003a90:    30070707    ...0    DCD    805766919
        0x08003a94:    070e3e3c    <>..    DCD    118373948
        0x08003a98:    03030303    ....    DCD    50529027
        0x08003a9c:    fcfe8f07    ....    DCD    4244541191
        0x08003aa0:    c08000f8    ....    DCD    3229614328
        0x08003aa4:    3870e0e0    ..p8    DCD    946921696
        0x08003aa8:    070e1c1c    ....    DCD    118365212
        0x08003aac:    06000103    ....    DCD    100663555
        0x08003ab0:    06070707    ....    DCD    101123847
        0x08003ab4:    06060606    ....    DCD    101058054
        0x08003ab8:    06060606    ....    DCD    101058054
        0x08003abc:    1e1c1806    ....    DCD    505157638
        0x08003ac0:    0303070f    ....    DCD    50530063
        0x08003ac4:    fe878303    ....    DCD    4270293763
        0x08003ac8:    c00078fe    .x..    DCD    3221256446
        0x08003acc:    0080c0c0    ....    DCD    8437952
        0x08003ad0:    03030303    ....    DCD    50529027
        0x08003ad4:    fcfe8f07    ....    DCD    4244541191
        0x08003ad8:    030100f8    ....    DCD    50397432
        0x08003adc:    06060707    ....    DCD    101058311
        0x08003ae0:    03070606    ....    DCD    50791942
        0x08003ae4:    00000103    ....    DCD    259
        0x08003ae8:    80000000    ....    DCD    2147483648
        0x08003aec:    1e78f0e0    ..x.    DCD    511242464
        0x08003af0:    00ffffff    ....    DCD    16777215
        0x08003af4:    78700000    ..px    DCD    2020605952
        0x08003af8:    63676f7c    |ogc    DCD    1667723132
        0x08003afc:    ff606060    ```.    DCD    4284506208
        0x08003b00:    6060ffff    ..``    DCD    1616969727
        0x08003b04:    00000060    `...    DCD    96
        0x08003b08:    00000000    ....    DCD    0
        0x08003b0c:    07070000    ....    DCD    117899264
        0x08003b10:    00000007    ....    DCD    7
        0x08003b14:    ffffe000    ....    DCD    4294959104
        0x08003b18:    c3c3c39f    ....    DCD    3284386719
        0x08003b1c:    8383c3c3    ....    DCD    2206450627
        0x08003b20:    c3c00003    ....    DCD    3284140035
        0x08003b24:    010183c3    ....    DCD    16876483
        0x08003b28:    01000000    ....    DCD    16777216
        0x08003b2c:    7cffff83    ...|    DCD    2097151875
        0x08003b30:    07030100    ....    DCD    117637376
        0x08003b34:    06060607    ....    DCD    101058055
        0x08003b38:    03030706    ....    DCD    50530054
        0x08003b3c:    f8e00001    ....    DCD    4175429633
        0x08003b40:    878f3efc    .>..    DCD    2274311932
        0x08003b44:    87838383    ....    DCD    2273543043
        0x08003b48:    181c1e07    ....    DCD    404495879
        0x08003b4c:    c3ffff3f    ?...    DCD    3288334143
        0x08003b50:    01010103    ....    DCD    16843011
        0x08003b54:    ff870301    ....    DCD    4287038209
        0x08003b58:    00007cfe    .|..    DCD    31998
        0x08003b5c:    07070301    ....    DCD    117900033
        0x08003b60:    07060606    ....    DCD    117835270
        0x08003b64:    00010303    ....    DCD    66307
        0x08003b68:    03030303    ....    DCD    50529027
        0x08003b6c:    03030303    ....    DCD    50529027
        0x08003b70:    7fffe383    ....    DCD    2147476355
        0x08003b74:    0000071f    ....    DCD    1823
        0x08003b78:    e0000000    ....    DCD    3758096384
        0x08003b7c:    073ffef8    ..?.    DCD    121634552
        0x08003b80:    00000001    ....    DCD    1
        0x08003b84:    04000000    ....    DCD    67108864
        0x08003b88:    00030707    ....    DCD    198407
        0x08003b8c:    00000000    ....    DCD    0
        0x08003b90:    7c000000    ...|    DCD    2080374784
        0x08003b94:    83c7fefe    ....    DCD    2210922238
        0x08003b98:    c7830303    ....    DCD    3347251971
        0x08003b9c:    007cfefe    ..|.    DCD    8191742
        0x08003ba0:    8ffcf8f0    ....    DCD    2415720688
        0x08003ba4:    03030707    ....    DCD    50530055
        0x08003ba8:    fc8f0707    ....    DCD    4237231879
        0x08003bac:    0100f0f8    ....    DCD    16838904
        0x08003bb0:    06070703    ....    DCD    101123843
        0x08003bb4:    07060606    ....    DCD    117835270
        0x08003bb8:    00010307    ....    DCD    66311
        0x08003bbc:    0efefcf0    ....    DCD    251591920
        0x08003bc0:    03030307    ....    DCD    50529031
        0x08003bc4:    fc1e0707    ....    DCD    4229826311
        0x08003bc8:    c3c1e0f8    ....    DCD    3284263160
        0x08003bcc:    0c0e07c7    ....    DCD    202246087
        0x08003bd0:    8e0c0c0c    ....    DCD    2383154188
        0x08003bd4:    3fffffe6    ...?    DCD    1073741798
        0x08003bd8:    07030100    ....    DCD    117637376
        0x08003bdc:    06060607    ....    DCD    101058055
        0x08003be0:    01030707    ....    DCD    16975623
        0x08003be4:    ffff0000    ....    DCD    4294901760
        0x08003be8:    030303ff    ....    DCD    50529279
        0x08003bec:    03030303    ....    DCD    50529027
        0x08003bf0:    03030303    ....    DCD    50529027
        0x08003bf4:    03ffffff    ....    DCD    67108863
        0x08003bf8:    03030303    ....    DCD    50529027
        0x08003bfc:    03030303    ....    DCD    50529027
        0x08003c00:    07070003    ....    DCD    117899267
        0x08003c04:    00000007    ....    DCD    7
        0x08003c08:    00000000    ....    DCD    0
        0x08003c0c:    00000000    ....    DCD    0
        0x08003c10:    03030303    ....    DCD    50529027
        0x08003c14:    ffff0303    ....    DCD    4294902531
        0x08003c18:    030303ff    ....    DCD    50529279
        0x08003c1c:    00030303    ....    DCD    197379
        0x08003c20:    00000000    ....    DCD    0
        0x08003c24:    ffffff00    ....    DCD    4294967040
        0x08003c28:    00000000    ....    DCD    0
        0x08003c2c:    00000000    ....    DCD    0
        0x08003c30:    00000000    ....    DCD    0
        0x08003c34:    00070707    ....    DCD    460551
        0x08003c38:    00000000    ....    DCD    0
        0x08003c3c:    0000        ..      DCW    0
    microsoftSansSerif_20ptDescriptors
        0x08003c3e:    1303        ..      DCW    4867
        0x08003c40:    00000000    ....    DCD    0
        0x08003c44:    130e0000    ....    DCD    319684608
        0x08003c48:    13080009    ....    DCD    319291401
        0x08003c4c:    130e0033    3...    DCD    319684659
        0x08003c50:    130e004b    K...    DCD    319684683
        0x08003c54:    130f0075    u...    DCD    319750261
        0x08003c58:    130e009f    ....    DCD    319684767
        0x08003c5c:    130e00cc    ....    DCD    319684812
        0x08003c60:    130e00f6    ....    DCD    319684854
        0x08003c64:    130e0120     ...    DCD    319684896
        0x08003c68:    130e014a    J...    DCD    319684938
        0x08003c6c:    00000174    t...    DCD    372
        0x08003c70:    00000000    ....    DCD    0
        0x08003c74:    00000000    ....    DCD    0
        0x08003c78:    00000000    ....    DCD    0
        0x08003c7c:    00000000    ....    DCD    0
        0x08003c80:    00000000    ....    DCD    0
        0x08003c84:    00000000    ....    DCD    0
        0x08003c88:    00000000    ....    DCD    0
        0x08003c8c:    00000000    ....    DCD    0
        0x08003c90:    00000000    ....    DCD    0
        0x08003c94:    00000000    ....    DCD    0
        0x08003c98:    00000000    ....    DCD    0
        0x08003c9c:    130e0000    ....    DCD    319684608
        0x08003ca0:    0000019e    ....    DCD    414
        0x08003ca4:    00000000    ....    DCD    0
        0x08003ca8:    00000000    ....    DCD    0
        0x08003cac:    00000000    ....    DCD    0
        0x08003cb0:    00000000    ....    DCD    0
        0x08003cb4:    00000000    ....    DCD    0
        0x08003cb8:    00000000    ....    DCD    0
        0x08003cbc:    00000000    ....    DCD    0
        0x08003cc0:    00000000    ....    DCD    0
        0x08003cc4:    00000000    ....    DCD    0
        0x08003cc8:    00000000    ....    DCD    0
        0x08003ccc:    00000000    ....    DCD    0
        0x08003cd0:    00000000    ....    DCD    0
        0x08003cd4:    130f0000    ....    DCD    319750144
        0x08003cd8:    000001c8    ....    DCD    456
    microsoftSansSerif_20ptFontInfo
        0x08003cdc:    02542e03    ..T.    DCD    39071235
        0x08003ce0:    08003c3e    ><..    DCD    134233150
        0x08003ce4:    08003a48    H:..    DCD    134232648
    consolas_8ptBitmaps
        0x08003ce8:    312142fc    .B!1    DCD    824263420
        0x08003cec:    00fc0a11    ....    DCD    16517649
        0x08003cf0:    02020201    ....    DCD    33686017
        0x08003cf4:    02040001    ....    DCD    33816577
        0x08003cf8:    0000ff01    ....    DCD    65281
        0x08003cfc:    02020200    ....    DCD    33686016
        0x08003d00:    02020203    ....    DCD    33686019
        0x08003d04:    41810102    ...A    DCD    1098973442
        0x08003d08:    02001e23    #...    DCD    33562147
        0x08003d0c:    02020203    ....    DCD    33686019
        0x08003d10:    11010202    ....    DCD    285278722
        0x08003d14:    ee391111    ..9.    DCD    3996717329
        0x08003d18:    02020202    ....    DCD    33686018
        0x08003d1c:    e0c00001    ....    DCD    3770679297
        0x08003d20:    ff838e98    ....    DCD    4286811800
        0x08003d24:    00008080    ....    DCD    32896
        0x08003d28:    03000000    ....    DCD    50331648
        0x08003d2c:    111f0000    ....    DCD    287244288
        0x08003d30:    e0311111    ..1.    DCD    3761312017
        0x08003d34:    02020202    ....    DCD    33686018
        0x08003d38:    26f80001    ...&    DCD    653787137
        0x08003d3c:    31111113    ...1    DCD    823202067
        0x08003d40:    020100e0    ....    DCD    33620192
        0x08003d44:    01010202    ....    DCD    16843266
        0x08003d48:    e1810101    ....    DCD    3783328001
        0x08003d4c:    00030f39    9...    DCD    200505
        0x08003d50:    00000302    ....    DCD    770
        0x08003d54:    29ce0000    ...)    DCD    701366272
        0x08003d58:    ce291111    ..).    DCD    3458797841
        0x08003d5c:    02020301    ....    DCD    33686273
        0x08003d60:    321e0102    ...2    DCD    840827138
        0x08003d64:    92212121    !!!.    DCD    2451644705
        0x08003d68:    0202007c    |...    DCD    33685628
        0x08003d6c:    00010102    ....    DCD    65794
    consolas_8ptDescriptors
        0x08003d70:    00000a07    ....    DCD    2567
        0x08003d74:    000e0a07    ....    DCD    920071
        0x08003d78:    001c0a07    ....    DCD    1837575
        0x08003d7c:    002a0a06    ..*.    DCD    2755078
        0x08003d80:    00360a08    ..6.    DCD    3541512
        0x08003d84:    00460a06    ..F.    DCD    4590086
        0x08003d88:    00520a07    ..R.    DCD    5376519
        0x08003d8c:    00600a07    ..`.    DCD    6294023
        0x08003d90:    006e0a06    ..n.    DCD    7211526
        0x08003d94:    007a0a07    ..z.    DCD    7997959
    consolas_8ptFontInfo
        0x08003d98:    02393002    .09.    DCD    37302274
        0x08003d9c:    08003d70    p=..    DCD    134233456
        0x08003da0:    08003ce8    .<..    DCD    134233320
    .constdata
    CHANNEL_OFFSET_TAB
        0x08003da4:    44301c08    ..0D    DCD    1144003592
        0x08003da8:    6c58        Xl      DCW    27736
        0x08003daa:    80          .       DCB    128
    OFFSET_TAB_CCMRx
        0x08003dab:    00          .       DCB    0
        0x08003dac:    04000000    ....    DCD    67108864
        0x08003db0:    0404        ..      DCW    1028
    SHIFT_TAB_OCxx
        0x08003db2:    0000        ..      DCW    0
        0x08003db4:    00000008    ....    DCD    8
        0x08003db8:    08          .       DCB    8
    SHIFT_TAB_ICxx
        0x08003db9:    000008      ...     DCB    0,0,8
        0x08003dbc:    08000000    ....    DCD    134217728
    SHIFT_TAB_CCxP
        0x08003dc0:    06040200    ....    DCD    100925952
        0x08003dc4:    0a08        ..      DCW    2568
        0x08003dc6:    0c          .       DCB    12
    SHIFT_TAB_OISx
        0x08003dc7:    00          .       DCB    0
        0x08003dc8:    04030201    ....    DCD    67305985
        0x08003dcc:    00000605    ....    DCD    1541
    .constdata
    CHANNEL_OFFSET_TAB
        0x08003dd0:    44301c08    ..0D    DCD    1144003592
        0x08003dd4:    6c58        Xl      DCW    27736
        0x08003dd6:    80          .       DCB    128
    OFFSET_TAB_CCMRx
        0x08003dd7:    00          .       DCB    0
        0x08003dd8:    04000000    ....    DCD    67108864
        0x08003ddc:    0404        ..      DCW    1028
    SHIFT_TAB_OCxx
        0x08003dde:    0000        ..      DCW    0
        0x08003de0:    00000008    ....    DCD    8
        0x08003de4:    08          .       DCB    8
    SHIFT_TAB_ICxx
        0x08003de5:    000008      ...     DCB    0,0,8
        0x08003de8:    08000000    ....    DCD    134217728
    SHIFT_TAB_CCxP
        0x08003dec:    06040200    ....    DCD    100925952
        0x08003df0:    0a08        ..      DCW    2568
        0x08003df2:    0c          .       DCB    12
    SHIFT_TAB_OISx
        0x08003df3:    00          .       DCB    0
        0x08003df4:    04030201    ....    DCD    67305985
        0x08003df8:    0605        ..      DCW    1541
    Menu_size
        0x08003dfa:    0021        !.      DCW    33
        0x08003dfc:    00000000    ....    DCD    0
    enc_setup
        0x08003e00:    00000000    ....    DCD    0
        0x08003e04:    00090000    ....    DCD    589824
    Region$$Table$$Base
        0x08003e08:    08003e28    (>..    DCD    134233640
        0x08003e0c:    20000000    ...     DCD    536870912
        0x08003e10:    00000598    ....    DCD    1432
        0x08003e14:    0800020c    ....    DCD    134218252
        0x08003e18:    08004098    .@..    DCD    134234264
        0x08003e1c:    20000598    ...     DCD    536872344
        0x08003e20:    00003a6c    l:..    DCD    14956
        0x08003e24:    08001cb4    ....    DCD    134225076
    Region$$Table$$Limit

** Section #2 'RW_IRAM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 624 bytes (alignment 4)
    Address: 0x20000000


** Section #3 'RW_IRAM1' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 14956 bytes (alignment 8)
    Address: 0x20000598


** Section #4 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #5 '.debug_frame' (SHT_PROGBITS)
    Size   : 3648 bytes


** Section #6 '.debug_info' (SHT_PROGBITS)
    Size   : 193112 bytes


** Section #7 '.debug_line' (SHT_PROGBITS)
    Size   : 25960 bytes


** Section #8 '.debug_loc' (SHT_PROGBITS)
    Size   : 8540 bytes


** Section #9 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 523460 bytes


** Section #10 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 5029 bytes


** Section #11 '.symtab' (SHT_SYMTAB)
    Size   : 10544 bytes (alignment 4)
    String table #12 '.strtab'
    Last local symbol no. 455


** Section #12 '.strtab' (SHT_STRTAB)
    Size   : 8904 bytes


** Section #13 '.note' (SHT_NOTE)
    Size   : 28 bytes (alignment 4)


** Section #14 '.comment' (SHT_PROGBITS)
    Size   : 23496 bytes


** Section #15 '.shstrtab' (SHT_STRTAB)
    Size   : 156 bytes


